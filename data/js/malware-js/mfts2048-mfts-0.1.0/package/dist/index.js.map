{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/// <reference path=\"../m3u8-parser.d.ts\" />\r\n\r\nimport path from 'node:path'\r\nimport { existsSync } from 'node:fs'\r\nimport { exec } from 'node:child_process'\r\nimport type { CipherCCMTypes } from 'node:crypto'\r\nimport crypto, { createDecipheriv } from 'node:crypto'\r\nimport { readFile, writeFile } from 'node:fs/promises'\r\nimport { assignIn } from 'lodash-es'\r\nimport type { Segment } from 'm3u8-parser'\r\nimport { Parser } from 'm3u8-parser'\r\nimport { PromisePool } from '@supercharge/promise-pool'\r\nimport download from 'download'\r\nimport { ensureDirSync, ensureFileSync } from 'fs-extra'\r\n\r\nexport interface Alias {\r\n  key_key: string\r\n  index_m3u8: string\r\n  index_m3u8_back: string\r\n  mp4: ((key: string) => string) | string\r\n}\r\n\r\nexport interface Options {\r\n  key: string\r\n  url: string\r\n  target: string\r\n  alias: Alias\r\n  concurrency: number\r\n}\r\n\r\nexport type OptionsWithRequiredFields = Required<Pick<Options, 'key' | 'url'>> & Partial<Options>\r\n\r\nexport async function createDownload(_options: OptionsWithRequiredFields) {\r\n  const options: Options = {\r\n    key: '',\r\n    url: '',\r\n    target: path.join(__dirname),\r\n    alias: {\r\n      key_key: 'key.key',\r\n      index_m3u8: 'index.m3u8',\r\n      index_m3u8_back: 'index.m3u8.back',\r\n      mp4: (key: string) => `${key}.mp4`,\r\n    },\r\n    concurrency: 5,\r\n  }\r\n\r\n  assignIn(options, _options)\r\n\r\n  const output_m3u8 = path.join(options.target, options.alias.index_m3u8)\r\n  const output_key = path.join(options.target, options.alias.key_key)\r\n  const output_mp4 = typeof options.alias.mp4 === 'string'\r\n    ? path.join(options.target, options.alias.mp4)\r\n    : path.join(options.target, options.alias.mp4(options.key))\r\n\r\n  const segments = await parseM3u8(options.url)\r\n\r\n  let aes = ''\r\n  const { errors, results } = await PromisePool\r\n    .for(segments)\r\n    .useCorrespondingResults()\r\n    .withConcurrency(options.concurrency)\r\n    .onTaskStarted(() => {\r\n\r\n    })\r\n    .onTaskFinished(() => {\r\n\r\n    })\r\n    .handleError((_error, _item, pool) => {\r\n      pool.stop()\r\n    })\r\n    .process(async (segment, index) => {\r\n      aes = aes || await parseKey(segment)\r\n\r\n      const output_ts_name = `${`${index}`.padStart(4, '0')}.ts`\r\n      const output_ts_temp = path.join(options.target, 'temp')\r\n      const output_ts = path.join(options.target, 'temp', output_ts_name)\r\n      ensureDirSync(output_ts_temp)\r\n\r\n      if (existsSync(output_ts))\r\n        return output_ts\r\n\r\n      const stream = await download(segment.uri)\r\n      const iv = crypto.randomBytes(16)\r\n      const algorithm: CipherCCMTypes = `${segment.key.method}-cbc`.toLowerCase() as CipherCCMTypes\r\n      const cipher = createDecipheriv(algorithm, aes, iv)\r\n      cipher.on('error', console.error)\r\n\r\n      const segmentData = Buffer.concat([cipher.update(stream), cipher.final()])\r\n\r\n      await writeFile(output_ts, segmentData)\r\n\r\n      return output_ts\r\n    })\r\n\r\n  if (errors.length) {\r\n    console.error(`存在异常${errors.length}`, errors[0])\r\n  }\r\n  else {\r\n    console.log('results', results)\r\n    await mergeTs(results as string[])\r\n  }\r\n\r\n  async function parseM3u8(url: string) {\r\n    const content = existsSync(output_m3u8)\r\n      ? await readFile(output_m3u8, {\r\n        encoding: 'utf-8',\r\n      })\r\n      : (await download(url, options.target, {\r\n          filename: options.alias.index_m3u8_back,\r\n        })).toString()\r\n\r\n    const parser = new Parser()\r\n    parser.push(content)\r\n    parser.end()\r\n\r\n    return parser.manifest.segments\r\n  }\r\n\r\n  async function parseKey(segment: Segment) {\r\n    if (!existsSync(output_key))\r\n      await download(segment.key!.uri, options.target)\r\n\r\n    return await readFile(output_key, { encoding: 'utf-8' })\r\n  }\r\n\r\n  async function mergeTs(results: string[]) {\r\n    const tempPath = path.join(options.target, 'temp.txt')\r\n    ensureFileSync(tempPath)\r\n    const tempContent = results.filter(Boolean).map(url => `file '${url as string}'`).join('\\r')\r\n\r\n    await writeFile(\r\n      tempPath,\r\n      tempContent,\r\n      'utf-8',\r\n    )\r\n    await ffmpegMerge(tempPath)\r\n  }\r\n\r\n  function ffmpegMerge(input: string): Promise<string> {\r\n    const cmd = `ffmpeg -f concat -safe 0 -i ${input} -c copy -y ${output_mp4}`\r\n    return new Promise((resolve) => {\r\n      exec(cmd, (err) => {\r\n        err && console.error(`exec error: ${err}`)\r\n\r\n        resolve(output_mp4)\r\n      })\r\n    })\r\n  }\r\n}\r\n"],"mappings":"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","names":["path","download","crypto","results"]}