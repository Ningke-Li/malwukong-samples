"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const ethers_1 = require("ethers");
const BridgeToken__factory_1 = require("@peersyst/xrp-evm-contracts/dist/typechain/factories/BridgeToken__factory");
const Logger_1 = require("../util/Logger");
const program = new commander_1.Command("mint-tokens")
    .option("-o, --owner-seed <value>", "Owner seed")
    .option("-t, --token-address <value>", "Token address")
    .option("-a, --amount <value>", "Token code")
    .option("-d, --destination-address <value>", "Destination address")
    .option("-n, --node <value>", "The network node", "https://rpc-evm-sidechain.peersyst.tech")
    .action(async ({ node, ownerSeed, amount, tokenAddress, destinationAddress }) => {
    if (node && ownerSeed && amount && tokenAddress) {
        try {
            const provider = new ethers_1.ethers.providers.JsonRpcProvider(node);
            const signerWallet = new ethers_1.ethers.Wallet(ownerSeed, provider);
            const bridgeTokenFactory = new BridgeToken__factory_1.BridgeToken__factory(signerWallet);
            const bridgeToken = bridgeTokenFactory.attach(tokenAddress);
            const dest = destinationAddress || signerWallet.address;
            (0, Logger_1.Log)(Logger_1.LogType.Tool, Logger_1.LogStatus.ToDo, `Minting ${amount} tokens to address ${dest}...`);
            const parsedAmount = ethers_1.ethers.utils.parseEther(amount.toString());
            await (await bridgeToken.mint(dest, parsedAmount)).wait();
            (0, Logger_1.Log)(Logger_1.LogType.Tool, Logger_1.LogStatus.Done, `Minted ${amount} tokens to address ${dest} successfully`);
        }
        catch (error) {
            console.log(error);
            process.exit(1);
        }
        process.exit(0);
    }
    else {
        program.help();
        process.exit(1);
    }
});
exports.default = program;
//# sourceMappingURL=MintTokens.js.map