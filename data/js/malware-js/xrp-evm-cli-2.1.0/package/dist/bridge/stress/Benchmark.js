"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Benchmark = void 0;
const fs = __importStar(require("fs"));
const ChainProviderFactory_1 = require("../core/ChainProviderFactory");
class Benchmark {
    constructor(claimAccounts = 0, claimIterations = 0, createAccounts = 0, createIterations = 0) {
        this.metrics = [];
        this.info = {
            startTime: new Date().getTime(),
            claimAccounts,
            claimIterations,
            createAccounts,
            createIterations,
        };
    }
    addMetric(metric) {
        this.metrics.push(metric);
        this.write();
    }
    finish() {
        this.info.endTime = new Date().getTime();
        this.write();
        this.print();
    }
    calculateResult(metrics) {
        return {
            all: this.calculateTypeResult(metrics),
            [ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM]: this.calculateTypeResult(metrics.filter((m) => m.direction === ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM)),
            [ChainProviderFactory_1.BridgeDirection.EVM_TO_XRP]: this.calculateTypeResult(metrics.filter((m) => m.direction === ChainProviderFactory_1.BridgeDirection.EVM_TO_XRP)),
        };
    }
    calculateTypeResult(metrics) {
        const metricResult = metrics.reduce((acc, metric) => {
            return {
                medianTime: acc.medianTime + (metric.endTime - metric.startTime),
                medianBlocks: acc.medianBlocks + (metric.endBlock - metric.startBlock),
            };
        }, { medianTime: 0, medianBlocks: 0 });
        metricResult.medianTime /= metrics.length;
        metricResult.medianBlocks /= metrics.length;
        let maxTime = 0, maxBlocks = 0, minTime = Infinity, minBlocks = Infinity;
        for (const metric of metrics) {
            const totalTime = metric.endTime - metric.startTime;
            const totalBlocks = metric.endBlock - metric.startBlock;
            if (totalTime > maxTime)
                maxTime = totalTime;
            if (totalTime < minTime)
                minTime = totalTime;
            if (totalBlocks > maxBlocks)
                maxBlocks = totalBlocks;
            if (totalBlocks < minBlocks)
                minBlocks = totalBlocks;
        }
        return {
            medianTime: metricResult.medianTime / 1000,
            medianBlocks: metricResult.medianBlocks,
            maxTime: maxTime / 1000,
            minTime: minTime / 1000,
            maxBlocks,
            minBlocks,
        };
    }
    get result() {
        const claimMetrics = this.metrics.filter((metric) => metric.type === "claim");
        const createAccountMetrics = this.metrics.filter((metric) => metric.type === "create_account");
        return {
            claim: this.calculateResult(claimMetrics),
            createAccount: this.calculateResult(createAccountMetrics),
            general: this.calculateResult(this.metrics),
        };
    }
    print() {
        const executionTime = ((this.info.endTime || 0) - this.info.startTime) / 1000;
        const nAtts = this.info.claimIterations * this.info.claimAccounts + this.info.createIterations * this.info.createAccounts;
        console.log("|----------------------------------------------------------|");
        console.log("|                      BENCHMARK INFO                      |");
        console.log("|----------------------------------------------------------|");
        console.log(`|                                                          |`);
        console.log(`| Execution time: ${n2s(executionTime)}s`);
        console.log(`| Attestations/s: ${n2s(nAtts / executionTime)}`);
        console.log(`|                                                          |`);
        this.printTypeResult("General", this.result.general.all);
        this.printTypeResult("General XRP->EVM", this.result.general[ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM]);
        this.printTypeResult("General EVM->XRP", this.result.general[ChainProviderFactory_1.BridgeDirection.EVM_TO_XRP]);
        console.log("|----------------------------------------------------------|");
        console.log(`|                                                          |`);
        this.printTypeResult("Claim", this.result.claim.all);
        this.printTypeResult("Claim XRP->EVM", this.result.claim[ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM]);
        this.printTypeResult("Claim EVM->XRP", this.result.claim[ChainProviderFactory_1.BridgeDirection.EVM_TO_XRP]);
        console.log("|----------------------------------------------------------|");
        console.log(`|                                                          |`);
        this.printTypeResult("CreateAccount", this.result.createAccount.all);
        this.printTypeResult("CreateAccount XRP->EVM", this.result.createAccount[ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM]);
        this.printTypeResult("CreateAccount EVM->XRP", this.result.createAccount[ChainProviderFactory_1.BridgeDirection.EVM_TO_XRP]);
        console.log("|----------------------------------------------------------|");
    }
    printTypeResult(name, typeResult) {
        console.log(`| ${name} median time: ${n2s(typeResult.medianTime)}s`);
        console.log(`| ${name} median blocks: ${n2s(typeResult.medianBlocks)}`);
        console.log(`| ${name} min time : ${n2s(typeResult.minTime)}s`);
        console.log(`| ${name} max time : ${n2s(typeResult.maxTime)}s`);
        console.log(`| ${name} min blocks : ${n2s(typeResult.minBlocks)}`);
        console.log(`| ${name} max blocks : ${n2s(typeResult.maxBlocks)}`);
        console.log(`|                                                          |`);
    }
    write() {
        fs.writeFileSync(`./benchmarks/bridge/benchmark-${this.info.claimIterations}-${this.info.claimAccounts}-${this.info.createIterations}-${this.info.createAccounts}.json`, JSON.stringify({ info: this.info, metrics: this.metrics }));
    }
    static load(path) {
        const file = fs.readFileSync(path);
        const obj = JSON.parse(file.toString());
        const benchmark = new Benchmark();
        benchmark.info = obj.info;
        benchmark.metrics = obj.metrics;
        return benchmark;
    }
}
exports.Benchmark = Benchmark;
const n2s = (n) => n.toLocaleString(undefined, {
    maximumFractionDigits: 2,
    minimumFractionDigits: 2,
});
//# sourceMappingURL=Benchmark.js.map