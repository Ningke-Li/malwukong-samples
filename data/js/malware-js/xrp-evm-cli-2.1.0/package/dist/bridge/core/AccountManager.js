"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManager = void 0;
const ChainProviderFactory_1 = require("./ChainProviderFactory");
const xrpl_1 = require("xrpl");
const ethers_1 = require("ethers");
const address_derivation_1 = require("../util/address-derivation");
const fs = __importStar(require("fs"));
const utils_1 = require("./utils");
class AccountManager {
    constructor(providers) {
        this.providers = providers;
        this.evmPrivateKeys = [];
        try {
            const file = fs.readFileSync("./evm-private-keys.json");
            this.evmPrivateKeys = JSON.parse(file.toString());
        }
        catch (e) { }
    }
    createAccounts(direction) {
        const xrpWallet = xrpl_1.Wallet.generate();
        const xrpAccount = {
            pk: xrpWallet.seed,
            address: xrpWallet.address,
            otherChainAddress: (0, address_derivation_1.xrplAccountToEvmAddress)(xrpWallet.address),
        };
        const evmWallet = ethers_1.Wallet.createRandom();
        const evmAccount = {
            pk: evmWallet.privateKey,
            address: evmWallet.address,
            otherChainAddress: (0, address_derivation_1.evmAddressToXrplAccount)(evmWallet.address),
        };
        this.writeFundedPrivateKey(evmWallet.privateKey);
        if (direction === ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM) {
            return {
                source: {
                    ...xrpAccount,
                    provider: this.providers[direction].source,
                },
                destination: {
                    ...evmAccount,
                    provider: this.providers[direction].destination,
                },
            };
        }
        else {
            return {
                source: {
                    ...evmAccount,
                    provider: this.providers[direction].source,
                },
                destination: {
                    ...xrpAccount,
                    provider: this.providers[direction].destination,
                },
            };
        }
    }
    async fundAccounts(accounts, sourceAmount, destinationAmount) {
        const fundingPromises = [];
        if (sourceAmount > 0) {
            fundingPromises.push(accounts.source.provider.fundAccount(accounts.source.pk, sourceAmount));
        }
        if (destinationAmount > 0) {
            fundingPromises.push(accounts.destination.provider.fundAccount(accounts.destination.pk, destinationAmount));
        }
        await Promise.all(fundingPromises);
    }
    writeFundedPrivateKey(pk) {
        this.evmPrivateKeys.push(pk);
        fs.writeFileSync("./evm-private-keys.json", JSON.stringify(this.evmPrivateKeys));
    }
    async refundAllUsedAccounts() {
        let i = 0;
        for (const pk of this.evmPrivateKeys) {
            console.log(`Refunding [${i}/${this.evmPrivateKeys.length}] ${pk}`);
            this.providers[ChainProviderFactory_1.BridgeDirection.EVM_TO_XRP].source.refundAccount(pk);
            this.providers[ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM].source.refundAccount(pk);
            await (0, utils_1.sleep)(0.5);
            i++;
        }
        console.log(`Refunded all used accounts`);
        fs.unlinkSync("./evm-private-keys.json");
    }
}
exports.AccountManager = AccountManager;
//# sourceMappingURL=AccountManager.js.map