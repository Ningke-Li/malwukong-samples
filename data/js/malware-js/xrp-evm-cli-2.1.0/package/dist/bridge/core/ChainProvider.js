"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmProvider = exports.XrpProvider = void 0;
const xrpl_1 = require("xrpl");
const wallet_1 = require("@ethersproject/wallet");
const providers_1 = require("@ethersproject/providers");
const utils_1 = require("./utils");
const ethers_1 = require("ethers");
const xrp_evm_contracts_1 = require("@peersyst/xrp-evm-contracts");
const address_derivation_1 = require("../util/address-derivation");
class XrpProvider {
    constructor(bridgeConfig) {
        this.bridgeConfig = bridgeConfig;
        this.client = new xrpl_1.Client(this.chainConfig.nodeUrl);
    }
    get chainConfig() {
        return this.bridgeConfig.bridgeChain("xrp");
    }
    get feePrivateKey() {
        return this.chainConfig.feePrivateKey;
    }
    get XChainBridge() {
        return this.chainConfig.XChainBridge;
    }
    get bridgeParams() {
        return this.bridgeConfig.config.params;
    }
    async init() {
        await this.client.connect();
        const masterWallet = xrpl_1.Wallet.fromSeed(this.feePrivateKey);
        const accountInfo = await this.client.request({
            command: "account_info",
            account: masterWallet.address,
        });
        this.masterNonce = accountInfo.result.account_data.Sequence;
    }
    getMasterAddress() {
        const masterWallet = xrpl_1.Wallet.fromSeed(this.feePrivateKey);
        return masterWallet.address;
    }
    getMasterPrivateKey() {
        return this.feePrivateKey;
    }
    getOtherChainAddress(address) {
        return (0, address_derivation_1.xrplAccountToEvmAddress)(address);
    }
    getAddressFromPrivateKey(privateKey) {
        const masterWallet = xrpl_1.Wallet.fromSeed(privateKey);
        return masterWallet.address;
    }
    async fundAccount(seed, value) {
        const masterWallet = xrpl_1.Wallet.fromSeed(this.feePrivateKey);
        const wallet = xrpl_1.Wallet.fromSeed(seed);
        const nonce = Number(this.masterNonce);
        console.log(`Funding account ${wallet.address} using nonce ${nonce}`);
        this.masterNonce++;
        const transaction = await this.client.autofill({
            TransactionType: "Payment",
            Destination: wallet.address,
            Account: masterWallet.address,
            Amount: (0, utils_1.xrpToDrops)(value + 10),
            Sequence: nonce,
        });
        const signed = masterWallet.sign(transaction);
        await this.client.submit(signed.tx_blob);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars
    async refundAccount(seed) { }
    async createClaim(seed, senderAddress) {
        const wallet = xrpl_1.Wallet.fromSeed(seed);
        const transaction = await this.client.autofill({
            TransactionType: "XChainCreateClaimID",
            XChainBridge: this.XChainBridge,
            SignatureReward: (0, utils_1.xrpToDrops)(this.bridgeParams.signatureReward),
            OtherChainSource: senderAddress,
            Account: wallet.address,
        });
        const signed = wallet.sign(transaction);
        const result = await this.client.submit(signed.tx_blob);
        let claimID;
        do {
            await (0, utils_1.sleep)(10);
            const response = await this.client.request({
                command: "tx",
                transaction: result.result.tx_json.hash,
                binary: false,
            });
            claimID = response.result.meta.AffectedNodes.find((n) => { var _a; return ((_a = n.CreatedNode) === null || _a === void 0 ? void 0 : _a.LedgerEntryType) === "XChainOwnedClaimID"; });
        } while (!claimID);
        const claimIDHex = claimID.CreatedNode.NewFields.XChainClaimID;
        return (0, utils_1.claimIDToNum)(claimIDHex);
    }
    async createAccount(seed, amount, receiverAddress) {
        const wallet = xrpl_1.Wallet.fromSeed(seed);
        const transaction = await this.client.autofill({
            TransactionType: "XChainAccountCreateCommit",
            XChainBridge: this.XChainBridge,
            SignatureReward: (0, utils_1.xrpToDrops)(this.bridgeParams.signatureReward),
            Destination: receiverAddress,
            Amount: (0, utils_1.xrpToDrops)(amount),
            Account: wallet.address,
        });
        const signed = wallet.sign(transaction);
        await this.client.submit(signed.tx_blob);
    }
    async commit(senderSeed, claimID, amount, receiver) {
        const senderWallet = xrpl_1.Wallet.fromSeed(senderSeed);
        const transaction = await this.client.autofill({
            TransactionType: "XChainCommit",
            XChainBridge: this.XChainBridge,
            XChainClaimID: (0, utils_1.claimIDToHex)(claimID),
            OtherChainDestination: receiver,
            Amount: this.bridgeConfig.parseXrpAmount(amount),
            Account: senderWallet.address,
        });
        const signed = senderWallet.sign(transaction);
        const res = await this.client.submit(signed.tx_blob);
        console.log(res);
        console.log(transaction);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
    async approve(pk, amount) { }
    async getBalance(address) {
        try {
            const balance = await this.client.getXrpBalance(address);
            return Number(balance);
        }
        catch (e) {
            return 0;
        }
    }
    async getBlock() {
        return this.client.getLedgerIndex();
    }
    async isClaimed(claimId, creator, previouslyFound = false, checkIteration = 0) {
        try {
            const res = await this.client.request({
                command: "account_objects",
                account: creator,
            });
            if (res.result.account_objects.length === 0) {
                if (previouslyFound || checkIteration >= 10)
                    return true;
                else {
                    await (0, utils_1.sleep)(0.2);
                    return this.isClaimed(claimId, creator, false, checkIteration + 1);
                }
            }
            for (const obj of res.result.account_objects) {
                if (obj.XChainClaimID.toUpperCase() === claimId.toString(16).toUpperCase()) {
                    return await this.isClaimed(claimId, creator, true, 0);
                }
            }
            return false;
        }
        catch (e) {
            console.log(`Error when trying to find if claimId ${claimId} is claimed for ${creator}: ${e}`);
            return false;
        }
    }
    async isCreated(receiver) {
        try {
            await this.client.request({
                command: "account_info",
                account: receiver,
            });
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
exports.XrpProvider = XrpProvider;
class EvmProvider {
    constructor(bridgeConfig) {
        this.bridgeConfig = bridgeConfig;
        this.fundedPrivateKeys = [];
        this.provider = new providers_1.JsonRpcProvider(this.chainConfig.nodeUrl);
    }
    get chainConfig() {
        return this.bridgeConfig.bridgeChain("evm");
    }
    get feePrivateKey() {
        return this.chainConfig.feePrivateKey;
    }
    get bridgeParams() {
        return this.bridgeConfig.config.params;
    }
    async init() {
        this.bridgeContract = xrp_evm_contracts_1.BridgeDoorToken__factory.connect(this.chainConfig.bridgeAccount, this.provider);
        this.tokenContract = xrp_evm_contracts_1.BridgeToken__factory.connect(this.chainConfig.tokenAddress, this.provider);
        const masterWallet = new wallet_1.Wallet(this.feePrivateKey, this.provider);
        this.feeAccountNonce = await this.provider.getTransactionCount(masterWallet.address);
    }
    getMasterAddress() {
        const masterWallet = new wallet_1.Wallet(this.feePrivateKey, this.provider);
        return masterWallet.address;
    }
    getMasterPrivateKey() {
        return this.feePrivateKey;
    }
    getOtherChainAddress(address) {
        return (0, address_derivation_1.evmAddressToXrplAccount)(address);
    }
    getAddressFromPrivateKey(privateKey) {
        const masterWallet = new wallet_1.Wallet(privateKey, this.provider);
        return masterWallet.address;
    }
    async fundAccount(privateKey, value) {
        const masterWallet = new wallet_1.Wallet(this.feePrivateKey, this.provider);
        const wallet = new wallet_1.Wallet(privateKey, this.provider);
        const nonce = Number(this.feeAccountNonce);
        console.log(`Funding account ${wallet.address} using nonce ${nonce}`);
        this.feeAccountNonce++;
        for (let i = 0; i < Infinity; i++) {
            try {
                await masterWallet.sendTransaction({
                    to: wallet.address,
                    value: ethers_1.ethers.utils.parseEther(value.toString()),
                    nonce: nonce,
                });
                break;
            }
            catch (e) {
                console.log(`Errored trying to broadcast fund transaction with nonce ${nonce}: ${e.body}`);
                await (0, utils_1.sleep)(0.2);
            }
        }
    }
    async refundAccount(pk) {
        const masterWallet = new wallet_1.Wallet(this.feePrivateKey, this.provider);
        const wallet = new wallet_1.Wallet(pk, this.provider);
        const walletBalance = await this.getBalance(wallet.address);
        const valueToSend = walletBalance - 0.1;
        if (valueToSend <= 0)
            return;
        console.log(`Sending back ${valueToSend} from ${wallet.address}`);
        await (await wallet.sendTransaction({
            to: masterWallet.address,
            value: ethers_1.ethers.utils.parseEther(valueToSend.toString()),
            gasLimit: 21000,
        })).wait();
    }
    async createAccount(pk, amount, receiverAddress) {
        const wallet = new wallet_1.Wallet(pk, this.provider);
        const signatureReward = ethers_1.ethers.utils.parseEther(this.bridgeParams.signatureReward.toString());
        const parsedAmount = ethers_1.ethers.utils.parseEther(amount.toString());
        await (await this.bridgeContract.connect(wallet).createAccountCommit(receiverAddress, parsedAmount, signatureReward, {
            value: parsedAmount.add(signatureReward),
            gasLimit: 300000,
        })).wait();
    }
    async createClaim(pk, senderAddress) {
        var _a;
        const wallet = new wallet_1.Wallet(pk, this.provider);
        const contractTransaction = await this.bridgeContract.connect(wallet).createClaimId(senderAddress, {
            value: ethers_1.ethers.utils.parseEther(this.bridgeParams.signatureReward.toString()),
            gasLimit: 140000,
        });
        const transaction = await contractTransaction.wait();
        const event = (_a = transaction.events) === null || _a === void 0 ? void 0 : _a.find((event) => event.event === "CreateClaim");
        const [claimID] = (event === null || event === void 0 ? void 0 : event.args) || [];
        return claimID.toNumber();
    }
    async commit(senderPk, claimID, amount, receiver) {
        const wallet = new wallet_1.Wallet(senderPk, this.provider);
        const parsedAmount = ethers_1.ethers.utils.parseEther(amount.toString());
        if (receiver) {
            await (await this.bridgeContract.connect(wallet).commit(receiver, claimID, parsedAmount, {
                value: this.bridgeConfig.isTokenBridge ? undefined : parsedAmount,
                gasLimit: 100000,
            })).wait();
        }
        else {
            await (await this.bridgeContract.connect(wallet).commitWithoutAddress(claimID, parsedAmount, {
                value: this.bridgeConfig.isTokenBridge ? undefined : parsedAmount,
                gasLimit: 100000,
            })).wait();
        }
    }
    async approve(senderPk, amount) {
        const wallet = new wallet_1.Wallet(senderPk, this.provider);
        const parsedAmount = ethers_1.ethers.utils.parseEther(amount.toString());
        await (await this.tokenContract.connect(wallet).approve(this.chainConfig.bridgeAccount, parsedAmount)).wait();
    }
    async getBalance(address) {
        const balance = await this.provider.getBalance(address);
        return Number(ethers_1.ethers.utils.formatEther(balance));
    }
    async getBlock() {
        return this.provider.getBlockNumber();
    }
    async getLatestBlock() {
        return this.provider.getBlockNumber();
    }
    async isClaimed(claimId) {
        const res = await this.bridgeContract.queryFilter(this.bridgeContract.filters.Credit(claimId), (await this.provider.getBlockNumber()) - 3000);
        return res.length > 0;
    }
    async isCreated(receiver) {
        const res = await this.bridgeContract.queryFilter(this.bridgeContract.filters.CreateAccount(receiver), (await this.provider.getBlockNumber()) - 3000);
        return res.length > 0;
    }
}
exports.EvmProvider = EvmProvider;
//# sourceMappingURL=ChainProvider.js.map