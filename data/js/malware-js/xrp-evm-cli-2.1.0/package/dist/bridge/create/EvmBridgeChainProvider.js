"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBridgeChainProvider = void 0;
const address_derivation_1 = require("../util/address-derivation");
const ethers_1 = require("ethers");
const Logger_1 = require("../../util/Logger");
const protocol_kit_1 = require("@safe-global/protocol-kit");
const crypto_1 = __importDefault(require("crypto"));
const BridgeDoorToken__factory_1 = require("@peersyst/xrp-evm-contracts/dist/typechain/factories/BridgeDoorToken__factory");
const BridgeDoorNative__factory_1 = require("@peersyst/xrp-evm-contracts/dist/typechain/factories/BridgeDoorNative__factory");
const utils_1 = require("ethers/lib/utils");
class EvmBridgeChainProvider {
    toEvmAddress(address) {
        if (address.startsWith("0x"))
            return address;
        else
            return (0, address_derivation_1.xrplAccountToEvmAddress)(address);
    }
    defaultSafeContractNetworks(chainId) {
        return {
            [chainId.toString()]: {
                safeMasterCopyAddress: "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
                safeProxyFactoryAddress: "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
                multiSendAddress: "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
                multiSendCallOnlyAddress: "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
                fallbackHandlerAddress: "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
                signMessageLibAddress: "0x03F886722b44BefB13871D4a05621D38616D3b7c",
                createCallAddress: "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
            },
        };
    }
    createBridgeWallet() {
        return undefined;
    }
    async fundAddress(fundingWallet, address, amount) {
        const result = await fundingWallet.sendTransaction({
            from: fundingWallet.address,
            to: address,
            value: ethers_1.ethers.utils.parseEther(amount.toString()),
            gasLimit: 300000,
        });
        await result.wait();
    }
    async setupAccounts(config, signer, witnesses) {
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Funding witnesses...");
        for (const witness of witnesses) {
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Working, `Funding witness ${witness}...`);
            await this.fundAddress(signer, witness, 1);
        }
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, "Witnesses funded");
        const bridgeAddress = (0, utils_1.getContractAddress)({
            from: signer.address,
            nonce: (await signer.getTransactionCount()) +
                2 +
                (witnesses.find((w) => w.toLowerCase() === signer.address.toLowerCase()) ? 0 : 1),
        });
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Setting up safe smart contract [predicted bridge address ${bridgeAddress}]...`);
        const safeAddress = await this.setupSafe(config, bridgeAddress, signer, witnesses);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Safe smart contract set up at ${safeAddress}`);
        return safeAddress;
    }
    async setupSafe(config, bridgeAddress, signer, witnesses) {
        const ethAdapter = new protocol_kit_1.EthersAdapter({ ethers: ethers_1.ethers, signerOrProvider: signer });
        const safeFactory = await protocol_kit_1.SafeFactory.create({
            ethAdapter,
            contractNetworks: this.defaultSafeContractNetworks(await signer.getChainId()),
        });
        const isSignerWitness = !!witnesses.find((w) => w.toLowerCase() === signer.address.toLowerCase());
        const safe = await safeFactory.deploySafe({
            safeAccountConfig: {
                threshold: 1,
                owners: isSignerWitness ? witnesses : [...witnesses, signer.address],
            },
            saltNonce: ethers_1.BigNumber.from(crypto_1.default.randomInt(1000000)).toString(),
            options: {
                gasLimit: 300000,
            },
        });
        const enableModuleTransaction = await safe.createEnableModuleTx(bridgeAddress);
        const safeTxHash = await safe.getTransactionHash(enableModuleTransaction);
        const signature = await safe.signTransactionHash(safeTxHash);
        enableModuleTransaction.addSignature(signature);
        await safe.executeTransaction(enableModuleTransaction);
        if (!isSignerWitness) {
            const removeSignerTx = await safe.createRemoveOwnerTx({
                ownerAddress: signer.address,
                threshold: config.threshold,
            });
            const removeSignerTxHash = await safe.getTransactionHash(removeSignerTx);
            const signature = await safe.signTransactionHash(removeSignerTxHash);
            removeSignerTx.addSignature(signature);
            await safe.executeTransaction(removeSignerTx);
        }
        return safe.getAddress();
    }
    async createIssuingChainBridge(config, lockingBridgeAddress) {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(config.issuingChain.url);
        const signerWallet = new ethers_1.ethers.Wallet(config.issuingChain.fundingPrivateKey, provider);
        const safeAddress = await this.setupAccounts(config, signerWallet, config.issuingChain.witnesses);
        let bridgeAddress, tokenAddress;
        const isNative = config.lockingChain.tokenCode === "XRP";
        if (isNative) {
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Setting up native bridge smart contract ${lockingBridgeAddress}`);
            const bridgeDoorNativeFactory = new BridgeDoorNative__factory_1.BridgeDoorNative__factory(signerWallet);
            const bridgeDoorNative = await bridgeDoorNativeFactory.deploy(safeAddress, ethers_1.ethers.utils.parseEther(config.minRewardAmount.toString()), ethers_1.ethers.utils.parseEther(config.minCreateAmount.toString()), ethers_1.ethers.constants.AddressZero, this.toEvmAddress(lockingBridgeAddress));
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Bridge smart contract set up at ${bridgeDoorNative.address}`);
            bridgeAddress = bridgeDoorNative.address;
        }
        else {
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Setting up bridge smart contract ${lockingBridgeAddress} ${config.lockingChain.tokenIssuer}...`);
            const bridgeDoorTokenFactory = new BridgeDoorToken__factory_1.BridgeDoorToken__factory(signerWallet);
            const bridgeDoorToken = await bridgeDoorTokenFactory.deploy(safeAddress, ethers_1.ethers.utils.parseEther(config.minRewardAmount.toString()), this.toEvmAddress(lockingBridgeAddress), this.toEvmAddress(config.lockingChain.tokenIssuer), ethers_1.ethers.constants.AddressZero, ethers_1.ethers.constants.AddressZero, config.lockingChain.tokenCode, `Bridged ${config.lockingChain.tokenCode} (${config.lockingChain.tokenIssuer})`);
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Bridge smart contract set up at ${bridgeDoorToken.address}`);
            bridgeAddress = bridgeDoorToken.address;
            tokenAddress = await bridgeDoorToken._tokenAddress();
        }
        return {
            address: bridgeAddress,
            config: {
                LockingChainDoor: this.toEvmAddress(lockingBridgeAddress),
                LockingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: !isNative ? this.toEvmAddress(config.lockingChain.tokenIssuer) : "",
                },
                IssuingChainDoor: bridgeAddress,
                IssuingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: !isNative ? bridgeAddress : "",
                },
            },
            tokenAddress: tokenAddress,
        };
    }
    async createLockingChainBridge(config, issuingBridgeAddress) {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(config.lockingChain.url);
        const signerWallet = new ethers_1.ethers.Wallet(config.lockingChain.fundingPrivateKey, provider);
        const safeAddress = await this.setupAccounts(config, signerWallet, config.lockingChain.witnesses);
        const bridgeDoorTokenFactory = new BridgeDoorToken__factory_1.BridgeDoorToken__factory(signerWallet);
        const bridgeDoorToken = await bridgeDoorTokenFactory.deploy(safeAddress, ethers_1.ethers.utils.parseEther(config.minRewardAmount.toString()), ethers_1.ethers.constants.AddressZero, config.lockingChain.tokenIssuer, this.toEvmAddress(issuingBridgeAddress), this.toEvmAddress(issuingBridgeAddress), config.lockingChain.tokenCode, "");
        return {
            address: bridgeDoorToken.address,
            config: {
                LockingChainDoor: bridgeDoorToken.address,
                LockingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: config.lockingChain.tokenIssuer,
                },
                IssuingChainDoor: this.toEvmAddress(issuingBridgeAddress),
                IssuingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: this.toEvmAddress(issuingBridgeAddress),
                },
            },
        };
    }
}
exports.EvmBridgeChainProvider = EvmBridgeChainProvider;
//# sourceMappingURL=EvmBridgeChainProvider.js.map