"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateXrpBridge = void 0;
const xrpl_1 = require("xrpl");
// Setup the signer list on the door account
async function setupSignerList(client, bridgeDoorWallet, witnesses, claimThreshold) {
    const signerListSet = await client.autofill({
        TransactionType: "SignerListSet",
        Account: bridgeDoorWallet.address,
        SignerQuorum: claimThreshold,
        SignerEntries: witnesses.map((w) => ({
            SignerEntry: {
                Account: w,
                SignerWeight: 1,
            },
        })),
    });
    // sign transaction
    const signed = bridgeDoorWallet.sign(signerListSet);
    await client.submit(signed.tx_blob);
}
// Send a create bridge transaction on xrpl door account
async function createBridge(client, bridgeDoorWallet, minAccountCreate, signatureReward) {
    // Hardcoded for now, should be the address of the evm contract, but
    const issuerAddress = "rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh";
    const createBridge = await client.autofill({
        TransactionType: "XChainCreateBridge",
        Account: bridgeDoorWallet.address,
        XChainBridge: {
            LockingChainDoor: bridgeDoorWallet.address,
            LockingChainIssue: {
                currency: "XRP",
            },
            // IssuingChainDoor: evmAddressToXrplAccount(evmContractAddress),
            IssuingChainDoor: issuerAddress,
            IssuingChainIssue: {
                currency: "XRP",
            },
        },
        MinAccountCreateAmount: (0, xrpl_1.xrpToDrops)(minAccountCreate),
        SignatureReward: (0, xrpl_1.xrpToDrops)(signatureReward),
    });
    // sign transaction
    const signed = bridgeDoorWallet.sign(createBridge);
    const result = await client.submit(signed.tx_blob);
    if (result.result.engine_result === "tesSUCCESS") {
    }
    else {
        console.log("Error creating bridge", result);
    }
}
async function fundXrpAccount(client, senderSeed, destinationAddress, amount) {
    const funder = xrpl_1.Wallet.fromSeed(senderSeed);
    const fundTransaction = await client.autofill({
        TransactionType: "Payment",
        Account: funder.address,
        Destination: destinationAddress,
        Amount: (0, xrpl_1.xrpToDrops)(amount),
    });
    // sign transaction
    const signed = funder.sign(fundTransaction);
    const result = await client.submit(signed.tx_blob);
    if (result.result.engine_result === "tesSUCCESS") {
    }
    else {
        console.log("Error creating bridge", result);
    }
}
async function CreateXrpBridge(config) {
    const client = new xrpl_1.Client(config.xrplRpc);
    await client.connect();
    for (const witness of config.witnesses) {
        await fundXrpAccount(client, config.xrplSeed, witness.xrpAddress, 100);
    }
    const xrpDoorWallet = xrpl_1.Wallet.generate();
    await fundXrpAccount(client, config.xrplSeed, xrpDoorWallet.address, 100);
    await setupSignerList(client, xrpDoorWallet, config.witnesses.map((w) => w.xrpAddress), config.quorum);
    await createBridge(client, xrpDoorWallet, config.minCreateAmount, config.minRewardAmount);
    return xrpDoorWallet.address;
}
exports.CreateXrpBridge = CreateXrpBridge;
//# sourceMappingURL=CreateXrpBridge.js.map