"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeService = void 0;
const exrpd_1 = require("../util/exrpd");
const keccak256_1 = __importDefault(require("keccak256"));
const contract_1 = require("./contract");
const CreateXrpBridge_1 = require("./CreateXrpBridge");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ejs_1 = __importDefault(require("ejs"));
const BridgeDoorContract_1 = require("./contract/BridgeDoorContract");
const Logger_1 = require("../../util/Logger");
class BridgeService {
    constructor(config, exportPath) {
        this.config = config;
        this.exportPath = exportPath;
        if (this.config.xrplAddress)
            this.xrpBridgeAddress = this.config.xrplAddress;
    }
    get xrpSafeContract() {
        return (0, contract_1.XrpSafeContract)(this.config.witnesses.map((w) => w.evmAddress), this.config.quorum);
    }
    getNextAvailableAccountNumber(genesis) {
        for (let i = 0; i < genesis["app_state"]["auth"]["accounts"].length; i++) {
            let found = false;
            for (const account of genesis["app_state"]["auth"]["accounts"]) {
                if (account["base_account"]["account_number"] === i.toString()) {
                    found = true;
                    break;
                }
            }
            if (!found)
                return i.toString();
        }
        return genesis["app_state"]["auth"]["accounts"].length.toString();
    }
    addGenesisContract(contract, genesis) {
        const cosmosAddress = JSON.parse((0, exrpd_1.exrpd)(`keys parse ${contract.address.replace("0x", "")} --output json`)).formats[0];
        const codeHash = (0, keccak256_1.default)(Buffer.from(contract.bytecode, "hex")).toString("hex");
        let accountFound = false;
        for (let i = 0; i < genesis["app_state"]["auth"]["accounts"].length; i++) {
            const account = genesis["app_state"]["auth"]["accounts"][i];
            if (account.base_account.address === cosmosAddress) {
                genesis["app_state"]["auth"]["accounts"][i].code_hash = "0x" + codeHash;
                accountFound = true;
                break;
            }
        }
        if (!accountFound) {
            genesis["app_state"]["auth"]["accounts"].push({
                "@type": "/ethermint.types.v1.EthAccount",
                base_account: {
                    address: cosmosAddress,
                    pub_key: null,
                    account_number: this.getNextAvailableAccountNumber(genesis),
                    sequence: "1",
                },
                code_hash: "0x" + codeHash,
            });
        }
        genesis["app_state"]["evm"]["accounts"].push({
            address: contract.address,
            code: contract.bytecode,
            storage: contract.memory,
        });
        return genesis;
    }
    addBridgeContracts(genesis) {
        if (!this.xrpBridgeAddress) {
            throw new Error("XRP bridge not configured yet");
        }
        for (const contract of contract_1.SafeCoreContracts) {
            genesis = this.addGenesisContract(contract, genesis);
        }
        genesis = this.addGenesisContract(this.xrpSafeContract, genesis);
        genesis = this.addGenesisContract((0, contract_1.BridgeDoorContract)(this.xrpBridgeAddress, this.config.minCreateAmount, this.config.minRewardAmount), genesis);
        return genesis;
    }
    async createXrpBridge() {
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Creating XRP bridge...");
        this.xrpBridgeAddress = await (0, CreateXrpBridge_1.CreateXrpBridge)(this.config);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `XRP bridge created at address: ${this.xrpBridgeAddress}`);
    }
    async configure(evmRpc) {
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Configuring bridge witness servers...");
        if (!this.xrpBridgeAddress) {
            throw new Error("XRP bridge not configured yet");
        }
        const configTemplate = fs_1.default.readFileSync(path_1.default.join(__dirname, "../template/witness-config.yml.ejs")).toString();
        const envTemplate = fs_1.default.readFileSync(path_1.default.join(__dirname, "../template/witness.env.ejs")).toString();
        for (let i = 0; i < this.config.witnesses.length; i++) {
            const witness = this.config.witnesses[i];
            const configResult = ejs_1.default.render(configTemplate, {
                xrpNode: this.config.xrplRpc,
                xrpBridgeAddress: this.xrpBridgeAddress,
                evmNode: evmRpc,
                evmBridgeAddress: BridgeDoorContract_1.BridgeDoorContractAddress,
            });
            const envResult = ejs_1.default.render(envTemplate, {
                awsRegion: witness.region,
                awsAccessKey: witness.accessKey,
                awsSecretAccessKey: witness.secretAccessKey,
                awsKeyId: witness.keyId,
            });
            fs_1.default.writeFileSync(path_1.default.join(this.exportPath, `witness-${i}-config.yml`), configResult);
            fs_1.default.writeFileSync(path_1.default.join(this.exportPath, `witness-${i}.env`), envResult);
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Working, `Bridge witness server ${i} configured`);
        }
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `All bridge witness servers configured`);
    }
}
exports.BridgeService = BridgeService;
//# sourceMappingURL=BridgeService.js.map