"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockchainService = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const NodeService_1 = require("./NodeService");
const toml_1 = __importDefault(require("@iarna/toml"));
const Logger_1 = require("../../util/Logger");
const SafeContract_1 = require("../bridge/contract/SafeContract");
const DefaultGenesis_1 = require("./DefaultGenesis");
const exrpd_1 = require("../util/exrpd");
const child_process_1 = require("child_process");
const Defaults = {
    evmDenom: "axrp",
    poaDenom: "apoa",
    validatorPoaAmount: 1000000000,
    accountEvmAmount: 10,
    evmSupply: 10000000000,
};
class BlockchainService {
    constructor(exportPath, config, bridgeService) {
        this.exportPath = exportPath;
        this.config = config;
        this.bridgeService = bridgeService;
    }
    get dockerImage() {
        return "peersyst/xrp-evm-blockchain:latest";
    }
    get chainId() {
        return `exrp_${this.config.chainId}-0`;
    }
    nodePath(nodeName) {
        return path_1.default.join(this.exportPath, nodeName);
    }
    initializeNodes() {
        const nodes = [];
        if (!Array.isArray(this.config.nodes)) {
            for (let i = 0; i < this.config.nodes; i++) {
                nodes.push({
                    name: `node-${i}`,
                    host: `node-${i}`,
                });
            }
        }
        else {
            nodes.push(...this.config.nodes);
        }
        const nodesWithService = [];
        for (const node of nodes) {
            nodesWithService.push({ ...node, service: new NodeService_1.NodeService(this.config, node.name, path_1.default.join(this.nodePath(node.name))) });
        }
        for (const node of nodesWithService) {
            node.service.initNode();
        }
        return nodesWithService;
    }
    overrideGenesis(nodePath) {
        const genesis = (0, DefaultGenesis_1.DefaultGenesis)(this.config, Defaults.evmDenom, Defaults.poaDenom);
        fs_1.default.writeFileSync(path_1.default.join(nodePath, `/config/genesis.json`), JSON.stringify(genesis));
    }
    addGenesisBridgeContracts(nodePath) {
        const genesisPath = path_1.default.join(nodePath, "/config/genesis.json");
        const genesis = JSON.parse(fs_1.default.readFileSync(genesisPath).toString());
        const genesisWithContracts = this.bridgeService.addBridgeContracts(genesis);
        fs_1.default.writeFileSync(genesisPath, JSON.stringify(genesisWithContracts));
    }
    collectGenesisTransactions(srcNodePath, destNodePath, destNodeService) {
        (0, child_process_1.execSync)(`cp -r ${path_1.default.join(srcNodePath, "/config/gentx/*")} ${path_1.default.join(destNodePath, "/config/gentx/")}`);
        destNodeService.collectGenTxs();
    }
    copyGenesis(srcNodePath, destNodePath) {
        fs_1.default.copyFileSync(path_1.default.join(srcNodePath, "/config/genesis.json"), path_1.default.join(destNodePath, "/config/genesis.json"));
    }
    overrideSeeds(nodePath, seeds) {
        const configPath = path_1.default.join(nodePath, "/config/config.toml");
        const rawConfig = fs_1.default.readFileSync(configPath).toString();
        const config = toml_1.default.parse(rawConfig);
        config.p2p.seeds = seeds;
        const newConfig = toml_1.default.stringify(config);
        fs_1.default.writeFileSync(configPath, newConfig);
    }
    configure() {
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.ToDo, "Configuring EVM Sidechain network...");
        const nodes = this.initializeNodes();
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, "Nodes initialized");
        const defaultNodePath = this.nodePath("default");
        const defaultNodeService = new NodeService_1.NodeService(this.config, "default", defaultNodePath);
        defaultNodeService.initNode();
        this.overrideGenesis(defaultNodePath);
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Applied default genesis`);
        let allocatedSupply = 0;
        for (const node of nodes) {
            const amount = `${(0, exrpd_1.formatAmount)(Defaults.validatorPoaAmount, Defaults.poaDenom)},${(0, exrpd_1.formatAmount)(Defaults.accountEvmAmount, Defaults.evmDenom)}`;
            defaultNodeService.addGenesisAccount(node.service.info.address, amount);
            allocatedSupply += Defaults.accountEvmAmount;
            (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Added node account ${node.service.info.address} with ${amount}`);
        }
        for (const witness of this.bridgeService.config.witnesses) {
            const cosmosAddress = JSON.parse((0, exrpd_1.exrpd)(`keys parse ${witness.evmAddress.replace("0x", "")} --output json`)).formats[0];
            const amount = (0, exrpd_1.formatAmount)(Defaults.accountEvmAmount, Defaults.evmDenom, 18);
            defaultNodeService.addGenesisAccount(cosmosAddress, amount);
            (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Added witness account ${witness.evmAddress} with ${amount}`);
            allocatedSupply += Defaults.accountEvmAmount;
        }
        for (const account of this.config.extraAccounts) {
            const cosmosAddress = JSON.parse((0, exrpd_1.exrpd)(`keys parse ${account.address.replace("0x", "")} --output json`)).formats[0];
            const amount = (0, exrpd_1.formatAmount)(account.balance, Defaults.evmDenom, 18);
            defaultNodeService.addGenesisAccount(cosmosAddress, amount);
            (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Added extra account ${account.address} with ${amount}`);
            allocatedSupply += account.balance;
        }
        const safeAddress = defaultNodeService.parseHexAddressToBech32(SafeContract_1.XrpSafeContractAddress);
        const chestAmount = (0, exrpd_1.formatAmount)(Defaults.evmSupply - allocatedSupply, Defaults.evmDenom, 18);
        defaultNodeService.addGenesisAccount(safeAddress, chestAmount);
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Added chest account ${safeAddress} with ${chestAmount}`);
        this.addGenesisBridgeContracts(defaultNodePath);
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Added genesis bridge contracts`);
        fs_1.default.mkdirSync(path_1.default.join(defaultNodePath, "/config/gentx/"));
        for (const node of nodes) {
            fs_1.default.copyFileSync(path_1.default.join(defaultNodePath, `/config/genesis.json`), path_1.default.join(this.nodePath(node.name), `/config/genesis.json`));
            node.service.signGenesisStakeTransaction((0, exrpd_1.formatAmount)(Defaults.validatorPoaAmount, Defaults.poaDenom));
            this.collectGenesisTransactions(this.nodePath(node.name), defaultNodePath, defaultNodeService);
        }
        for (const node of nodes) {
            this.copyGenesis(defaultNodePath, this.nodePath(node.name));
        }
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Distributed genesis to all nodes`);
        const seeds = nodes.map((node) => `${node.service.info.id}@${node.host}:26656`).join(",");
        for (const node of nodes) {
            this.overrideSeeds(this.nodePath(node.name), seeds);
        }
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Working, `Configured persistent peers to all nodes`);
        fs_1.default.copyFileSync(path_1.default.join(defaultNodePath, "/config/genesis.json"), path_1.default.join(this.exportPath, "genesis.json"));
        fs_1.default.writeFileSync(path_1.default.join(this.exportPath, "nodes.json"), JSON.stringify(nodes));
        (0, Logger_1.Log)(Logger_1.LogType.Network, Logger_1.LogStatus.Done, "EVM Sidechain network configured");
        return nodes;
    }
}
exports.BlockchainService = BlockchainService;
//# sourceMappingURL=BlockchainService.js.map