var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 ||= {})
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __commonJS = (cb, mod4) => function __require() {
  return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var __export = (target, all2) => {
  for (var name6 in all2)
    __defProp(target, name6, { get: all2[name6], enumerable: true });
};
var __copyProps = (to, from7, except, desc) => {
  if (from7 && typeof from7 === "object" || typeof from7 === "function") {
    for (let key of __getOwnPropNames(from7))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from7[key], enumerable: !(desc = __getOwnPropDesc(from7, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
  mod4
));
var __toCommonJS = (mod4) => __copyProps(__defProp({}, "__esModule", { value: true }), mod4);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve5, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve5(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it2, method) => {
  it2 = obj[Symbol.asyncIterator];
  method = (key, fn) => (fn = obj[key]) && (it2[key] = (arg) => new Promise((resolve5, reject, done) => {
    arg = fn.call(obj, arg);
    done = arg.done;
    return Promise.resolve(arg.value).then((value) => resolve5({ value, done }), reject);
  }));
  return it2 ? it2.call(obj) : (obj = obj[Symbol.iterator](), it2 = {}, method("next"), method("return"), it2);
};

// ../../node_modules/flat/index.js
var require_flat = __commonJS({
  "../../node_modules/flat/index.js"(exports2, module2) {
    module2.exports = flatten3;
    flatten3.flatten = flatten3;
    flatten3.unflatten = unflatten;
    function isBuffer3(obj) {
      return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function keyIdentity(key) {
      return key;
    }
    function flatten3(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const maxDepth = opts.maxDepth;
      const transformKey = opts.transformKey || keyIdentity;
      const output = {};
      function step(object, prev, currentDepth) {
        currentDepth = currentDepth || 1;
        Object.keys(object).forEach(function(key) {
          const value = object[key];
          const isarray = opts.safe && Array.isArray(value);
          const type = Object.prototype.toString.call(value);
          const isbuffer = isBuffer3(value);
          const isobject = type === "[object Object]" || type === "[object Array]";
          const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
          if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
            return step(value, newKey, currentDepth + 1);
          }
          output[newKey] = value;
        });
      }
      step(target);
      return output;
    }
    function unflatten(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const overwrite = opts.overwrite || false;
      const transformKey = opts.transformKey || keyIdentity;
      const result = {};
      const isbuffer = isBuffer3(target);
      if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
        return target;
      }
      function getkey(key) {
        const parsedKey = Number(key);
        return isNaN(parsedKey) || key.indexOf(".") !== -1 || opts.object ? key : parsedKey;
      }
      function addKeys(keyPrefix, recipient, target2) {
        return Object.keys(target2).reduce(function(result2, key) {
          result2[keyPrefix + delimiter + key] = target2[key];
          return result2;
        }, recipient);
      }
      function isEmpty(val) {
        const type = Object.prototype.toString.call(val);
        const isArray = type === "[object Array]";
        const isObject = type === "[object Object]";
        if (!val) {
          return true;
        } else if (isArray) {
          return !val.length;
        } else if (isObject) {
          return !Object.keys(val).length;
        }
      }
      target = Object.keys(target).reduce(function(result2, key) {
        const type = Object.prototype.toString.call(target[key]);
        const isObject = type === "[object Object]" || type === "[object Array]";
        if (!isObject || isEmpty(target[key])) {
          result2[key] = target[key];
          return result2;
        } else {
          return addKeys(
            key,
            result2,
            flatten3(target[key], opts)
          );
        }
      }, {});
      Object.keys(target).forEach(function(key) {
        const split = key.split(delimiter).map(transformKey);
        let key1 = getkey(split.shift());
        let key2 = getkey(split[0]);
        let recipient = result;
        while (key2 !== void 0) {
          if (key1 === "__proto__") {
            return;
          }
          const type = Object.prototype.toString.call(recipient[key1]);
          const isobject = type === "[object Object]" || type === "[object Array]";
          if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
            return;
          }
          if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
            recipient[key1] = typeof key2 === "number" && !opts.object ? [] : {};
          }
          recipient = recipient[key1];
          if (split.length > 0) {
            key1 = getkey(split.shift());
            key2 = getkey(split[0]);
          }
        }
        recipient[key1] = unflatten(target[key], opts);
      });
      return result;
    }
  }
});

// ../../node_modules/err-code/index.js
var require_err_code = __commonJS({
  "../../node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code9, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code9 === "object") {
        props = code9;
        code9 = "";
      }
      if (code9) {
        props.code = code9;
      }
      try {
        return assign(err, props);
      } catch (_2) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve5, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve5.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base642 = exports2;
    base642.length = function length5(string2) {
      var p2 = string2.length;
      if (!p2)
        return 0;
      var n2 = 0;
      while (--p2 % 4 > 1 && string2.charAt(p2) === "=")
        ++n2;
      return Math.ceil(string2.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    var i2;
    base642.encode = function encode17(buffer2, start, end) {
      var parts = null, chunk = [];
      var i3 = 0, j2 = 0, t2;
      while (start < end) {
        var b2 = buffer2[start++];
        switch (j2) {
          case 0:
            chunk[i3++] = b64[b2 >> 2];
            t2 = (b2 & 3) << 4;
            j2 = 1;
            break;
          case 1:
            chunk[i3++] = b64[t2 | b2 >> 4];
            t2 = (b2 & 15) << 2;
            j2 = 2;
            break;
          case 2:
            chunk[i3++] = b64[t2 | b2 >> 6];
            chunk[i3++] = b64[b2 & 63];
            j2 = 0;
            break;
        }
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j2) {
        chunk[i3++] = b64[t2];
        chunk[i3++] = 61;
        if (j2 === 1)
          chunk[i3++] = 61;
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode25(string2, buffer2, offset) {
      var start = offset;
      var j2 = 0, t2;
      for (var i3 = 0; i3 < string2.length; ) {
        var c2 = string2.charCodeAt(i3++);
        if (c2 === 61 && j2 > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j2) {
          case 0:
            t2 = c2;
            j2 = 1;
            break;
          case 1:
            buffer2[offset++] = t2 << 2 | (c2 & 48) >> 4;
            t2 = c2;
            j2 = 2;
            break;
          case 2:
            buffer2[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
            t2 = c2;
            j2 = 3;
            break;
          case 3:
            buffer2[offset++] = (t2 & 3) << 6 | c2;
            j2 = 0;
            break;
        }
      }
      if (j2 === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i2 = 0; i2 < listeners.length; )
            if (listeners[i2].fn === fn)
              listeners.splice(i2, 1);
            else
              ++i2;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i2 = 1;
        for (; i2 < arguments.length; )
          args.push(arguments[i2++]);
        for (i2 = 0; i2 < listeners.length; )
          listeners[i2].fn.apply(listeners[i2++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[3];
            buf2[pos + 1] = f8b[2];
            buf2[pos + 2] = f8b[1];
            buf2[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf2, pos) {
            f8b[3] = buf2[pos];
            f8b[2] = buf2[pos + 1];
            f8b[1] = buf2[pos + 2];
            f8b[0] = buf2[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf2, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf2, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign3 << 31 | 2139095040) >>> 0, buf2, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf2, pos) {
            var uint = readUint(buf2, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
            buf2[pos + 4] = f8b[4];
            buf2[pos + 5] = f8b[5];
            buf2[pos + 6] = f8b[6];
            buf2[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[7];
            buf2[pos + 1] = f8b[6];
            buf2[pos + 2] = f8b[5];
            buf2[pos + 3] = f8b[4];
            buf2[pos + 4] = f8b[3];
            buf2[pos + 5] = f8b[2];
            buf2[pos + 6] = f8b[1];
            buf2[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            f8b[4] = buf2[pos + 4];
            f8b[5] = buf2[pos + 5];
            f8b[6] = buf2[pos + 6];
            f8b[7] = buf2[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf2, pos) {
            f8b[7] = buf2[pos];
            f8b[6] = buf2[pos + 1];
            f8b[5] = buf2[pos + 2];
            f8b[4] = buf2[pos + 3];
            f8b[3] = buf2[pos + 4];
            f8b[2] = buf2[pos + 5];
            f8b[1] = buf2[pos + 6];
            f8b[0] = buf2[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0) {
              writeUint(0, buf2, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf2, pos + off0);
              writeUint(2146959360, buf2, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf2, pos + off0);
              writeUint((sign3 << 31 | 2146435072) >>> 0, buf2, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf2, pos + off0);
                writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
            var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
            var sign3 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c2 = 0;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c2 = string2.charCodeAt(i2);
        if (c2 < 128)
          len += 1;
        else if (c2 < 2048)
          len += 2;
        else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i2 = 0, t2;
      while (start < end) {
        t2 = buffer2[start++];
        if (t2 < 128)
          chunk[i2++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i2++] = (t2 & 31) << 6 | buffer2[start++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i2++] = 55296 + (t2 >> 10);
          chunk[i2++] = 56320 + (t2 & 1023);
        } else
          chunk[i2++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf8.write = function utf8_write(string2, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c1 = string2.charCodeAt(i2);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc3, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc3(size2);
        if (offset + size2 > SIZE) {
          slab = alloc3(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// ../../node_modules/protons-runtime/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/protons-runtime/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util2 = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign3 = value < 0;
      if (sign3)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from7(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util2.isString(value)) {
        if (util2.Long)
          value = util2.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length5() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protons-runtime/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/protons-runtime/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util2 = exports2;
    util2.asPromise = require_aspromise();
    util2.base64 = require_base64();
    util2.EventEmitter = require_eventemitter();
    util2.float = require_float();
    util2.inquire = require_inquire();
    util2.utf8 = require_utf8();
    util2.pool = require_pool();
    util2.LongBits = require_longbits();
    util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util2.LongBits.fromHash(hash);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src5, ifNotSet) {
      for (var keys = Object.keys(src5), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src5[keys[i2]];
      return dst;
    }
    util2.merge = merge;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name6) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get2() {
            return name6;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name6) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name6)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/protons-runtime/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/protons-runtime/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util2 = require_minimal();
    var BufferReader;
    var LongBits = util2.LongBits;
    var utf8 = util2.utf8;
    function indexOutOfRange(reader2, writeLength) {
      return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create5 = function create6() {
      return util2.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create5();
    Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
    util2.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length5 = this.uint32(), start = this.pos, end = this.pos + length5;
      if (end > this.len)
        throw indexOutOfRange(this, length5);
      this.pos += length5;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length5) {
      if (typeof length5 === "number") {
        if (this.pos + length5 > this.len)
          throw indexOutOfRange(this, length5);
        this.pos += length5;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create5();
      BufferReader._configure();
      var fn = util2.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util2.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protons-runtime/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/protons-runtime/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util2 = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util2.Buffer)
        BufferReader.prototype._slice = util2.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protons-runtime/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/protons-runtime/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util2 = require_minimal();
    var BufferWriter;
    var LongBits = util2.LongBits;
    var base642 = util2.base64;
    var utf8 = util2.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer2) {
      this.head = writer2.head;
      this.tail = writer2.tail;
      this.len = writer2.len;
      this.next = writer2.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create5 = function create6() {
      return util2.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create5();
    Writer.alloc = function alloc3(size) {
      return new util2.Array(size);
    };
    if (util2.Array !== Array)
      Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util2.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util2.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf2[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util2.isString(value)) {
        var buf2 = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf2, 0);
        value = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create5();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protons-runtime/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/protons-runtime/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util2 = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util2._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf2[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util2.isString(value))
        value = util2._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util2.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util2.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/sparse-array/index.js
var require_sparse_array = __commonJS({
  "../../node_modules/sparse-array/index.js"(exports2, module2) {
    "use strict";
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value) {
        this.set(this.length, value);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last2 = this._data[this._data.length - 1];
          this._length = last2 ? last2[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i2 = 0;
        while (i2 < this.length) {
          iterator(this.get(i2), i2, this);
          i2++;
        }
      }
      map(iterator) {
        let i2 = 0;
        let mapped = new Array(this.length);
        while (i2 < this.length) {
          mapped[i2] = iterator(this.get(i2), i2, this);
          i2++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i2 = 0;
        let acc = initialValue;
        while (i2 < this.length) {
          const value = this.get(i2);
          acc = reducer(acc, value, i2);
          i2++;
        }
        return acc;
      }
      find(finder) {
        let i2 = 0, found, last2;
        while (i2 < this.length && !found) {
          last2 = this.get(i2);
          found = finder(last2);
          i2++;
        }
        return found ? last2 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists2 = (byte & 1 << bitPos) > 0;
        if (!exists2) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [index, value];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i2 = bytes.length - 1; i2 > 0; i2--) {
          const value = bytes[i2];
          if (value === 0) {
            bytes.pop();
          } else {
            break;
          }
        }
        return bytes;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v2 = _v;
      v2 = v2 - (v2 >> 1 & 1431655765);
      v2 = (v2 & 858993459) + (v2 >> 2 & 858993459);
      return (v2 + (v2 >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a2, b2) {
      return a2[0] - b2[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// ../../node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes) {
        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
          return false;
        }
        for (var i2 = 0; i2 < bytes.length; i2++) {
          if (!Number.isInteger(bytes[i2]) || bytes[i2] < 0 || bytes[i2] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m2, n2) {
        return (m2 & 65535) * n2 + (((m2 >>> 16) * n2 & 65535) << 16);
      }
      function _x86Rotl(m2, n2) {
        return m2 << n2 | m2 >>> 32 - n2;
      }
      function _x86Fmix(h2) {
        h2 ^= h2 >>> 16;
        h2 = _x86Multiply(h2, 2246822507);
        h2 ^= h2 >>> 13;
        h2 = _x86Multiply(h2, 3266489909);
        h2 ^= h2 >>> 16;
        return h2;
      }
      function _x64Add(m2, n2) {
        m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
        n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
        var o2 = [0, 0, 0, 0];
        o2[3] += m2[3] + n2[3];
        o2[2] += o2[3] >>> 16;
        o2[3] &= 65535;
        o2[2] += m2[2] + n2[2];
        o2[1] += o2[2] >>> 16;
        o2[2] &= 65535;
        o2[1] += m2[1] + n2[1];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[0] += m2[0] + n2[0];
        o2[0] &= 65535;
        return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
      }
      function _x64Multiply(m2, n2) {
        m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
        n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
        var o2 = [0, 0, 0, 0];
        o2[3] += m2[3] * n2[3];
        o2[2] += o2[3] >>> 16;
        o2[3] &= 65535;
        o2[2] += m2[2] * n2[3];
        o2[1] += o2[2] >>> 16;
        o2[2] &= 65535;
        o2[2] += m2[3] * n2[2];
        o2[1] += o2[2] >>> 16;
        o2[2] &= 65535;
        o2[1] += m2[1] * n2[3];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[1] += m2[2] * n2[2];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[1] += m2[3] * n2[1];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[0] += m2[0] * n2[3] + m2[1] * n2[2] + m2[2] * n2[1] + m2[3] * n2[0];
        o2[0] &= 65535;
        return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
      }
      function _x64Rotl(m2, n2) {
        n2 %= 64;
        if (n2 === 32) {
          return [m2[1], m2[0]];
        } else if (n2 < 32) {
          return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2 | m2[0] >>> 32 - n2];
        } else {
          n2 -= 32;
          return [m2[1] << n2 | m2[0] >>> 32 - n2, m2[0] << n2 | m2[1] >>> 32 - n2];
        }
      }
      function _x64LeftShift(m2, n2) {
        n2 %= 64;
        if (n2 === 0) {
          return m2;
        } else if (n2 < 32) {
          return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2];
        } else {
          return [m2[1] << n2 - 32, 0];
        }
      }
      function _x64Xor(m2, n2) {
        return [m2[0] ^ n2[0], m2[1] ^ n2[1]];
      }
      function _x64Fmix(h2) {
        h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
        h2 = _x64Multiply(h2, [4283543511, 3981806797]);
        h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
        h2 = _x64Multiply(h2, [3301882366, 444984403]);
        h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
        return h2;
      }
      library.x86.hash32 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 4;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
          k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes[i2 + 2] << 16;
          case 2:
            k1 ^= bytes[i2 + 1] << 8;
          case 1:
            k1 ^= bytes[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
          k2 = bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24;
          k3 = bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24;
          k4 = bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes[i2 + 14] << 16;
          case 14:
            k4 ^= bytes[i2 + 13] << 8;
          case 13:
            k4 ^= bytes[i2 + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes[i2 + 11] << 24;
          case 11:
            k3 ^= bytes[i2 + 10] << 16;
          case 10:
            k3 ^= bytes[i2 + 9] << 8;
          case 9:
            k3 ^= bytes[i2 + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes[i2 + 7] << 24;
          case 7:
            k2 ^= bytes[i2 + 6] << 16;
          case 6:
            k2 ^= bytes[i2 + 5] << 8;
          case 5:
            k2 ^= bytes[i2 + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes[i2 + 3] << 24;
          case 3:
            k1 ^= bytes[i2 + 2] << 16;
          case 2:
            k1 ^= bytes[i2 + 1] << 8;
          case 1:
            k1 ^= bytes[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h2 ^= bytes.length;
        h3 ^= bytes.length;
        h4 ^= bytes.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = [bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24, bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24];
          k2 = [bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24, bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes[i2 + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes[i2]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes.length]);
        h2 = _x64Xor(h2, [0, bytes.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports2);
  }
});

// ../../node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "../../node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    module2.exports = require_murmurHash3js();
  }
});

// ../../node_modules/jsbi/dist/jsbi-cjs.js
var require_jsbi_cjs = __commonJS({
  "../../node_modules/jsbi/dist/jsbi-cjs.js"(exports2, module2) {
    "use strict";
    var JSBI = class extends Array {
      constructor(i2, _2) {
        if (super(i2), this.sign = _2, Object.setPrototypeOf(this, JSBI.prototype), i2 > JSBI.__kMaxLength)
          throw new RangeError("Maximum BigInt size exceeded");
      }
      static BigInt(i2) {
        var _2 = Math.floor, t2 = Number.isFinite;
        if ("number" == typeof i2) {
          if (0 === i2)
            return JSBI.__zero();
          if (JSBI.__isOneDigitInt(i2))
            return 0 > i2 ? JSBI.__oneDigit(-i2, true) : JSBI.__oneDigit(i2, false);
          if (!t2(i2) || _2(i2) !== i2)
            throw new RangeError("The number " + i2 + " cannot be converted to BigInt because it is not an integer");
          return JSBI.__fromDouble(i2);
        }
        if ("string" == typeof i2) {
          const _3 = JSBI.__fromString(i2);
          if (null === _3)
            throw new SyntaxError("Cannot convert " + i2 + " to a BigInt");
          return _3;
        }
        if ("boolean" == typeof i2)
          return true === i2 ? JSBI.__oneDigit(1, false) : JSBI.__zero();
        if ("object" == typeof i2) {
          if (i2.constructor === JSBI)
            return i2;
          const _3 = JSBI.__toPrimitive(i2);
          return JSBI.BigInt(_3);
        }
        throw new TypeError("Cannot convert " + i2 + " to a BigInt");
      }
      toDebugString() {
        const i2 = ["BigInt["];
        for (const _2 of this)
          i2.push((_2 ? (_2 >>> 0).toString(16) : _2) + ", ");
        return i2.push("]"), i2.join("");
      }
      toString(i2 = 10) {
        if (2 > i2 || 36 < i2)
          throw new RangeError("toString() radix argument must be between 2 and 36");
        return 0 === this.length ? "0" : 0 == (i2 & i2 - 1) ? JSBI.__toStringBasePowerOfTwo(this, i2) : JSBI.__toStringGeneric(this, i2, false);
      }
      valueOf() {
        throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
      }
      static toNumber(i2) {
        const _2 = i2.length;
        if (0 === _2)
          return 0;
        if (1 === _2) {
          const _3 = i2.__unsignedDigit(0);
          return i2.sign ? -_3 : _3;
        }
        const t2 = i2.__digit(_2 - 1), e2 = JSBI.__clz30(t2), n2 = 30 * _2 - e2;
        if (1024 < n2)
          return i2.sign ? -Infinity : 1 / 0;
        let g2 = n2 - 1, s2 = t2, o2 = _2 - 1;
        const l2 = e2 + 3;
        let r2 = 32 === l2 ? 0 : s2 << l2;
        r2 >>>= 12;
        const a2 = l2 - 12;
        let u2 = 12 <= l2 ? 0 : s2 << 20 + l2, d2 = 20 + l2;
        for (0 < a2 && 0 < o2 && (o2--, s2 = i2.__digit(o2), r2 |= s2 >>> 30 - a2, u2 = s2 << a2 + 2, d2 = a2 + 2); 0 < d2 && 0 < o2; )
          o2--, s2 = i2.__digit(o2), u2 |= 30 <= d2 ? s2 << d2 - 30 : s2 >>> 30 - d2, d2 -= 30;
        const h2 = JSBI.__decideRounding(i2, d2, o2, s2);
        if ((1 === h2 || 0 === h2 && 1 == (1 & u2)) && (u2 = u2 + 1 >>> 0, 0 === u2 && (r2++, 0 != r2 >>> 20 && (r2 = 0, g2++, 1023 < g2))))
          return i2.sign ? -Infinity : 1 / 0;
        const m2 = i2.sign ? -2147483648 : 0;
        return g2 = g2 + 1023 << 20, JSBI.__kBitConversionInts[1] = m2 | g2 | r2, JSBI.__kBitConversionInts[0] = u2, JSBI.__kBitConversionDouble[0];
      }
      static unaryMinus(i2) {
        if (0 === i2.length)
          return i2;
        const _2 = i2.__copy();
        return _2.sign = !i2.sign, _2;
      }
      static bitwiseNot(i2) {
        return i2.sign ? JSBI.__absoluteSubOne(i2).__trim() : JSBI.__absoluteAddOne(i2, true);
      }
      static exponentiate(i2, _2) {
        if (_2.sign)
          throw new RangeError("Exponent must be positive");
        if (0 === _2.length)
          return JSBI.__oneDigit(1, false);
        if (0 === i2.length)
          return i2;
        if (1 === i2.length && 1 === i2.__digit(0))
          return i2.sign && 0 == (1 & _2.__digit(0)) ? JSBI.unaryMinus(i2) : i2;
        if (1 < _2.length)
          throw new RangeError("BigInt too big");
        let t2 = _2.__unsignedDigit(0);
        if (1 === t2)
          return i2;
        if (t2 >= JSBI.__kMaxLengthBits)
          throw new RangeError("BigInt too big");
        if (1 === i2.length && 2 === i2.__digit(0)) {
          const _3 = 1 + (0 | t2 / 30), e3 = i2.sign && 0 != (1 & t2), n3 = new JSBI(_3, e3);
          n3.__initializeDigits();
          const g2 = 1 << t2 % 30;
          return n3.__setDigit(_3 - 1, g2), n3;
        }
        let e2 = null, n2 = i2;
        for (0 != (1 & t2) && (e2 = i2), t2 >>= 1; 0 !== t2; t2 >>= 1)
          n2 = JSBI.multiply(n2, n2), 0 != (1 & t2) && (null === e2 ? e2 = n2 : e2 = JSBI.multiply(e2, n2));
        return e2;
      }
      static multiply(_2, t2) {
        if (0 === _2.length)
          return _2;
        if (0 === t2.length)
          return t2;
        let i2 = _2.length + t2.length;
        30 <= _2.__clzmsd() + t2.__clzmsd() && i2--;
        const e2 = new JSBI(i2, _2.sign !== t2.sign);
        e2.__initializeDigits();
        for (let n2 = 0; n2 < _2.length; n2++)
          JSBI.__multiplyAccumulate(t2, _2.__digit(n2), e2, n2);
        return e2.__trim();
      }
      static divide(i2, _2) {
        if (0 === _2.length)
          throw new RangeError("Division by zero");
        if (0 > JSBI.__absoluteCompare(i2, _2))
          return JSBI.__zero();
        const t2 = i2.sign !== _2.sign, e2 = _2.__unsignedDigit(0);
        let n2;
        if (1 === _2.length && 32767 >= e2) {
          if (1 === e2)
            return t2 === i2.sign ? i2 : JSBI.unaryMinus(i2);
          n2 = JSBI.__absoluteDivSmall(i2, e2, null);
        } else
          n2 = JSBI.__absoluteDivLarge(i2, _2, true, false);
        return n2.sign = t2, n2.__trim();
      }
      static remainder(i2, _2) {
        if (0 === _2.length)
          throw new RangeError("Division by zero");
        if (0 > JSBI.__absoluteCompare(i2, _2))
          return i2;
        const t2 = _2.__unsignedDigit(0);
        if (1 === _2.length && 32767 >= t2) {
          if (1 === t2)
            return JSBI.__zero();
          const _3 = JSBI.__absoluteModSmall(i2, t2);
          return 0 === _3 ? JSBI.__zero() : JSBI.__oneDigit(_3, i2.sign);
        }
        const e2 = JSBI.__absoluteDivLarge(i2, _2, false, true);
        return e2.sign = i2.sign, e2.__trim();
      }
      static add(i2, _2) {
        const t2 = i2.sign;
        return t2 === _2.sign ? JSBI.__absoluteAdd(i2, _2, t2) : 0 <= JSBI.__absoluteCompare(i2, _2) ? JSBI.__absoluteSub(i2, _2, t2) : JSBI.__absoluteSub(_2, i2, !t2);
      }
      static subtract(i2, _2) {
        const t2 = i2.sign;
        return t2 === _2.sign ? 0 <= JSBI.__absoluteCompare(i2, _2) ? JSBI.__absoluteSub(i2, _2, t2) : JSBI.__absoluteSub(_2, i2, !t2) : JSBI.__absoluteAdd(i2, _2, t2);
      }
      static leftShift(i2, _2) {
        return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? JSBI.__rightShiftByAbsolute(i2, _2) : JSBI.__leftShiftByAbsolute(i2, _2);
      }
      static signedRightShift(i2, _2) {
        return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? JSBI.__leftShiftByAbsolute(i2, _2) : JSBI.__rightShiftByAbsolute(i2, _2);
      }
      static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
      }
      static lessThan(i2, _2) {
        return 0 > JSBI.__compareToBigInt(i2, _2);
      }
      static lessThanOrEqual(i2, _2) {
        return 0 >= JSBI.__compareToBigInt(i2, _2);
      }
      static greaterThan(i2, _2) {
        return 0 < JSBI.__compareToBigInt(i2, _2);
      }
      static greaterThanOrEqual(i2, _2) {
        return 0 <= JSBI.__compareToBigInt(i2, _2);
      }
      static equal(_2, t2) {
        if (_2.sign !== t2.sign)
          return false;
        if (_2.length !== t2.length)
          return false;
        for (let e2 = 0; e2 < _2.length; e2++)
          if (_2.__digit(e2) !== t2.__digit(e2))
            return false;
        return true;
      }
      static notEqual(i2, _2) {
        return !JSBI.equal(i2, _2);
      }
      static bitwiseAnd(i2, _2) {
        var t2 = Math.max;
        if (!i2.sign && !_2.sign)
          return JSBI.__absoluteAnd(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          const e2 = t2(i2.length, _2.length) + 1;
          let n2 = JSBI.__absoluteSubOne(i2, e2);
          const g2 = JSBI.__absoluteSubOne(_2);
          return n2 = JSBI.__absoluteOr(n2, g2, n2), JSBI.__absoluteAddOne(n2, true, n2).__trim();
        }
        return i2.sign && ([i2, _2] = [_2, i2]), JSBI.__absoluteAndNot(i2, JSBI.__absoluteSubOne(_2)).__trim();
      }
      static bitwiseXor(i2, _2) {
        var t2 = Math.max;
        if (!i2.sign && !_2.sign)
          return JSBI.__absoluteXor(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          const e3 = t2(i2.length, _2.length), n3 = JSBI.__absoluteSubOne(i2, e3), g2 = JSBI.__absoluteSubOne(_2);
          return JSBI.__absoluteXor(n3, g2, n3).__trim();
        }
        const e2 = t2(i2.length, _2.length) + 1;
        i2.sign && ([i2, _2] = [_2, i2]);
        let n2 = JSBI.__absoluteSubOne(_2, e2);
        return n2 = JSBI.__absoluteXor(n2, i2, n2), JSBI.__absoluteAddOne(n2, true, n2).__trim();
      }
      static bitwiseOr(i2, _2) {
        var t2 = Math.max;
        const e2 = t2(i2.length, _2.length);
        if (!i2.sign && !_2.sign)
          return JSBI.__absoluteOr(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          let t3 = JSBI.__absoluteSubOne(i2, e2);
          const n3 = JSBI.__absoluteSubOne(_2);
          return t3 = JSBI.__absoluteAnd(t3, n3, t3), JSBI.__absoluteAddOne(t3, true, t3).__trim();
        }
        i2.sign && ([i2, _2] = [_2, i2]);
        let n2 = JSBI.__absoluteSubOne(_2, e2);
        return n2 = JSBI.__absoluteAndNot(n2, i2, n2), JSBI.__absoluteAddOne(n2, true, n2).__trim();
      }
      static asIntN(_2, t2) {
        var i2 = Math.floor;
        if (0 === t2.length)
          return t2;
        if (_2 = i2(_2), 0 > _2)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === _2)
          return JSBI.__zero();
        if (_2 >= JSBI.__kMaxLengthBits)
          return t2;
        const e2 = 0 | (_2 + 29) / 30;
        if (t2.length < e2)
          return t2;
        const g2 = t2.__unsignedDigit(e2 - 1), s2 = 1 << (_2 - 1) % 30;
        if (t2.length === e2 && g2 < s2)
          return t2;
        if (!((g2 & s2) === s2))
          return JSBI.__truncateToNBits(_2, t2);
        if (!t2.sign)
          return JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, true);
        if (0 == (g2 & s2 - 1)) {
          for (let n2 = e2 - 2; 0 <= n2; n2--)
            if (0 !== t2.__digit(n2))
              return JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
          return t2.length === e2 && g2 === s2 ? t2 : JSBI.__truncateToNBits(_2, t2);
        }
        return JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
      }
      static asUintN(i2, _2) {
        var t2 = Math.floor;
        if (0 === _2.length)
          return _2;
        if (i2 = t2(i2), 0 > i2)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === i2)
          return JSBI.__zero();
        if (_2.sign) {
          if (i2 > JSBI.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          return JSBI.__truncateAndSubFromPowerOfTwo(i2, _2, false);
        }
        if (i2 >= JSBI.__kMaxLengthBits)
          return _2;
        const e2 = 0 | (i2 + 29) / 30;
        if (_2.length < e2)
          return _2;
        const g2 = i2 % 30;
        if (_2.length == e2) {
          if (0 === g2)
            return _2;
          const i3 = _2.__digit(e2 - 1);
          if (0 == i3 >>> g2)
            return _2;
        }
        return JSBI.__truncateToNBits(i2, _2);
      }
      static ADD(i2, _2) {
        if (i2 = JSBI.__toPrimitive(i2), _2 = JSBI.__toPrimitive(_2), "string" == typeof i2)
          return "string" != typeof _2 && (_2 = _2.toString()), i2 + _2;
        if ("string" == typeof _2)
          return i2.toString() + _2;
        if (i2 = JSBI.__toNumeric(i2), _2 = JSBI.__toNumeric(_2), JSBI.__isBigInt(i2) && JSBI.__isBigInt(_2))
          return JSBI.add(i2, _2);
        if ("number" == typeof i2 && "number" == typeof _2)
          return i2 + _2;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
      }
      static LT(i2, _2) {
        return JSBI.__compare(i2, _2, 0);
      }
      static LE(i2, _2) {
        return JSBI.__compare(i2, _2, 1);
      }
      static GT(i2, _2) {
        return JSBI.__compare(i2, _2, 2);
      }
      static GE(i2, _2) {
        return JSBI.__compare(i2, _2, 3);
      }
      static EQ(i2, _2) {
        for (; ; ) {
          if (JSBI.__isBigInt(i2))
            return JSBI.__isBigInt(_2) ? JSBI.equal(i2, _2) : JSBI.EQ(_2, i2);
          if ("number" == typeof i2) {
            if (JSBI.__isBigInt(_2))
              return JSBI.__equalToNumber(_2, i2);
            if ("object" != typeof _2)
              return i2 == _2;
            _2 = JSBI.__toPrimitive(_2);
          } else if ("string" == typeof i2) {
            if (JSBI.__isBigInt(_2))
              return i2 = JSBI.__fromString(i2), null !== i2 && JSBI.equal(i2, _2);
            if ("object" != typeof _2)
              return i2 == _2;
            _2 = JSBI.__toPrimitive(_2);
          } else if ("boolean" == typeof i2) {
            if (JSBI.__isBigInt(_2))
              return JSBI.__equalToNumber(_2, +i2);
            if ("object" != typeof _2)
              return i2 == _2;
            _2 = JSBI.__toPrimitive(_2);
          } else if ("symbol" == typeof i2) {
            if (JSBI.__isBigInt(_2))
              return false;
            if ("object" != typeof _2)
              return i2 == _2;
            _2 = JSBI.__toPrimitive(_2);
          } else if ("object" == typeof i2) {
            if ("object" == typeof _2 && _2.constructor !== JSBI)
              return i2 == _2;
            i2 = JSBI.__toPrimitive(i2);
          } else
            return i2 == _2;
        }
      }
      static NE(i2, _2) {
        return !JSBI.EQ(i2, _2);
      }
      static DataViewGetBigInt64(i2, _2, t2 = false) {
        return JSBI.asIntN(64, JSBI.DataViewGetBigUint64(i2, _2, t2));
      }
      static DataViewGetBigUint64(i2, _2, t2 = false) {
        const [e2, n2] = t2 ? [4, 0] : [0, 4], g2 = i2.getUint32(_2 + e2, t2), s2 = i2.getUint32(_2 + n2, t2), o2 = new JSBI(3, false);
        return o2.__setDigit(0, 1073741823 & s2), o2.__setDigit(1, (268435455 & g2) << 2 | s2 >>> 30), o2.__setDigit(2, g2 >>> 28), o2.__trim();
      }
      static DataViewSetBigInt64(i2, _2, t2, e2 = false) {
        JSBI.DataViewSetBigUint64(i2, _2, t2, e2);
      }
      static DataViewSetBigUint64(i2, _2, t2, e2 = false) {
        t2 = JSBI.asUintN(64, t2);
        let n2 = 0, g2 = 0;
        if (0 < t2.length && (g2 = t2.__digit(0), 1 < t2.length)) {
          const i3 = t2.__digit(1);
          g2 |= i3 << 30, n2 = i3 >>> 2, 2 < t2.length && (n2 |= t2.__digit(2) << 28);
        }
        const [s2, o2] = e2 ? [4, 0] : [0, 4];
        i2.setUint32(_2 + s2, n2, e2), i2.setUint32(_2 + o2, g2, e2);
      }
      static __zero() {
        return new JSBI(0, false);
      }
      static __oneDigit(i2, _2) {
        const t2 = new JSBI(1, _2);
        return t2.__setDigit(0, i2), t2;
      }
      __copy() {
        const _2 = new JSBI(this.length, this.sign);
        for (let t2 = 0; t2 < this.length; t2++)
          _2[t2] = this[t2];
        return _2;
      }
      __trim() {
        let i2 = this.length, _2 = this[i2 - 1];
        for (; 0 === _2; )
          i2--, _2 = this[i2 - 1], this.pop();
        return 0 === i2 && (this.sign = false), this;
      }
      __initializeDigits() {
        for (let _2 = 0; _2 < this.length; _2++)
          this[_2] = 0;
      }
      static __decideRounding(i2, _2, t2, e2) {
        if (0 < _2)
          return -1;
        let n2;
        if (0 > _2)
          n2 = -_2 - 1;
        else {
          if (0 === t2)
            return -1;
          t2--, e2 = i2.__digit(t2), n2 = 29;
        }
        let g2 = 1 << n2;
        if (0 == (e2 & g2))
          return -1;
        if (g2 -= 1, 0 != (e2 & g2))
          return 1;
        for (; 0 < t2; )
          if (t2--, 0 !== i2.__digit(t2))
            return 1;
        return 0;
      }
      static __fromDouble(i2) {
        JSBI.__kBitConversionDouble[0] = i2;
        const _2 = 2047 & JSBI.__kBitConversionInts[1] >>> 20, t2 = _2 - 1023, e2 = (0 | t2 / 30) + 1, n2 = new JSBI(e2, 0 > i2);
        let g2 = 1048575 & JSBI.__kBitConversionInts[1] | 1048576, s2 = JSBI.__kBitConversionInts[0];
        const o2 = 20, l2 = t2 % 30;
        let r2, a2 = 0;
        if (l2 < 20) {
          const i3 = o2 - l2;
          a2 = i3 + 32, r2 = g2 >>> i3, g2 = g2 << 32 - i3 | s2 >>> i3, s2 <<= 32 - i3;
        } else if (l2 === 20)
          a2 = 32, r2 = g2, g2 = s2, s2 = 0;
        else {
          const i3 = l2 - o2;
          a2 = 32 - i3, r2 = g2 << i3 | s2 >>> 32 - i3, g2 = s2 << i3, s2 = 0;
        }
        n2.__setDigit(e2 - 1, r2);
        for (let _3 = e2 - 2; 0 <= _3; _3--)
          0 < a2 ? (a2 -= 30, r2 = g2 >>> 2, g2 = g2 << 30 | s2 >>> 2, s2 <<= 30) : r2 = 0, n2.__setDigit(_3, r2);
        return n2.__trim();
      }
      static __isWhitespace(i2) {
        return !!(13 >= i2 && 9 <= i2) || (159 >= i2 ? 32 == i2 : 131071 >= i2 ? 160 == i2 || 5760 == i2 : 196607 >= i2 ? (i2 &= 131071, 10 >= i2 || 40 == i2 || 41 == i2 || 47 == i2 || 95 == i2 || 4096 == i2) : 65279 == i2);
      }
      static __fromString(i2, _2 = 0) {
        let t2 = 0;
        const e2 = i2.length;
        let n2 = 0;
        if (n2 === e2)
          return JSBI.__zero();
        let g2 = i2.charCodeAt(n2);
        for (; JSBI.__isWhitespace(g2); ) {
          if (++n2 === e2)
            return JSBI.__zero();
          g2 = i2.charCodeAt(n2);
        }
        if (43 === g2) {
          if (++n2 === e2)
            return null;
          g2 = i2.charCodeAt(n2), t2 = 1;
        } else if (45 === g2) {
          if (++n2 === e2)
            return null;
          g2 = i2.charCodeAt(n2), t2 = -1;
        }
        if (0 === _2) {
          if (_2 = 10, 48 === g2) {
            if (++n2 === e2)
              return JSBI.__zero();
            if (g2 = i2.charCodeAt(n2), 88 === g2 || 120 === g2) {
              if (_2 = 16, ++n2 === e2)
                return null;
              g2 = i2.charCodeAt(n2);
            } else if (79 === g2 || 111 === g2) {
              if (_2 = 8, ++n2 === e2)
                return null;
              g2 = i2.charCodeAt(n2);
            } else if (66 === g2 || 98 === g2) {
              if (_2 = 2, ++n2 === e2)
                return null;
              g2 = i2.charCodeAt(n2);
            }
          }
        } else if (16 === _2 && 48 === g2) {
          if (++n2 === e2)
            return JSBI.__zero();
          if (g2 = i2.charCodeAt(n2), 88 === g2 || 120 === g2) {
            if (++n2 === e2)
              return null;
            g2 = i2.charCodeAt(n2);
          }
        }
        if (0 != t2 && 10 !== _2)
          return null;
        for (; 48 === g2; ) {
          if (++n2 === e2)
            return JSBI.__zero();
          g2 = i2.charCodeAt(n2);
        }
        const s2 = e2 - n2;
        let o2 = JSBI.__kMaxBitsPerChar[_2], l2 = JSBI.__kBitsPerCharTableMultiplier - 1;
        if (s2 > 1073741824 / o2)
          return null;
        const r2 = o2 * s2 + l2 >>> JSBI.__kBitsPerCharTableShift, a2 = new JSBI(0 | (r2 + 29) / 30, false), u2 = 10 > _2 ? _2 : 10, h2 = 10 < _2 ? _2 - 10 : 0;
        if (0 == (_2 & _2 - 1)) {
          o2 >>= JSBI.__kBitsPerCharTableShift;
          const _3 = [], t3 = [];
          let s3 = false;
          do {
            let l3 = 0, r3 = 0;
            for (; ; ) {
              let _4;
              if (g2 - 48 >>> 0 < u2)
                _4 = g2 - 48;
              else if ((32 | g2) - 97 >>> 0 < h2)
                _4 = (32 | g2) - 87;
              else {
                s3 = true;
                break;
              }
              if (r3 += o2, l3 = l3 << o2 | _4, ++n2 === e2) {
                s3 = true;
                break;
              }
              if (g2 = i2.charCodeAt(n2), 30 < r3 + o2)
                break;
            }
            _3.push(l3), t3.push(r3);
          } while (!s3);
          JSBI.__fillFromParts(a2, _3, t3);
        } else {
          a2.__initializeDigits();
          let t3 = false, s3 = 0;
          do {
            let r3 = 0, b2 = 1;
            for (; ; ) {
              let o3;
              if (g2 - 48 >>> 0 < u2)
                o3 = g2 - 48;
              else if ((32 | g2) - 97 >>> 0 < h2)
                o3 = (32 | g2) - 87;
              else {
                t3 = true;
                break;
              }
              const l3 = b2 * _2;
              if (1073741823 < l3)
                break;
              if (b2 = l3, r3 = r3 * _2 + o3, s3++, ++n2 === e2) {
                t3 = true;
                break;
              }
              g2 = i2.charCodeAt(n2);
            }
            l2 = 30 * JSBI.__kBitsPerCharTableMultiplier - 1;
            const D2 = 0 | (o2 * s3 + l2 >>> JSBI.__kBitsPerCharTableShift) / 30;
            a2.__inplaceMultiplyAdd(b2, r3, D2);
          } while (!t3);
        }
        if (n2 !== e2) {
          if (!JSBI.__isWhitespace(g2))
            return null;
          for (n2++; n2 < e2; n2++)
            if (g2 = i2.charCodeAt(n2), !JSBI.__isWhitespace(g2))
              return null;
        }
        return a2.sign = -1 == t2, a2.__trim();
      }
      static __fillFromParts(_2, t2, e2) {
        let n2 = 0, g2 = 0, s2 = 0;
        for (let o2 = t2.length - 1; 0 <= o2; o2--) {
          const i2 = t2[o2], l2 = e2[o2];
          g2 |= i2 << s2, s2 += l2, 30 === s2 ? (_2.__setDigit(n2++, g2), s2 = 0, g2 = 0) : 30 < s2 && (_2.__setDigit(n2++, 1073741823 & g2), s2 -= 30, g2 = i2 >>> l2 - s2);
        }
        if (0 !== g2) {
          if (n2 >= _2.length)
            throw new Error("implementation bug");
          _2.__setDigit(n2++, g2);
        }
        for (; n2 < _2.length; n2++)
          _2.__setDigit(n2, 0);
      }
      static __toStringBasePowerOfTwo(_2, i2) {
        const t2 = _2.length;
        let e2 = i2 - 1;
        e2 = (85 & e2 >>> 1) + (85 & e2), e2 = (51 & e2 >>> 2) + (51 & e2), e2 = (15 & e2 >>> 4) + (15 & e2);
        const n2 = e2, g2 = i2 - 1, s2 = _2.__digit(t2 - 1), o2 = JSBI.__clz30(s2);
        let l2 = 0 | (30 * t2 - o2 + n2 - 1) / n2;
        if (_2.sign && l2++, 268435456 < l2)
          throw new Error("string too long");
        const r2 = Array(l2);
        let a2 = l2 - 1, u2 = 0, d2 = 0;
        for (let e3 = 0; e3 < t2 - 1; e3++) {
          const i3 = _2.__digit(e3), t3 = (u2 | i3 << d2) & g2;
          r2[a2--] = JSBI.__kConversionChars[t3];
          const s3 = n2 - d2;
          for (u2 = i3 >>> s3, d2 = 30 - s3; d2 >= n2; )
            r2[a2--] = JSBI.__kConversionChars[u2 & g2], u2 >>>= n2, d2 -= n2;
        }
        const h2 = (u2 | s2 << d2) & g2;
        for (r2[a2--] = JSBI.__kConversionChars[h2], u2 = s2 >>> n2 - d2; 0 !== u2; )
          r2[a2--] = JSBI.__kConversionChars[u2 & g2], u2 >>>= n2;
        if (_2.sign && (r2[a2--] = "-"), -1 != a2)
          throw new Error("implementation bug");
        return r2.join("");
      }
      static __toStringGeneric(_2, i2, t2) {
        const e2 = _2.length;
        if (0 === e2)
          return "";
        if (1 === e2) {
          let e3 = _2.__unsignedDigit(0).toString(i2);
          return false === t2 && _2.sign && (e3 = "-" + e3), e3;
        }
        const n2 = 30 * e2 - JSBI.__clz30(_2.__digit(e2 - 1)), g2 = JSBI.__kMaxBitsPerChar[i2], s2 = g2 - 1;
        let o2 = n2 * JSBI.__kBitsPerCharTableMultiplier;
        o2 += s2 - 1, o2 = 0 | o2 / s2;
        const l2 = o2 + 1 >> 1, r2 = JSBI.exponentiate(JSBI.__oneDigit(i2, false), JSBI.__oneDigit(l2, false));
        let a2, u2;
        const d2 = r2.__unsignedDigit(0);
        if (1 === r2.length && 32767 >= d2) {
          a2 = new JSBI(_2.length, false), a2.__initializeDigits();
          let t3 = 0;
          for (let e3 = 2 * _2.length - 1; 0 <= e3; e3--) {
            const i3 = t3 << 15 | _2.__halfDigit(e3);
            a2.__setHalfDigit(e3, 0 | i3 / d2), t3 = 0 | i3 % d2;
          }
          u2 = t3.toString(i2);
        } else {
          const t3 = JSBI.__absoluteDivLarge(_2, r2, true, true);
          a2 = t3.quotient;
          const e3 = t3.remainder.__trim();
          u2 = JSBI.__toStringGeneric(e3, i2, true);
        }
        a2.__trim();
        let h2 = JSBI.__toStringGeneric(a2, i2, true);
        for (; u2.length < l2; )
          u2 = "0" + u2;
        return false === t2 && _2.sign && (h2 = "-" + h2), h2 + u2;
      }
      static __unequalSign(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteGreater(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteLess(i2) {
        return i2 ? 1 : -1;
      }
      static __compareToBigInt(i2, _2) {
        const t2 = i2.sign;
        if (t2 !== _2.sign)
          return JSBI.__unequalSign(t2);
        const e2 = JSBI.__absoluteCompare(i2, _2);
        return 0 < e2 ? JSBI.__absoluteGreater(t2) : 0 > e2 ? JSBI.__absoluteLess(t2) : 0;
      }
      static __compareToNumber(i2, _2) {
        if (JSBI.__isOneDigitInt(_2)) {
          const t2 = i2.sign, e2 = 0 > _2;
          if (t2 !== e2)
            return JSBI.__unequalSign(t2);
          if (0 === i2.length) {
            if (e2)
              throw new Error("implementation bug");
            return 0 === _2 ? 0 : -1;
          }
          if (1 < i2.length)
            return JSBI.__absoluteGreater(t2);
          const n2 = Math.abs(_2), g2 = i2.__unsignedDigit(0);
          return g2 > n2 ? JSBI.__absoluteGreater(t2) : g2 < n2 ? JSBI.__absoluteLess(t2) : 0;
        }
        return JSBI.__compareToDouble(i2, _2);
      }
      static __compareToDouble(i2, _2) {
        if (_2 !== _2)
          return _2;
        if (_2 === 1 / 0)
          return -1;
        if (_2 === -Infinity)
          return 1;
        const t2 = i2.sign;
        if (t2 !== 0 > _2)
          return JSBI.__unequalSign(t2);
        if (0 === _2)
          throw new Error("implementation bug: should be handled elsewhere");
        if (0 === i2.length)
          return -1;
        JSBI.__kBitConversionDouble[0] = _2;
        const e2 = 2047 & JSBI.__kBitConversionInts[1] >>> 20;
        if (2047 == e2)
          throw new Error("implementation bug: handled elsewhere");
        const n2 = e2 - 1023;
        if (0 > n2)
          return JSBI.__absoluteGreater(t2);
        const g2 = i2.length;
        let s2 = i2.__digit(g2 - 1);
        const o2 = JSBI.__clz30(s2), l2 = 30 * g2 - o2, r2 = n2 + 1;
        if (l2 < r2)
          return JSBI.__absoluteLess(t2);
        if (l2 > r2)
          return JSBI.__absoluteGreater(t2);
        let a2 = 1048576 | 1048575 & JSBI.__kBitConversionInts[1], u2 = JSBI.__kBitConversionInts[0];
        const d2 = 20, h2 = 29 - o2;
        if (h2 !== (0 | (l2 - 1) % 30))
          throw new Error("implementation bug");
        let m2, b2 = 0;
        if (20 > h2) {
          const i3 = d2 - h2;
          b2 = i3 + 32, m2 = a2 >>> i3, a2 = a2 << 32 - i3 | u2 >>> i3, u2 <<= 32 - i3;
        } else if (20 === h2)
          b2 = 32, m2 = a2, a2 = u2, u2 = 0;
        else {
          const i3 = h2 - d2;
          b2 = 32 - i3, m2 = a2 << i3 | u2 >>> 32 - i3, a2 = u2 << i3, u2 = 0;
        }
        if (s2 >>>= 0, m2 >>>= 0, s2 > m2)
          return JSBI.__absoluteGreater(t2);
        if (s2 < m2)
          return JSBI.__absoluteLess(t2);
        for (let e3 = g2 - 2; 0 <= e3; e3--) {
          0 < b2 ? (b2 -= 30, m2 = a2 >>> 2, a2 = a2 << 30 | u2 >>> 2, u2 <<= 30) : m2 = 0;
          const _3 = i2.__unsignedDigit(e3);
          if (_3 > m2)
            return JSBI.__absoluteGreater(t2);
          if (_3 < m2)
            return JSBI.__absoluteLess(t2);
        }
        if (0 !== a2 || 0 !== u2) {
          if (0 === b2)
            throw new Error("implementation bug");
          return JSBI.__absoluteLess(t2);
        }
        return 0;
      }
      static __equalToNumber(i2, _2) {
        var t2 = Math.abs;
        return JSBI.__isOneDigitInt(_2) ? 0 === _2 ? 0 === i2.length : 1 === i2.length && i2.sign === 0 > _2 && i2.__unsignedDigit(0) === t2(_2) : 0 === JSBI.__compareToDouble(i2, _2);
      }
      static __comparisonResultToBool(i2, _2) {
        return 0 === _2 ? 0 > i2 : 1 === _2 ? 0 >= i2 : 2 === _2 ? 0 < i2 : 3 === _2 ? 0 <= i2 : void 0;
      }
      static __compare(i2, _2, t2) {
        if (i2 = JSBI.__toPrimitive(i2), _2 = JSBI.__toPrimitive(_2), "string" == typeof i2 && "string" == typeof _2)
          switch (t2) {
            case 0:
              return i2 < _2;
            case 1:
              return i2 <= _2;
            case 2:
              return i2 > _2;
            case 3:
              return i2 >= _2;
          }
        if (JSBI.__isBigInt(i2) && "string" == typeof _2)
          return _2 = JSBI.__fromString(_2), null !== _2 && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i2, _2), t2);
        if ("string" == typeof i2 && JSBI.__isBigInt(_2))
          return i2 = JSBI.__fromString(i2), null !== i2 && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i2, _2), t2);
        if (i2 = JSBI.__toNumeric(i2), _2 = JSBI.__toNumeric(_2), JSBI.__isBigInt(i2)) {
          if (JSBI.__isBigInt(_2))
            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i2, _2), t2);
          if ("number" != typeof _2)
            throw new Error("implementation bug");
          return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i2, _2), t2);
        }
        if ("number" != typeof i2)
          throw new Error("implementation bug");
        if (JSBI.__isBigInt(_2))
          return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_2, i2), 2 ^ t2);
        if ("number" != typeof _2)
          throw new Error("implementation bug");
        return 0 === t2 ? i2 < _2 : 1 === t2 ? i2 <= _2 : 2 === t2 ? i2 > _2 : 3 === t2 ? i2 >= _2 : void 0;
      }
      __clzmsd() {
        return JSBI.__clz30(this.__digit(this.length - 1));
      }
      static __absoluteAdd(_2, t2, e2) {
        if (_2.length < t2.length)
          return JSBI.__absoluteAdd(t2, _2, e2);
        if (0 === _2.length)
          return _2;
        if (0 === t2.length)
          return _2.sign === e2 ? _2 : JSBI.unaryMinus(_2);
        let n2 = _2.length;
        (0 === _2.__clzmsd() || t2.length === _2.length && 0 === t2.__clzmsd()) && n2++;
        const g2 = new JSBI(n2, e2);
        let s2 = 0, o2 = 0;
        for (; o2 < t2.length; o2++) {
          const i2 = _2.__digit(o2) + t2.__digit(o2) + s2;
          s2 = i2 >>> 30, g2.__setDigit(o2, 1073741823 & i2);
        }
        for (; o2 < _2.length; o2++) {
          const i2 = _2.__digit(o2) + s2;
          s2 = i2 >>> 30, g2.__setDigit(o2, 1073741823 & i2);
        }
        return o2 < g2.length && g2.__setDigit(o2, s2), g2.__trim();
      }
      static __absoluteSub(_2, t2, e2) {
        if (0 === _2.length)
          return _2;
        if (0 === t2.length)
          return _2.sign === e2 ? _2 : JSBI.unaryMinus(_2);
        const n2 = new JSBI(_2.length, e2);
        let g2 = 0, s2 = 0;
        for (; s2 < t2.length; s2++) {
          const i2 = _2.__digit(s2) - t2.__digit(s2) - g2;
          g2 = 1 & i2 >>> 30, n2.__setDigit(s2, 1073741823 & i2);
        }
        for (; s2 < _2.length; s2++) {
          const i2 = _2.__digit(s2) - g2;
          g2 = 1 & i2 >>> 30, n2.__setDigit(s2, 1073741823 & i2);
        }
        return n2.__trim();
      }
      static __absoluteAddOne(_2, i2, t2 = null) {
        const e2 = _2.length;
        null === t2 ? t2 = new JSBI(e2, i2) : t2.sign = i2;
        let n2 = 1;
        for (let g2 = 0; g2 < e2; g2++) {
          const i3 = _2.__digit(g2) + n2;
          n2 = i3 >>> 30, t2.__setDigit(g2, 1073741823 & i3);
        }
        return 0 != n2 && t2.__setDigitGrow(e2, 1), t2;
      }
      static __absoluteSubOne(_2, t2) {
        const e2 = _2.length;
        t2 = t2 || e2;
        const n2 = new JSBI(t2, false);
        let g2 = 1;
        for (let s2 = 0; s2 < e2; s2++) {
          const i2 = _2.__digit(s2) - g2;
          g2 = 1 & i2 >>> 30, n2.__setDigit(s2, 1073741823 & i2);
        }
        if (0 != g2)
          throw new Error("implementation bug");
        for (let g3 = e2; g3 < t2; g3++)
          n2.__setDigit(g3, 0);
        return n2;
      }
      static __absoluteAnd(_2, t2, e2 = null) {
        let n2 = _2.length, g2 = t2.length, s2 = g2;
        if (n2 < g2) {
          s2 = n2;
          const i2 = _2, e3 = n2;
          _2 = t2, n2 = g2, t2 = i2, g2 = e3;
        }
        let o2 = s2;
        null === e2 ? e2 = new JSBI(o2, false) : o2 = e2.length;
        let l2 = 0;
        for (; l2 < s2; l2++)
          e2.__setDigit(l2, _2.__digit(l2) & t2.__digit(l2));
        for (; l2 < o2; l2++)
          e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteAndNot(_2, t2, e2 = null) {
        const n2 = _2.length, g2 = t2.length;
        let s2 = g2;
        n2 < g2 && (s2 = n2);
        let o2 = n2;
        null === e2 ? e2 = new JSBI(o2, false) : o2 = e2.length;
        let l2 = 0;
        for (; l2 < s2; l2++)
          e2.__setDigit(l2, _2.__digit(l2) & ~t2.__digit(l2));
        for (; l2 < n2; l2++)
          e2.__setDigit(l2, _2.__digit(l2));
        for (; l2 < o2; l2++)
          e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteOr(_2, t2, e2 = null) {
        let n2 = _2.length, g2 = t2.length, s2 = g2;
        if (n2 < g2) {
          s2 = n2;
          const i2 = _2, e3 = n2;
          _2 = t2, n2 = g2, t2 = i2, g2 = e3;
        }
        let o2 = n2;
        null === e2 ? e2 = new JSBI(o2, false) : o2 = e2.length;
        let l2 = 0;
        for (; l2 < s2; l2++)
          e2.__setDigit(l2, _2.__digit(l2) | t2.__digit(l2));
        for (; l2 < n2; l2++)
          e2.__setDigit(l2, _2.__digit(l2));
        for (; l2 < o2; l2++)
          e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteXor(_2, t2, e2 = null) {
        let n2 = _2.length, g2 = t2.length, s2 = g2;
        if (n2 < g2) {
          s2 = n2;
          const i2 = _2, e3 = n2;
          _2 = t2, n2 = g2, t2 = i2, g2 = e3;
        }
        let o2 = n2;
        null === e2 ? e2 = new JSBI(o2, false) : o2 = e2.length;
        let l2 = 0;
        for (; l2 < s2; l2++)
          e2.__setDigit(l2, _2.__digit(l2) ^ t2.__digit(l2));
        for (; l2 < n2; l2++)
          e2.__setDigit(l2, _2.__digit(l2));
        for (; l2 < o2; l2++)
          e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteCompare(_2, t2) {
        const e2 = _2.length - t2.length;
        if (0 != e2)
          return e2;
        let n2 = _2.length - 1;
        for (; 0 <= n2 && _2.__digit(n2) === t2.__digit(n2); )
          n2--;
        return 0 > n2 ? 0 : _2.__unsignedDigit(n2) > t2.__unsignedDigit(n2) ? 1 : -1;
      }
      static __multiplyAccumulate(_2, t2, e2, n2) {
        if (0 === t2)
          return;
        const g2 = 32767 & t2, s2 = t2 >>> 15;
        let o2 = 0, l2 = 0;
        for (let r2, a2 = 0; a2 < _2.length; a2++, n2++) {
          r2 = e2.__digit(n2);
          const i2 = _2.__digit(a2), t3 = 32767 & i2, u2 = i2 >>> 15, d2 = JSBI.__imul(t3, g2), h2 = JSBI.__imul(t3, s2), m2 = JSBI.__imul(u2, g2), b2 = JSBI.__imul(u2, s2);
          r2 += l2 + d2 + o2, o2 = r2 >>> 30, r2 &= 1073741823, r2 += ((32767 & h2) << 15) + ((32767 & m2) << 15), o2 += r2 >>> 30, l2 = b2 + (h2 >>> 15) + (m2 >>> 15), e2.__setDigit(n2, 1073741823 & r2);
        }
        for (; 0 != o2 || 0 !== l2; n2++) {
          let i2 = e2.__digit(n2);
          i2 += o2 + l2, l2 = 0, o2 = i2 >>> 30, e2.__setDigit(n2, 1073741823 & i2);
        }
      }
      static __internalMultiplyAdd(_2, t2, e2, g2, s2) {
        let o2 = e2, l2 = 0;
        for (let n2 = 0; n2 < g2; n2++) {
          const i2 = _2.__digit(n2), e3 = JSBI.__imul(32767 & i2, t2), g3 = JSBI.__imul(i2 >>> 15, t2), a2 = e3 + ((32767 & g3) << 15) + l2 + o2;
          o2 = a2 >>> 30, l2 = g3 >>> 15, s2.__setDigit(n2, 1073741823 & a2);
        }
        if (s2.length > g2)
          for (s2.__setDigit(g2++, o2 + l2); g2 < s2.length; )
            s2.__setDigit(g2++, 0);
        else if (0 !== o2 + l2)
          throw new Error("implementation bug");
      }
      __inplaceMultiplyAdd(i2, _2, t2) {
        t2 > this.length && (t2 = this.length);
        const e2 = 32767 & i2, n2 = i2 >>> 15;
        let g2 = 0, s2 = _2;
        for (let o2 = 0; o2 < t2; o2++) {
          const i3 = this.__digit(o2), _3 = 32767 & i3, t3 = i3 >>> 15, l2 = JSBI.__imul(_3, e2), r2 = JSBI.__imul(_3, n2), a2 = JSBI.__imul(t3, e2), u2 = JSBI.__imul(t3, n2);
          let d2 = s2 + l2 + g2;
          g2 = d2 >>> 30, d2 &= 1073741823, d2 += ((32767 & r2) << 15) + ((32767 & a2) << 15), g2 += d2 >>> 30, s2 = u2 + (r2 >>> 15) + (a2 >>> 15), this.__setDigit(o2, 1073741823 & d2);
        }
        if (0 != g2 || 0 !== s2)
          throw new Error("implementation bug");
      }
      static __absoluteDivSmall(_2, t2, e2 = null) {
        null === e2 && (e2 = new JSBI(_2.length, false));
        let n2 = 0;
        for (let g2, s2 = 2 * _2.length - 1; 0 <= s2; s2 -= 2) {
          g2 = (n2 << 15 | _2.__halfDigit(s2)) >>> 0;
          const i2 = 0 | g2 / t2;
          n2 = 0 | g2 % t2, g2 = (n2 << 15 | _2.__halfDigit(s2 - 1)) >>> 0;
          const o2 = 0 | g2 / t2;
          n2 = 0 | g2 % t2, e2.__setDigit(s2 >>> 1, i2 << 15 | o2);
        }
        return e2;
      }
      static __absoluteModSmall(_2, t2) {
        let e2 = 0;
        for (let n2 = 2 * _2.length - 1; 0 <= n2; n2--) {
          const i2 = (e2 << 15 | _2.__halfDigit(n2)) >>> 0;
          e2 = 0 | i2 % t2;
        }
        return e2;
      }
      static __absoluteDivLarge(i2, _2, t2, e2) {
        const g2 = _2.__halfDigitLength(), n2 = _2.length, s2 = i2.__halfDigitLength() - g2;
        let o2 = null;
        t2 && (o2 = new JSBI(s2 + 2 >>> 1, false), o2.__initializeDigits());
        const l2 = new JSBI(g2 + 2 >>> 1, false);
        l2.__initializeDigits();
        const r2 = JSBI.__clz15(_2.__halfDigit(g2 - 1));
        0 < r2 && (_2 = JSBI.__specialLeftShift(_2, r2, 0));
        const a2 = JSBI.__specialLeftShift(i2, r2, 1), u2 = _2.__halfDigit(g2 - 1);
        let d2 = 0;
        for (let r3, h2 = s2; 0 <= h2; h2--) {
          r3 = 32767;
          const i3 = a2.__halfDigit(h2 + g2);
          if (i3 !== u2) {
            const t3 = (i3 << 15 | a2.__halfDigit(h2 + g2 - 1)) >>> 0;
            r3 = 0 | t3 / u2;
            let e4 = 0 | t3 % u2;
            const n3 = _2.__halfDigit(g2 - 2), s3 = a2.__halfDigit(h2 + g2 - 2);
            for (; JSBI.__imul(r3, n3) >>> 0 > (e4 << 16 | s3) >>> 0 && (r3--, e4 += u2, !(32767 < e4)); )
              ;
          }
          JSBI.__internalMultiplyAdd(_2, r3, 0, n2, l2);
          let e3 = a2.__inplaceSub(l2, h2, g2 + 1);
          0 !== e3 && (e3 = a2.__inplaceAdd(_2, h2, g2), a2.__setHalfDigit(h2 + g2, 32767 & a2.__halfDigit(h2 + g2) + e3), r3--), t2 && (1 & h2 ? d2 = r3 << 15 : o2.__setDigit(h2 >>> 1, d2 | r3));
        }
        if (e2)
          return a2.__inplaceRightShift(r2), t2 ? { quotient: o2, remainder: a2 } : a2;
        if (t2)
          return o2;
        throw new Error("unreachable");
      }
      static __clz15(i2) {
        return JSBI.__clz30(i2) - 15;
      }
      __inplaceAdd(_2, t2, e2) {
        let n2 = 0;
        for (let g2 = 0; g2 < e2; g2++) {
          const i2 = this.__halfDigit(t2 + g2) + _2.__halfDigit(g2) + n2;
          n2 = i2 >>> 15, this.__setHalfDigit(t2 + g2, 32767 & i2);
        }
        return n2;
      }
      __inplaceSub(_2, t2, e2) {
        let n2 = 0;
        if (1 & t2) {
          t2 >>= 1;
          let g2 = this.__digit(t2), s2 = 32767 & g2, o2 = 0;
          for (; o2 < e2 - 1 >>> 1; o2++) {
            const i3 = _2.__digit(o2), e3 = (g2 >>> 15) - (32767 & i3) - n2;
            n2 = 1 & e3 >>> 15, this.__setDigit(t2 + o2, (32767 & e3) << 15 | 32767 & s2), g2 = this.__digit(t2 + o2 + 1), s2 = (32767 & g2) - (i3 >>> 15) - n2, n2 = 1 & s2 >>> 15;
          }
          const i2 = _2.__digit(o2), l2 = (g2 >>> 15) - (32767 & i2) - n2;
          n2 = 1 & l2 >>> 15, this.__setDigit(t2 + o2, (32767 & l2) << 15 | 32767 & s2);
          if (t2 + o2 + 1 >= this.length)
            throw new RangeError("out of bounds");
          0 == (1 & e2) && (g2 = this.__digit(t2 + o2 + 1), s2 = (32767 & g2) - (i2 >>> 15) - n2, n2 = 1 & s2 >>> 15, this.__setDigit(t2 + _2.length, 1073709056 & g2 | 32767 & s2));
        } else {
          t2 >>= 1;
          let g2 = 0;
          for (; g2 < _2.length - 1; g2++) {
            const i3 = this.__digit(t2 + g2), e3 = _2.__digit(g2), s3 = (32767 & i3) - (32767 & e3) - n2;
            n2 = 1 & s3 >>> 15;
            const o3 = (i3 >>> 15) - (e3 >>> 15) - n2;
            n2 = 1 & o3 >>> 15, this.__setDigit(t2 + g2, (32767 & o3) << 15 | 32767 & s3);
          }
          const i2 = this.__digit(t2 + g2), s2 = _2.__digit(g2), o2 = (32767 & i2) - (32767 & s2) - n2;
          n2 = 1 & o2 >>> 15;
          let l2 = 0;
          0 == (1 & e2) && (l2 = (i2 >>> 15) - (s2 >>> 15) - n2, n2 = 1 & l2 >>> 15), this.__setDigit(t2 + g2, (32767 & l2) << 15 | 32767 & o2);
        }
        return n2;
      }
      __inplaceRightShift(_2) {
        if (0 === _2)
          return;
        let t2 = this.__digit(0) >>> _2;
        const e2 = this.length - 1;
        for (let n2 = 0; n2 < e2; n2++) {
          const i2 = this.__digit(n2 + 1);
          this.__setDigit(n2, 1073741823 & i2 << 30 - _2 | t2), t2 = i2 >>> _2;
        }
        this.__setDigit(e2, t2);
      }
      static __specialLeftShift(_2, t2, e2) {
        const g2 = _2.length, n2 = new JSBI(g2 + e2, false);
        if (0 === t2) {
          for (let t3 = 0; t3 < g2; t3++)
            n2.__setDigit(t3, _2.__digit(t3));
          return 0 < e2 && n2.__setDigit(g2, 0), n2;
        }
        let s2 = 0;
        for (let o2 = 0; o2 < g2; o2++) {
          const i2 = _2.__digit(o2);
          n2.__setDigit(o2, 1073741823 & i2 << t2 | s2), s2 = i2 >>> 30 - t2;
        }
        return 0 < e2 && n2.__setDigit(g2, s2), n2;
      }
      static __leftShiftByAbsolute(_2, i2) {
        const t2 = JSBI.__toShiftAmount(i2);
        if (0 > t2)
          throw new RangeError("BigInt too big");
        const e2 = 0 | t2 / 30, n2 = t2 % 30, g2 = _2.length, s2 = 0 !== n2 && 0 != _2.__digit(g2 - 1) >>> 30 - n2, o2 = g2 + e2 + (s2 ? 1 : 0), l2 = new JSBI(o2, _2.sign);
        if (0 === n2) {
          let t3 = 0;
          for (; t3 < e2; t3++)
            l2.__setDigit(t3, 0);
          for (; t3 < o2; t3++)
            l2.__setDigit(t3, _2.__digit(t3 - e2));
        } else {
          let t3 = 0;
          for (let _3 = 0; _3 < e2; _3++)
            l2.__setDigit(_3, 0);
          for (let s3 = 0; s3 < g2; s3++) {
            const i3 = _2.__digit(s3);
            l2.__setDigit(s3 + e2, 1073741823 & i3 << n2 | t3), t3 = i3 >>> 30 - n2;
          }
          if (s2)
            l2.__setDigit(g2 + e2, t3);
          else if (0 !== t3)
            throw new Error("implementation bug");
        }
        return l2.__trim();
      }
      static __rightShiftByAbsolute(_2, i2) {
        const t2 = _2.length, e2 = _2.sign, n2 = JSBI.__toShiftAmount(i2);
        if (0 > n2)
          return JSBI.__rightShiftByMaximum(e2);
        const g2 = 0 | n2 / 30, s2 = n2 % 30;
        let o2 = t2 - g2;
        if (0 >= o2)
          return JSBI.__rightShiftByMaximum(e2);
        let l2 = false;
        if (e2) {
          if (0 != (_2.__digit(g2) & (1 << s2) - 1))
            l2 = true;
          else
            for (let t3 = 0; t3 < g2; t3++)
              if (0 !== _2.__digit(t3)) {
                l2 = true;
                break;
              }
        }
        if (l2 && 0 === s2) {
          const i3 = _2.__digit(t2 - 1);
          0 == ~i3 && o2++;
        }
        let r2 = new JSBI(o2, e2);
        if (0 === s2) {
          r2.__setDigit(o2 - 1, 0);
          for (let e3 = g2; e3 < t2; e3++)
            r2.__setDigit(e3 - g2, _2.__digit(e3));
        } else {
          let e3 = _2.__digit(g2) >>> s2;
          const n3 = t2 - g2 - 1;
          for (let t3 = 0; t3 < n3; t3++) {
            const i3 = _2.__digit(t3 + g2 + 1);
            r2.__setDigit(t3, 1073741823 & i3 << 30 - s2 | e3), e3 = i3 >>> s2;
          }
          r2.__setDigit(n3, e3);
        }
        return l2 && (r2 = JSBI.__absoluteAddOne(r2, true, r2)), r2.__trim();
      }
      static __rightShiftByMaximum(i2) {
        return i2 ? JSBI.__oneDigit(1, true) : JSBI.__zero();
      }
      static __toShiftAmount(i2) {
        if (1 < i2.length)
          return -1;
        const _2 = i2.__unsignedDigit(0);
        return _2 > JSBI.__kMaxLengthBits ? -1 : _2;
      }
      static __toPrimitive(i2, _2 = "default") {
        if ("object" != typeof i2)
          return i2;
        if (i2.constructor === JSBI)
          return i2;
        if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
          const t3 = i2[Symbol.toPrimitive];
          if (t3) {
            const i3 = t3(_2);
            if ("object" != typeof i3)
              return i3;
            throw new TypeError("Cannot convert object to primitive value");
          }
        }
        const t2 = i2.valueOf;
        if (t2) {
          const _3 = t2.call(i2);
          if ("object" != typeof _3)
            return _3;
        }
        const e2 = i2.toString;
        if (e2) {
          const _3 = e2.call(i2);
          if ("object" != typeof _3)
            return _3;
        }
        throw new TypeError("Cannot convert object to primitive value");
      }
      static __toNumeric(i2) {
        return JSBI.__isBigInt(i2) ? i2 : +i2;
      }
      static __isBigInt(i2) {
        return "object" == typeof i2 && null !== i2 && i2.constructor === JSBI;
      }
      static __truncateToNBits(i2, _2) {
        const t2 = 0 | (i2 + 29) / 30, e2 = new JSBI(t2, _2.sign), n2 = t2 - 1;
        for (let t3 = 0; t3 < n2; t3++)
          e2.__setDigit(t3, _2.__digit(t3));
        let g2 = _2.__digit(n2);
        if (0 != i2 % 30) {
          const _3 = 32 - i2 % 30;
          g2 = g2 << _3 >>> _3;
        }
        return e2.__setDigit(n2, g2), e2.__trim();
      }
      static __truncateAndSubFromPowerOfTwo(_2, t2, e2) {
        var n2 = Math.min;
        const g2 = 0 | (_2 + 29) / 30, s2 = new JSBI(g2, e2);
        let o2 = 0;
        const l2 = g2 - 1;
        let a2 = 0;
        for (const i2 = n2(l2, t2.length); o2 < i2; o2++) {
          const i3 = 0 - t2.__digit(o2) - a2;
          a2 = 1 & i3 >>> 30, s2.__setDigit(o2, 1073741823 & i3);
        }
        for (; o2 < l2; o2++)
          s2.__setDigit(o2, 0 | 1073741823 & -a2);
        let u2 = l2 < t2.length ? t2.__digit(l2) : 0;
        const d2 = _2 % 30;
        let h2;
        if (0 == d2)
          h2 = 0 - u2 - a2, h2 &= 1073741823;
        else {
          const i2 = 32 - d2;
          u2 = u2 << i2 >>> i2;
          const _3 = 1 << 32 - i2;
          h2 = _3 - u2 - a2, h2 &= _3 - 1;
        }
        return s2.__setDigit(l2, h2), s2.__trim();
      }
      __digit(_2) {
        return this[_2];
      }
      __unsignedDigit(_2) {
        return this[_2] >>> 0;
      }
      __setDigit(_2, i2) {
        this[_2] = 0 | i2;
      }
      __setDigitGrow(_2, i2) {
        this[_2] = 0 | i2;
      }
      __halfDigitLength() {
        const i2 = this.length;
        return 32767 >= this.__unsignedDigit(i2 - 1) ? 2 * i2 - 1 : 2 * i2;
      }
      __halfDigit(_2) {
        return 32767 & this[_2 >>> 1] >>> 15 * (1 & _2);
      }
      __setHalfDigit(_2, i2) {
        const t2 = _2 >>> 1, e2 = this.__digit(t2), n2 = 1 & _2 ? 32767 & e2 | i2 << 15 : 1073709056 & e2 | 32767 & i2;
        this.__setDigit(t2, n2);
      }
      static __digitPow(i2, _2) {
        let t2 = 1;
        for (; 0 < _2; )
          1 & _2 && (t2 *= i2), _2 >>>= 1, i2 *= i2;
        return t2;
      }
      static __isOneDigitInt(i2) {
        return (1073741823 & i2) === i2;
      }
    };
    JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i2) {
      return Math.clz32(i2) - 2;
    } : function(i2) {
      return 0 === i2 ? 30 : 0 | 29 - (0 | Math.log(i2 >>> 0) / Math.LN2);
    }, JSBI.__imul = Math.imul || function(i2, _2) {
      return 0 | i2 * _2;
    }, module2.exports = JSBI;
  }
});

// ../../node_modules/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "../../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util2 = require_minimal2();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign3 = value < 0;
      if (sign3)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from7(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util2.isString(value)) {
        if (util2.Long)
          value = util2.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length5() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protobufjs/src/util/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util2 = exports2;
    util2.asPromise = require_aspromise();
    util2.base64 = require_base64();
    util2.EventEmitter = require_eventemitter();
    util2.float = require_float();
    util2.inquire = require_inquire();
    util2.utf8 = require_utf8();
    util2.pool = require_pool();
    util2.LongBits = require_longbits2();
    util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util2.LongBits.fromHash(hash);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src5, ifNotSet) {
      for (var keys = Object.keys(src5), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src5[keys[i2]];
      return dst;
    }
    util2.merge = merge;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name6) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name6;
      } });
      CustomError.prototype.toString = function toString4() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name6) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name6)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "../../node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util2 = require_minimal2();
    var BufferWriter;
    var LongBits = util2.LongBits;
    var base642 = util2.base64;
    var utf8 = util2.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer2) {
      this.head = writer2.head;
      this.tail = writer2.tail;
      this.len = writer2.len;
      this.next = writer2.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create5 = function create6() {
      return util2.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create5();
    Writer.alloc = function alloc3(size) {
      return new util2.Array(size);
    };
    if (util2.Array !== Array)
      Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util2.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util2.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf2[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util2.isString(value)) {
        var buf2 = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf2, 0);
        value = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create5();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "../../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util2 = require_minimal2();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util2._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf2[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util2.isString(value))
        value = util2._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util2.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util2.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "../../node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util2 = require_minimal2();
    var BufferReader;
    var LongBits = util2.LongBits;
    var utf8 = util2.utf8;
    function indexOutOfRange(reader2, writeLength) {
      return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create5 = function create6() {
      return util2.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create5();
    Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
    util2.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length5 = this.uint32(), start = this.pos, end = this.pos + length5;
      if (end > this.len)
        throw indexOutOfRange(this, length5);
      this.pos += length5;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length5) {
      if (typeof length5 === "number") {
        if (this.pos + length5 > this.len)
          throw indexOutOfRange(this, length5);
        this.pos += length5;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create5();
      BufferReader._configure();
      var fn = util2.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util2.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "../../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util2 = require_minimal2();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util2.Buffer)
        BufferReader.prototype._slice = util2.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util2 = require_minimal2();
    (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util2.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal2();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure2;
    function configure2() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure2();
  }
});

// ../../node_modules/protobufjs/minimal.js
var require_minimal3 = __commonJS({
  "../../node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/base-x.js
var require_base_x = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/base-x.js"(exports2, module2) {
    "use strict";
    function base6(ALPHABET, name6) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
        BASE_MAP[j2] = 255;
      }
      for (var i2 = 0; i2 < ALPHABET.length; i2++) {
        var x2 = ALPHABET.charAt(i2);
        var xc = x2.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x2 + " is ambiguous");
        }
        BASE_MAP[xc] = i2;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode17(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length5 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i3 = 0;
          for (var it1 = size - 1; (carry !== 0 || i3 < length5) && it1 !== -1; it1--, i3++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length5 = i3;
          pbegin++;
        }
        var it2 = size - length5;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length5 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i3 = 0;
          for (var it3 = size - 1; (carry !== 0 || i3 < length5) && it3 !== -1; it3--, i3++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length5 = i3;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length5;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j3 = zeroes;
        while (it4 !== size) {
          vch[j3++] = b256[it4++];
        }
        return vch;
      }
      function decode25(string2) {
        var buffer2 = decodeUnsafe(string2);
        if (buffer2) {
          return buffer2;
        }
        throw new Error(`Non-${name6} character`);
      }
      return {
        encode: encode17,
        decodeUnsafe,
        decode: decode25
      };
    }
    var src5 = base6;
    var _brrp__multiformats_scope_baseX5 = src5;
    module2.exports = _brrp__multiformats_scope_baseX5;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bytes.js
var require_bytes = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var empty5 = new Uint8Array(0);
    var toHex3 = (d2) => d2.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    var fromHex3 = (hex) => {
      const hexes3 = hex.match(/../g);
      return hexes3 ? new Uint8Array(hexes3.map((b2) => parseInt(b2, 16))) : empty5;
    };
    var equals10 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce5 = (o2) => {
      if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
        return o2;
      if (o2 instanceof ArrayBuffer)
        return new Uint8Array(o2);
      if (ArrayBuffer.isView(o2)) {
        return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var isBinary3 = (o2) => o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
    var fromString5 = (str) => new TextEncoder().encode(str);
    var toString4 = (b2) => new TextDecoder().decode(b2);
    exports2.coerce = coerce5;
    exports2.empty = empty5;
    exports2.equals = equals10;
    exports2.fromHex = fromHex3;
    exports2.fromString = fromString5;
    exports2.isBinary = isBinary3;
    exports2.toHex = toHex3;
    exports2.toString = toString4;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base.js
var require_base = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var baseX$1 = require_base_x();
    var bytes = require_bytes();
    var Encoder6 = class {
      constructor(name6, prefix, baseEncode) {
        this.name = name6;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder5 = class {
      constructor(name6, prefix, baseDecode) {
        this.name = name6;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or5(this, decoder);
      }
    };
    var ComposedDecoder5 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or5(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or5 = (left, right) => new ComposedDecoder5({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    var Codec5 = class {
      constructor(name6, prefix, baseEncode, baseDecode) {
        this.name = name6;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder6(name6, prefix, baseEncode);
        this.decoder = new Decoder5(name6, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from7 = ({ name: name6, prefix, encode: encode18, decode: decode26 }) => new Codec5(name6, prefix, encode18, decode26);
    var baseX5 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
      const { encode: encode18, decode: decode26 } = baseX$1(alphabet2, name6);
      return from7({
        prefix,
        name: name6,
        encode: encode18,
        decode: (text) => bytes.coerce(decode26(text))
      });
    };
    var decode25 = (string2, alphabet2, bitsPerChar, name6) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet2.length; ++i2) {
        codes[alphabet2[i2]] = i2;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string2[i2]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name6} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode17 = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer2 = buffer2 << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46485 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from7({
        prefix,
        name: name6,
        encode(input) {
          return encode17(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode25(input, alphabet2, bitsPerChar, name6);
        }
      });
    };
    exports2.Codec = Codec5;
    exports2.baseX = baseX5;
    exports2.from = from7;
    exports2.or = or5;
    exports2.rfc4648 = rfc46485;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/identity.js
var require_identity = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var bytes = require_bytes();
    var identity4 = base6.from({
      prefix: "\0",
      name: "identity",
      encode: (buf2) => bytes.toString(buf2),
      decode: (str) => bytes.fromString(str)
    });
    exports2.identity = identity4;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base2.js
var require_base2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base22 = base6.rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    exports2.base2 = base22;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base8.js
var require_base8 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base82 = base6.rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    exports2.base8 = base82;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base10.js
var require_base10 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base102 = base6.baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    exports2.base10 = base102;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base16.js
var require_base16 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base162 = base6.rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper2 = base6.rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    exports2.base16 = base162;
    exports2.base16upper = base16upper2;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base32.js
var require_base32 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base325 = base6.rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper5 = base6.rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad5 = base6.rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper5 = base6.rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex5 = base6.rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper5 = base6.rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad5 = base6.rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper5 = base6.rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z5 = base6.rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    exports2.base32 = base325;
    exports2.base32hex = base32hex5;
    exports2.base32hexpad = base32hexpad5;
    exports2.base32hexpadupper = base32hexpadupper5;
    exports2.base32hexupper = base32hexupper5;
    exports2.base32pad = base32pad5;
    exports2.base32padupper = base32padupper5;
    exports2.base32upper = base32upper5;
    exports2.base32z = base32z5;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base36.js
var require_base36 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base36.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base362 = base6.baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper2 = base6.baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    exports2.base36 = base362;
    exports2.base36upper = base36upper2;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base58.js
var require_base58 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base58.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base58btc5 = base6.baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr5 = base6.baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    exports2.base58btc = base58btc5;
    exports2.base58flickr = base58flickr5;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base64.js
var require_base642 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base642 = base6.rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad2 = base6.rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url2 = base6.rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad2 = base6.rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    exports2.base64 = base642;
    exports2.base64pad = base64pad2;
    exports2.base64url = base64url2;
    exports2.base64urlpad = base64urlpad2;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base256emoji.js
var require_base256emoji = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base256emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars2 = alphabet2.reduce((p2, c2, i2) => {
      p2[i2] = c2;
      return p2;
    }, []);
    var alphabetCharsToBytes2 = alphabet2.reduce((p2, c2, i2) => {
      p2[c2.codePointAt(0)] = i2;
      return p2;
    }, []);
    function encode17(data) {
      return data.reduce((p2, c2) => {
        p2 += alphabetBytesToChars2[c2];
        return p2;
      }, "");
    }
    function decode25(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes2[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji2 = base6.from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode17,
      decode: decode25
    });
    exports2.base256emoji = base256emoji2;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/varint.js
var require_varint = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/varint.js"(exports2, module2) {
    "use strict";
    var encode_15 = encode17;
    var MSB5 = 128;
    var REST5 = 127;
    var MSBALL5 = ~REST5;
    var INT5 = Math.pow(2, 31);
    function encode17(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT5) {
        out[offset++] = num & 255 | MSB5;
        num /= 128;
      }
      while (num & MSBALL5) {
        out[offset++] = num & 255 | MSB5;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode17.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode25 = read5;
    var MSB$15 = 128;
    var REST$15 = 127;
    function read5(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
      do {
        if (counter >= l2) {
          read5.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b2 = buf2[counter++];
        res += shift < 28 ? (b2 & REST$15) << shift : (b2 & REST$15) * Math.pow(2, shift);
        shift += 7;
      } while (b2 >= MSB$15);
      read5.bytes = counter - offset;
      return res;
    }
    var N15 = Math.pow(2, 7);
    var N25 = Math.pow(2, 14);
    var N35 = Math.pow(2, 21);
    var N45 = Math.pow(2, 28);
    var N55 = Math.pow(2, 35);
    var N65 = Math.pow(2, 42);
    var N75 = Math.pow(2, 49);
    var N85 = Math.pow(2, 56);
    var N95 = Math.pow(2, 63);
    var length5 = function(value) {
      return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
    };
    var varint6 = {
      encode: encode_15,
      decode: decode25,
      encodingLength: length5
    };
    var _brrp_varint5 = varint6;
    var varint$1 = _brrp_varint5;
    module2.exports = varint$1;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/varint.js
var require_varint2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/varint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint$1 = require_varint();
    var decode25 = (data, offset = 0) => {
      const code9 = varint$1.decode(data, offset);
      return [
        code9,
        varint$1.decode.bytes
      ];
    };
    var encodeTo5 = (int, target, offset = 0) => {
      varint$1.encode(int, target, offset);
      return target;
    };
    var encodingLength5 = (int) => {
      return varint$1.encodingLength(int);
    };
    exports2.decode = decode25;
    exports2.encodeTo = encodeTo5;
    exports2.encodingLength = encodingLength5;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/digest.js
var require_digest = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var varint6 = require_varint2();
    var create5 = (code9, digest3) => {
      const size = digest3.byteLength;
      const sizeOffset = varint6.encodingLength(code9);
      const digestOffset = sizeOffset + varint6.encodingLength(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      varint6.encodeTo(code9, bytes2, 0);
      varint6.encodeTo(size, bytes2, sizeOffset);
      bytes2.set(digest3, digestOffset);
      return new Digest5(code9, size, digest3, bytes2);
    };
    var decode25 = (multihash) => {
      const bytes$1 = bytes.coerce(multihash);
      const [code9, sizeOffset] = varint6.decode(bytes$1);
      const [size, digestOffset] = varint6.decode(bytes$1.subarray(sizeOffset));
      const digest3 = bytes$1.subarray(sizeOffset + digestOffset);
      if (digest3.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest5(code9, size, digest3, bytes$1);
    };
    var equals10 = (a2, b2) => {
      if (a2 === b2) {
        return true;
      } else {
        return a2.code === b2.code && a2.size === b2.size && bytes.equals(a2.bytes, b2.bytes);
      }
    };
    var Digest5 = class {
      constructor(code9, size, digest3, bytes2) {
        this.code = code9;
        this.size = size;
        this.digest = digest3;
        this.bytes = bytes2;
      }
    };
    exports2.Digest = Digest5;
    exports2.create = create5;
    exports2.decode = decode25;
    exports2.equals = equals10;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/hasher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var digest3 = require_digest();
    var from7 = ({ name: name6, code: code9, encode: encode17 }) => new Hasher3(name6, code9, encode17);
    var Hasher3 = class {
      constructor(name6, code9, encode17) {
        this.name = name6;
        this.code = code9;
        this.encode = encode17;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? digest3.create(this.code, result) : result.then((digest$1) => digest3.create(this.code, digest$1));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    exports2.Hasher = Hasher3;
    exports2.from = from7;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto6 = require("crypto");
    var hasher = require_hasher();
    var bytes = require_bytes();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
    }
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto6);
    var sha2562 = hasher.from({
      name: "sha2-256",
      code: 18,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha256").update(input).digest())
    });
    var sha5122 = hasher.from({
      name: "sha2-512",
      code: 19,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha512").update(input).digest())
    });
    exports2.sha256 = sha2562;
    exports2.sha512 = sha5122;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/identity.js
var require_identity2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var digest$1 = require_digest();
    var code9 = 0;
    var name6 = "identity";
    var encode17 = bytes.coerce;
    var digest3 = (input) => digest$1.create(code9, encode17(input));
    var identity4 = {
      code: code9,
      name: name6,
      encode: encode17,
      digest: digest3
    };
    exports2.identity = identity4;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/raw.js
var require_raw = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/raw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var name6 = "raw";
    var code9 = 85;
    var encode17 = (node) => bytes.coerce(node);
    var decode25 = (data) => bytes.coerce(data);
    exports2.code = code9;
    exports2.decode = decode25;
    exports2.encode = encode17;
    exports2.name = name6;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/json.js
var require_json = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var textEncoder8 = new TextEncoder();
    var textDecoder6 = new TextDecoder();
    var name6 = "json";
    var code9 = 512;
    var encode17 = (node) => textEncoder8.encode(JSON.stringify(node));
    var decode25 = (data) => JSON.parse(textDecoder6.decode(data));
    exports2.code = code9;
    exports2.decode = decode25;
    exports2.encode = encode17;
    exports2.name = name6;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/cid.js
var require_cid = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/cid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint6 = require_varint2();
    var digest3 = require_digest();
    var base58 = require_base58();
    var base325 = require_base32();
    var bytes = require_bytes();
    var CID5 = class {
      constructor(version5, code9, multihash, bytes2) {
        this.code = code9;
        this.version = version5;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden4,
          byteLength: hidden4,
          code: readonly5,
          version: readonly5,
          multihash: readonly5,
          bytes: readonly5,
          _baseCache: hidden4,
          asCID: hidden4
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code9, multihash } = this;
            if (code9 !== DAG_PB_CODE5) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE5) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID5.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code9, digest: digest$1 } = this.multihash;
            const multihash = digest3.create(code9, digest$1);
            return CID5.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && digest3.equals(this.multihash, other.multihash);
      }
      toString(base6) {
        const { bytes: bytes2, version: version5, _baseCache } = this;
        switch (version5) {
          case 0:
            return toStringV05(bytes2, _baseCache, base6 || base58.base58btc.encoder);
          default:
            return toStringV15(bytes2, _baseCache, base6 || base325.base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate4(/^0\.0/, IS_CID_DEPRECATION4);
        return !!(value && (value[cidSymbol5] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID5) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version5, code: code9, multihash, bytes: bytes2 } = value;
          return new CID5(version5, code9, multihash, bytes2 || encodeCID5(version5, code9, multihash.bytes));
        } else if (value != null && value[cidSymbol5] === true) {
          const { version: version5, multihash, code: code9 } = value;
          const digest$1 = digest3.decode(multihash);
          return CID5.create(version5, code9, digest$1);
        } else {
          return null;
        }
      }
      static create(version5, code9, digest4) {
        if (typeof code9 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version5) {
          case 0: {
            if (code9 !== DAG_PB_CODE5) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`);
            } else {
              return new CID5(version5, code9, digest4, digest4.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID5(version5, code9, digest4.bytes);
            return new CID5(version5, code9, digest4, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest4) {
        return CID5.create(0, DAG_PB_CODE5, digest4);
      }
      static createV1(code9, digest4) {
        return CID5.create(1, code9, digest4);
      }
      static decode(bytes2) {
        const [cid, remainder] = CID5.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes$1) {
        const specs = CID5.inspectBytes(bytes$1);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest$1 = new digest3.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID5.createV0(digest$1) : CID5.createV1(specs.codec, digest$1);
        return [
          cid,
          bytes$1.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i2, length5] = varint6.decode(initialBytes.subarray(offset));
          offset += length5;
          return i2;
        };
        let version5 = next();
        let codec = DAG_PB_CODE5;
        if (version5 === 18) {
          version5 = 0;
          offset = 0;
        } else if (version5 === 1) {
          codec = next();
        }
        if (version5 !== 0 && version5 !== 1) {
          throw new RangeError(`Invalid CID version ${version5}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version5,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base6) {
        const [prefix, bytes2] = parseCIDtoBytes5(source, base6);
        const cid = CID5.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    var parseCIDtoBytes5 = (source, base6) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base6 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder.decode(`${base58.base58btc.prefix}${source}`)
          ];
        }
        case base58.base58btc.prefix: {
          const decoder = base6 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base325.base32.prefix: {
          const decoder = base6 || base325.base32;
          return [
            base325.base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base6 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base6.decode(source)
          ];
        }
      }
    };
    var toStringV05 = (bytes2, cache2, base6) => {
      const { prefix } = base6;
      if (prefix !== base58.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
      }
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base6.encode(bytes2).slice(1);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var toStringV15 = (bytes2, cache2, base6) => {
      const { prefix } = base6;
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base6.encode(bytes2);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var DAG_PB_CODE5 = 112;
    var SHA_256_CODE5 = 18;
    var encodeCID5 = (version5, code9, multihash) => {
      const codeOffset = varint6.encodingLength(version5);
      const hashOffset = codeOffset + varint6.encodingLength(code9);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      varint6.encodeTo(version5, bytes2, 0);
      varint6.encodeTo(code9, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");
    var readonly5 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden4 = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version4 = "0.0.0-dev";
    var deprecate4 = (range, message2) => {
      if (range.test(version4)) {
        console.warn(message2);
      } else {
        throw new Error(message2);
      }
    };
    var IS_CID_DEPRECATION4 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    exports2.CID = CID5;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/index.js
var require_src = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = require_cid();
    var varint6 = require_varint2();
    var bytes = require_bytes();
    var hasher = require_hasher();
    var digest3 = require_digest();
    exports2.CID = cid.CID;
    exports2.varint = varint6;
    exports2.bytes = bytes;
    exports2.hasher = hasher;
    exports2.digest = digest3;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/basics.js
var require_basics = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/basics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var identity4 = require_identity();
    var base22 = require_base2();
    var base82 = require_base8();
    var base102 = require_base10();
    var base162 = require_base16();
    var base325 = require_base32();
    var base362 = require_base36();
    var base58 = require_base58();
    var base642 = require_base642();
    var base256emoji2 = require_base256emoji();
    var sha2 = require_sha2();
    var identity$1 = require_identity2();
    var raw = require_raw();
    var json = require_json();
    require_src();
    var cid = require_cid();
    var hasher = require_hasher();
    var digest3 = require_digest();
    var varint6 = require_varint2();
    var bytes = require_bytes();
    var bases2 = {
      ...identity4,
      ...base22,
      ...base82,
      ...base102,
      ...base162,
      ...base325,
      ...base362,
      ...base58,
      ...base642,
      ...base256emoji2
    };
    var hashes2 = {
      ...sha2,
      ...identity$1
    };
    var codecs2 = {
      raw,
      json
    };
    exports2.CID = cid.CID;
    exports2.hasher = hasher;
    exports2.digest = digest3;
    exports2.varint = varint6;
    exports2.bytes = bytes;
    exports2.bases = bases2;
    exports2.codecs = codecs2;
    exports2.hashes = hashes2;
  }
});

// ../../node_modules/uint8arrays/cjs/src/util/as-uint8array.js
var require_as_uint8array = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/util/as-uint8array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function asUint8Array3(buf2) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      }
      return buf2;
    }
    exports2.asUint8Array = asUint8Array3;
  }
});

// ../../node_modules/uint8arrays/cjs/src/alloc.js
var require_alloc = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/alloc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var asUint8array = require_as_uint8array();
    function alloc3(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.alloc(size));
      }
      return new Uint8Array(size);
    }
    function allocUnsafe3(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size));
      }
      return new Uint8Array(size);
    }
    exports2.alloc = alloc3;
    exports2.allocUnsafe = allocUnsafe3;
  }
});

// ../../node_modules/uint8arrays/cjs/src/util/bases.js
var require_bases = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/util/bases.js"(exports2, module2) {
    "use strict";
    var basics = require_basics();
    var alloc3 = require_alloc();
    function createCodec3(name6, prefix, encode17, decode25) {
      return {
        name: name6,
        prefix,
        encoder: {
          name: name6,
          prefix,
          encode: encode17
        },
        decoder: { decode: decode25 }
      };
    }
    var string2 = createCodec3("utf8", "u", (buf2) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf2);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii2 = createCodec3("ascii", "a", (buf2) => {
      let string3 = "a";
      for (let i2 = 0; i2 < buf2.length; i2++) {
        string3 += String.fromCharCode(buf2[i2]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf2 = alloc3.allocUnsafe(str.length);
      for (let i2 = 0; i2 < str.length; i2++) {
        buf2[i2] = str.charCodeAt(i2);
      }
      return buf2;
    });
    var BASES2 = {
      utf8: string2,
      "utf-8": string2,
      hex: basics.bases.base16,
      latin1: ascii2,
      ascii: ascii2,
      binary: ascii2,
      ...basics.bases
    };
    module2.exports = BASES2;
  }
});

// ../../node_modules/uint8arrays/cjs/src/from-string.js
var require_from_string = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/from-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bases2 = require_bases();
    var asUint8array = require_as_uint8array();
    function fromString5(string2, encoding = "utf8") {
      const base6 = bases2[encoding];
      if (!base6) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
      }
      return base6.decoder.decode(`${base6.prefix}${string2}`);
    }
    exports2.fromString = fromString5;
  }
});

// ../../node_modules/hamt-sharding/src/bucket.js
var require_bucket = __commonJS({
  "../../node_modules/hamt-sharding/src/bucket.js"(exports2, module2) {
    "use strict";
    var SparseArray2 = require_sparse_array();
    var { fromString: uint8ArrayFromString } = require_from_string();
    var Bucket3 = class {
      /**
       * @param {BucketOptions} options
       * @param {Bucket<T>} [parent]
       * @param {number} [posAtParent=0]
       */
      constructor(options, parent, posAtParent = 0) {
        this._options = options;
        this._popCount = 0;
        this._parent = parent;
        this._posAtParent = posAtParent;
        this._children = new SparseArray2();
        this.key = null;
      }
      /**
       * @param {string} key
       * @param {T} value
       */
      async put(key, value) {
        const place = await this._findNewBucketAndPos(key);
        await place.bucket._putAt(place, key, value);
      }
      /**
       * @param {string} key
       */
      async get(key) {
        const child = await this._findChild(key);
        if (child) {
          return child.value;
        }
      }
      /**
       * @param {string} key
       */
      async del(key) {
        const place = await this._findPlace(key);
        const child = place.bucket._at(place.pos);
        if (child && child.key === key) {
          place.bucket._delAt(place.pos);
        }
      }
      /**
       * @returns {number}
       */
      leafCount() {
        const children = this._children.compactArray();
        return children.reduce((acc, child) => {
          if (child instanceof Bucket3) {
            return acc + child.leafCount();
          }
          return acc + 1;
        }, 0);
      }
      childrenCount() {
        return this._children.length;
      }
      onlyChild() {
        return this._children.get(0);
      }
      /**
       * @returns {Iterable<BucketChild<T>>}
       */
      *eachLeafSeries() {
        const children = this._children.compactArray();
        for (const child of children) {
          if (child instanceof Bucket3) {
            yield* child.eachLeafSeries();
          } else {
            yield child;
          }
        }
        return [];
      }
      /**
       * @param {(value: BucketChild<T>, index: number) => T} map
       * @param {(reduced: any) => any} reduce
       */
      serialize(map, reduce2) {
        const acc = [];
        return reduce2(this._children.reduce((acc2, child, index) => {
          if (child) {
            if (child instanceof Bucket3) {
              acc2.push(child.serialize(map, reduce2));
            } else {
              acc2.push(map(child, index));
            }
          }
          return acc2;
        }, acc));
      }
      /**
       * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
       * @param {(reduced: any) => Promise<any>} asyncReduce
       */
      asyncTransform(asyncMap, asyncReduce) {
        return asyncTransformBucket2(this, asyncMap, asyncReduce);
      }
      toJSON() {
        return this.serialize(mapNode2, reduceNodes2);
      }
      prettyPrint() {
        return JSON.stringify(this.toJSON(), null, "  ");
      }
      tableSize() {
        return Math.pow(2, this._options.bits);
      }
      /**
       * @param {string} key
       * @returns {Promise<BucketChild<T> | undefined>}
       */
      async _findChild(key) {
        const result = await this._findPlace(key);
        const child = result.bucket._at(result.pos);
        if (child instanceof Bucket3) {
          return void 0;
        }
        if (child && child.key === key) {
          return child;
        }
      }
      /**
       * @param {string | InfiniteHash} key
       * @returns {Promise<BucketPosition<T>>}
       */
      async _findPlace(key) {
        const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
        const index = await hashValue.take(this._options.bits);
        const child = this._children.get(index);
        if (child instanceof Bucket3) {
          return child._findPlace(hashValue);
        }
        return {
          bucket: this,
          pos: index,
          hash: hashValue,
          existingChild: child
        };
      }
      /**
       * @param {string | InfiniteHash} key
       * @returns {Promise<BucketPosition<T>>}
       */
      async _findNewBucketAndPos(key) {
        const place = await this._findPlace(key);
        if (place.existingChild && place.existingChild.key !== key) {
          const bucket = new Bucket3(this._options, place.bucket, place.pos);
          place.bucket._putObjectAt(place.pos, bucket);
          const newPlace = await bucket._findPlace(place.existingChild.hash);
          newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
          return bucket._findNewBucketAndPos(place.hash);
        }
        return place;
      }
      /**
       * @param {BucketPosition<T>} place
       * @param {string} key
       * @param {T} value
       */
      _putAt(place, key, value) {
        this._putObjectAt(place.pos, {
          key,
          value,
          hash: place.hash
        });
      }
      /**
       * @param {number} pos
       * @param {Bucket<T> | BucketChild<T>} object
       */
      _putObjectAt(pos, object) {
        if (!this._children.get(pos)) {
          this._popCount++;
        }
        this._children.set(pos, object);
      }
      /**
       * @param {number} pos
       */
      _delAt(pos) {
        if (pos === -1) {
          throw new Error("Invalid position");
        }
        if (this._children.get(pos)) {
          this._popCount--;
        }
        this._children.unset(pos);
        this._level();
      }
      _level() {
        if (this._parent && this._popCount <= 1) {
          if (this._popCount === 1) {
            const onlyChild = this._children.find(exists2);
            if (onlyChild && !(onlyChild instanceof Bucket3)) {
              const hash = onlyChild.hash;
              hash.untake(this._options.bits);
              const place = {
                pos: this._posAtParent,
                hash,
                bucket: this._parent
              };
              this._parent._putAt(place, onlyChild.key, onlyChild.value);
            }
          } else {
            this._parent._delAt(this._posAtParent);
          }
        }
      }
      /**
       * @param {number} index
       * @returns {BucketChild<T> | Bucket<T> | undefined}
       */
      _at(index) {
        return this._children.get(index);
      }
    };
    function exists2(o2) {
      return Boolean(o2);
    }
    function mapNode2(node, index) {
      return node.key;
    }
    function reduceNodes2(nodes) {
      return nodes;
    }
    async function asyncTransformBucket2(bucket, asyncMap, asyncReduce) {
      const output = [];
      for (const child of bucket._children.compactArray()) {
        if (child instanceof Bucket3) {
          await asyncTransformBucket2(child, asyncMap, asyncReduce);
        } else {
          const mappedChildren = await asyncMap(child);
          output.push({
            bitField: bucket._children.bitField(),
            children: mappedChildren
          });
        }
      }
      return asyncReduce(output);
    }
    module2.exports = Bucket3;
  }
});

// ../../node_modules/hamt-sharding/src/consumable-buffer.js
var require_consumable_buffer = __commonJS({
  "../../node_modules/hamt-sharding/src/consumable-buffer.js"(exports2, module2) {
    "use strict";
    var START_MASKS2 = [
      255,
      254,
      252,
      248,
      240,
      224,
      192,
      128
    ];
    var STOP_MASKS2 = [
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255
    ];
    module2.exports = class ConsumableBuffer {
      /**
       * @param {Uint8Array} value
       */
      constructor(value) {
        this._value = value;
        this._currentBytePos = value.length - 1;
        this._currentBitPos = 7;
      }
      availableBits() {
        return this._currentBitPos + 1 + this._currentBytePos * 8;
      }
      totalBits() {
        return this._value.length * 8;
      }
      /**
       * @param {number} bits
       */
      take(bits) {
        let pendingBits = bits;
        let result = 0;
        while (pendingBits && this._haveBits()) {
          const byte = this._value[this._currentBytePos];
          const availableBits = this._currentBitPos + 1;
          const taking = Math.min(availableBits, pendingBits);
          const value = byteBitsToInt2(byte, availableBits - taking, taking);
          result = (result << taking) + value;
          pendingBits -= taking;
          this._currentBitPos -= taking;
          if (this._currentBitPos < 0) {
            this._currentBitPos = 7;
            this._currentBytePos--;
          }
        }
        return result;
      }
      /**
       * @param {number} bits
       */
      untake(bits) {
        this._currentBitPos += bits;
        while (this._currentBitPos > 7) {
          this._currentBitPos -= 8;
          this._currentBytePos += 1;
        }
      }
      _haveBits() {
        return this._currentBytePos >= 0;
      }
    };
    function byteBitsToInt2(byte, start, length5) {
      const mask = maskFor2(start, length5);
      return (byte & mask) >>> start;
    }
    function maskFor2(start, length5) {
      return START_MASKS2[start] & STOP_MASKS2[Math.min(length5 + start - 1, 7)];
    }
  }
});

// ../../node_modules/uint8arrays/cjs/src/concat.js
var require_concat = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alloc3 = require_alloc();
    var asUint8array = require_as_uint8array();
    function concat4(arrays, length5) {
      if (!length5) {
        length5 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc3.allocUnsafe(length5);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return asUint8array.asUint8Array(output);
    }
    exports2.concat = concat4;
  }
});

// ../../node_modules/hamt-sharding/src/consumable-hash.js
var require_consumable_hash = __commonJS({
  "../../node_modules/hamt-sharding/src/consumable-hash.js"(exports2, module2) {
    "use strict";
    var ConsumableBuffer2 = require_consumable_buffer();
    var { concat: uint8ArrayConcat } = require_concat();
    function wrapHash2(hashFn2) {
      function hashing(value) {
        if (value instanceof InfiniteHash2) {
          return value;
        } else {
          return new InfiniteHash2(value, hashFn2);
        }
      }
      return hashing;
    }
    var InfiniteHash2 = class {
      /**
       *
       * @param {Uint8Array} value
       * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
       */
      constructor(value, hashFn2) {
        if (!(value instanceof Uint8Array)) {
          throw new Error("can only hash Uint8Arrays");
        }
        this._value = value;
        this._hashFn = hashFn2;
        this._depth = -1;
        this._availableBits = 0;
        this._currentBufferIndex = 0;
        this._buffers = [];
      }
      /**
       * @param {number} bits
       */
      async take(bits) {
        let pendingBits = bits;
        while (this._availableBits < pendingBits) {
          await this._produceMoreBits();
        }
        let result = 0;
        while (pendingBits > 0) {
          const hash = this._buffers[this._currentBufferIndex];
          const available = Math.min(hash.availableBits(), pendingBits);
          const took = hash.take(available);
          result = (result << available) + took;
          pendingBits -= available;
          this._availableBits -= available;
          if (hash.availableBits() === 0) {
            this._currentBufferIndex++;
          }
        }
        return result;
      }
      /**
       * @param {number} bits
       */
      untake(bits) {
        let pendingBits = bits;
        while (pendingBits > 0) {
          const hash = this._buffers[this._currentBufferIndex];
          const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
          hash.untake(availableForUntake);
          pendingBits -= availableForUntake;
          this._availableBits += availableForUntake;
          if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
            this._depth--;
            this._currentBufferIndex--;
          }
        }
      }
      async _produceMoreBits() {
        this._depth++;
        const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
        const hashValue = await this._hashFn(value);
        const buffer2 = new ConsumableBuffer2(hashValue);
        this._buffers.push(buffer2);
        this._availableBits += buffer2.availableBits();
      }
    };
    module2.exports = wrapHash2;
    module2.exports.InfiniteHash = InfiniteHash2;
  }
});

// ../../node_modules/hamt-sharding/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/hamt-sharding/src/index.js"(exports2, module2) {
    "use strict";
    var Bucket3 = require_bucket();
    var wrapHash2 = require_consumable_hash();
    function createHAMT3(options) {
      if (!options || !options.hashFn) {
        throw new Error("please define an options.hashFn");
      }
      const bucketOptions = {
        bits: options.bits || 8,
        hash: wrapHash2(options.hashFn)
      };
      return new Bucket3(bucketOptions);
    }
    module2.exports = {
      createHAMT: createHAMT3,
      Bucket: Bucket3
    };
  }
});

// ../../node_modules/it-last/index.js
var require_it_last = __commonJS({
  "../../node_modules/it-last/index.js"(exports2, module2) {
    "use strict";
    var last2 = async (source) => {
      let res;
      for await (const entry of source) {
        res = entry;
      }
      return res;
    };
    module2.exports = last2;
  }
});

// ../../node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "../../node_modules/readable-stream/lib/ours/primordials.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name6, prop) {
        return Object.defineProperty(self2, name6, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name6) {
        return Object.getOwnPropertyDescriptor(self2, name6);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(self2, buf2, len) {
        return self2.set(buf2, len);
      },
      Uint8Array
    };
  }
});

// ../../node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "../../node_modules/readable-stream/lib/ours/util.js"(exports2, module2) {
    "use strict";
    var bufferModule = require("buffer");
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob !== "undefined" ? function isBlob2(b2) {
      return b2 instanceof Blob;
    } : function isBlob2(b2) {
      return false;
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message2 = "";
        for (let i2 = 0; i2 < errors.length; i2++) {
          message2 += `    ${errors[i2].stack}
`;
        }
        super(message2);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve5;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve5 = res;
          reject = rej;
        });
        return {
          promise,
          resolve: resolve5,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve5, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve5(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format3, ...args) {
        return format3.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// ../../node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../../node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i2 = 0; i2 < keys.length; ++i2) {
        const key = keys[i2];
        if (!(key in BaseEvent.prototype)) {
          const descriptor2 = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor2.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x2) {
      return x2 !== null && typeof x2 === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i2 = 0; i2 < eventNames.length; ++i2) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i2]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types3 = new Array(arguments.length);
        for (let i2 = 0; i2 < arguments.length; ++i2) {
          types3[i2] = arguments[i2];
        }
        return defineCustomEventTarget(types3);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../../node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../../node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal2 = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal2;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports["default"] = AbortController2;
    module2.exports.AbortSignal = AbortSignal2;
  }
});

// ../../node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "../../node_modules/readable-stream/lib/ours/errors.js"(exports2, module2) {
    "use strict";
    var { format: format3, inspect, AggregateError: CustomAggregateError } = require_util();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message2) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message2);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format3(msg, ...args);
    }
    function E2(code9, message2, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code9, message2, args));
        }
        toString() {
          return `${this.name} [${code9}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code9}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code9;
      NodeError.prototype[kIsNodeError] = true;
      codes[code9] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden4 = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden4
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message2 = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message2, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E2("ERR_ASSERTION", "%s", Error);
    E2(
      "ERR_INVALID_ARG_TYPE",
      (name6, expected, actual) => {
        assert(typeof name6 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name6.endsWith(" argument")) {
          msg += `${name6} `;
        } else {
          msg += `"${name6}" ${name6.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types3 = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types3.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types3.indexOf("object");
          if (pos !== -1) {
            types3.splice(types3, pos, 1);
            instances.push("Object");
          }
        }
        if (types3.length > 0) {
          switch (types3.length) {
            case 1:
              msg += `of type ${types3[0]}`;
              break;
            case 2:
              msg += `one of type ${types3[0]} or ${types3[1]}`;
              break;
            default: {
              const last2 = types3.pop();
              msg += `one of type ${types3.join(", ")}, or ${last2}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last2 = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last2}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last2 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last2}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E2(
      "ERR_INVALID_ARG_VALUE",
      (name6, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name6.includes(".") ? "property" : "argument";
        return `The ${type} '${name6}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E2(
      "ERR_INVALID_RETURN_VALUE",
      (input, name6, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name6}" function but got ${type}.`;
      },
      TypeError
    );
    E2(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a2) => `"${a2}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last2 = args.pop();
              msg += `The ${args.join(", ")}, and ${last2} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "../../node_modules/readable-stream/lib/internal/validators.js"(exports2, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name6, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name6, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name6);
      return value;
    }
    var validateInteger = hideStackFrames((value, name6, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name6, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name6, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name6, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name6, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name6, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name6, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name6, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name6, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name6, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name6, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name6, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name6) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name6, "string", value);
    }
    function validateNumber(value, name6, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name6, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name6,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name6, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String2(v2)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name6, value, reason);
      }
    });
    function validateBoolean(value, name6) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name6, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name6, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name6, "Object", value);
      }
    });
    var validateArray = hideStackFrames((value, name6, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name6, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name6, value, reason);
      }
    });
    function validateSignalName(signal, name6 = "signal") {
      validateString(signal, name6);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer2, name6 = "buffer") => {
      if (!isArrayBufferView(buffer2)) {
        throw new ERR_INVALID_ARG_TYPE(name6, ["Buffer", "TypedArray", "DataView"], buffer2);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length5 = data.length;
      if (normalizedEncoding === "hex" && length5 % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length5}`);
      }
    }
    function validatePort(port, name6 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name6, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name6) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name6, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name6) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name6, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name6) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name6, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name6) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name6, "undefined", value);
    });
    function validateUnion(value, name6, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name6, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateBoolean,
      validateBuffer,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal
    };
  }
});

// ../../node_modules/process/index.js
var require_process = __commonJS({
  "../../node_modules/process/index.js"(exports2, module2) {
    module2.exports = global.process;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/utils.js"(exports2, module2) {
    "use strict";
    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var kDestroyed = Symbol2("kDestroyed");
    var kIsErrored = Symbol2("kIsErrored");
    var kIsReadable = Symbol2("kIsReadable");
    var kIsDisturbed = Symbol2("kIsDisturbed");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isIterable2(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      kDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      isClosed,
      isDestroyed,
      isDuplexNodeStream,
      isFinished,
      isIterable: isIterable2,
      isReadableNodeStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWritable,
      isWritableNodeStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    var process2 = require_process();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject } = require_validators();
    var { Promise: Promise2 } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose
    } = require_utils();
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "Stream", stream);
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclose);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclose);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclose);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclose);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      return cleanup;
    }
    function finished(stream, opts) {
      return new Promise2((resolve5, reject) => {
        eos(stream, opts, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve5();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/operators.js"(exports2, module2) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var {
      codes: { ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var { finished } = require_end_of_stream();
    var {
      ArrayPrototypePush,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      validateInteger(concurrency, "concurrency", 1);
      return async function* map2() {
        var _options$signal, _options$signal2;
        const ac = new AbortController2();
        const stream = this;
        const queue = [];
        const signal = ac.signal;
        const signalOpt = {
          signal
        };
        const abort = () => ac.abort();
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
          abort();
        }
        options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort);
        let next;
        let resume;
        let done = false;
        function onDone() {
          done = true;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              var _val;
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (val === kEmpty) {
                continue;
              }
              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                val.catch(onDone);
              }
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && queue.length && queue.length >= concurrency) {
                await new Promise2((resolve5) => {
                  resume = resolve5;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, void 0, onDone);
            queue.push(val);
          } finally {
            var _options$signal3;
            done = true;
            if (next) {
              next();
              next = null;
            }
            options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort);
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              if (resume) {
                resume();
                resume = null;
              }
            }
            await new Promise2((resolve5) => {
              next = resolve5;
            });
          }
        } finally {
          ac.abort();
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal4;
          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter2.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter2.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter2(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce2(reducer, initialValue, options) {
      var _options$signal5;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal6;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal9;
          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take2(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take3() {
        var _options$signal10;
        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal11;
          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          } else {
            return;
          }
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs,
      drop,
      filter: filter2,
      flatMap,
      map,
      take: take2
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce: reduce2,
      toArray,
      some,
      find
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var process2 = require_process();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w2, r2) {
      if (err) {
        err.stack;
        if (w2 && !w2.errored) {
          w2.errored = err;
        }
        if (r2 && !r2.errored) {
          r2.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r2 = this._readableState;
      const w2 = this._writableState;
      const s2 = w2 || r2;
      if (w2 && w2.destroyed || r2 && r2.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w2, r2);
      if (w2) {
        w2.destroyed = true;
      }
      if (r2) {
        r2.destroyed = true;
      }
      if (!s2.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r2 = self2._readableState;
        const w2 = self2._writableState;
        checkError(err2, w2, r2);
        if (w2) {
          w2.closed = true;
        }
        if (r2) {
          r2.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r2 = self2._readableState;
      const w2 = self2._writableState;
      if (w2) {
        w2.closeEmitted = true;
      }
      if (r2) {
        r2.closeEmitted = true;
      }
      if (w2 && w2.emitClose || r2 && r2.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r2 = self2._readableState;
      const w2 = self2._writableState;
      if (w2 && w2.errorEmitted || r2 && r2.errorEmitted) {
        return;
      }
      if (w2) {
        w2.errorEmitted = true;
      }
      if (r2) {
        r2.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r2 = this._readableState;
      const w2 = this._writableState;
      if (r2) {
        r2.constructed = true;
        r2.closed = false;
        r2.closeEmitted = false;
        r2.destroyed = false;
        r2.errored = null;
        r2.errorEmitted = false;
        r2.reading = false;
        r2.ended = r2.readable === false;
        r2.endEmitted = r2.readable === false;
      }
      if (w2) {
        w2.constructed = true;
        w2.destroyed = false;
        w2.closed = false;
        w2.closeEmitted = false;
        w2.errored = null;
        w2.errorEmitted = false;
        w2.finalCalled = false;
        w2.prefinished = false;
        w2.ended = w2.writable === false;
        w2.ending = w2.writable === false;
        w2.finished = w2.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r2 = stream._readableState;
      const w2 = stream._writableState;
      if (w2 && w2.destroyed || r2 && r2.destroyed) {
        return this;
      }
      if (r2 && r2.autoDestroy || w2 && w2.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w2 && !w2.errored) {
          w2.errored = err;
        }
        if (r2 && !r2.errored) {
          r2.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r2 = stream._readableState;
      const w2 = stream._writableState;
      if (r2) {
        r2.constructed = false;
      }
      if (w2) {
        w2.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r2 = stream._readableState;
        const w2 = stream._writableState;
        const s2 = w2 || r2;
        if (r2) {
          r2.constructed = true;
        }
        if (w2) {
          w2.constructed = true;
        }
        if (s2.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct(onConstruct);
      } catch (err) {
        onConstruct(err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return stream && stream.setHeader && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/legacy.js"(exports2, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require("events");
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports2, module2) {
    "use strict";
    var { AbortError, codes } = require_errors();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var validateAbortSignal = (signal, name6) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name6, "AbortSignal", signal);
      }
    };
    function isNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function");
    }
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, () => signal.removeEventListener("abort", onAbort));
      }
      return stream;
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { inspect } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v2) {
        const entry = {
          data: v2,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v2) {
        const entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s2) {
        if (this.length === 0)
          return "";
        let p2 = this.head;
        let ret = "" + p2.data;
        while ((p2 = p2.next) !== null)
          ret += s2 + p2.data;
        return ret;
      }
      concat(n2) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n2 >>> 0);
        let p2 = this.head;
        let i2 = 0;
        while (p2) {
          TypedArrayPrototypeSet(ret, p2.data, i2);
          i2 += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n2, hasStrings) {
        const data = this.head.data;
        if (n2 < data.length) {
          const slice2 = data.slice(0, n2);
          this.head.data = data.slice(n2);
          return slice2;
        }
        if (n2 === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n2) : this._getBuffer(n2);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p2 = this.head; p2; p2 = p2.next) {
          yield p2.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n2) {
        let ret = "";
        let p2 = this.head;
        let c2 = 0;
        do {
          const str = p2.data;
          if (n2 > str.length) {
            ret += str;
            n2 -= str.length;
          } else {
            if (n2 === str.length) {
              ret += str;
              ++c2;
              if (p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n2);
              this.head = p2;
              p2.data = StringPrototypeSlice(str, n2);
            }
            break;
          }
          ++c2;
        } while ((p2 = p2.next) !== null);
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n2) {
        const ret = Buffer2.allocUnsafe(n2);
        const retLen = n2;
        let p2 = this.head;
        let c2 = 0;
        do {
          const buf2 = p2.data;
          if (n2 > buf2.length) {
            TypedArrayPrototypeSet(ret, buf2, retLen - n2);
            n2 -= buf2.length;
          } else {
            if (n2 === buf2.length) {
              TypedArrayPrototypeSet(ret, buf2, retLen - n2);
              ++c2;
              if (p2.next)
                this.head = p2.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf2.buffer, buf2.byteOffset, n2), retLen - n2);
              this.head = p2;
              p2.data = buf2.slice(n2);
            }
            break;
          }
          ++c2;
        } while ((p2 = p2.next) !== null);
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? 16 : 16 * 1024;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name6 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name6, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    var process2 = require_process();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require("buffer");
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from7(Readable4, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable4({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable4({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e2) => process2.nextTick(cb, e2 || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from7;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/readable.js"(exports2, module2) {
    var process2 = require_process();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable4;
    Readable4.ReadableState = ReadableState;
    var { EventEmitter: EE } = require("events");
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require("buffer");
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      }
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require("string_decoder");
    var from7 = require_from();
    ObjectSetPrototypeOf(Readable4.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable4, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[kPaused] = null;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable4(options) {
      if (!(this instanceof Readable4))
        return new Readable4(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable4.prototype.destroy = destroyImpl.destroy;
    Readable4.prototype._undestroy = destroyImpl.undestroy;
    Readable4.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable4.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable4.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable4.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable4.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable4.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer2 = this._readableState.buffer;
      let content = "";
      for (const data of buffer2) {
        content += decoder.write(data);
      }
      buffer2.clear();
      if (content !== "")
        buffer2.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n2) {
      if (n2 > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n2);
      } else {
        n2--;
        n2 |= n2 >>> 1;
        n2 |= n2 >>> 2;
        n2 |= n2 >>> 4;
        n2 |= n2 >>> 8;
        n2 |= n2 >>> 16;
        n2++;
      }
      return n2;
    }
    function howMuchToRead(n2, state) {
      if (n2 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (NumberIsNaN(n2)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n2 <= state.length)
        return n2;
      return state.ended ? state.length : 0;
    }
    Readable4.prototype.read = function(n2) {
      debug("read", n2);
      if (n2 === void 0) {
        n2 = NaN;
      } else if (!NumberIsInteger(n2)) {
        n2 = NumberParseInt(n2, 10);
      }
      const state = this._readableState;
      const nOrig = n2;
      if (n2 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n2);
      if (n2 !== 0)
        state.emittedReadable = false;
      if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n2 = howMuchToRead(n2, state);
      if (n2 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n2 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.sync = false;
        if (!state.reading)
          n2 = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n2 > 0)
        ret = fromList(n2, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n2 = 0;
      } else {
        state.length -= n2;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n2 && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable4.prototype._read = function(n2) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable4.prototype.pipe = function(dest, pipeOpts) {
      const src5 = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src5.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src5) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src5.removeListener("end", onend);
        src5.removeListener("end", unpipe);
        src5.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src5.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src5, dest);
          dest.on("drain", ondrain);
        }
      }
      src5.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s2 = dest._writableState || dest._readableState;
          if (s2 && !s2.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src5.unpipe(dest);
      }
      dest.emit("pipe", src5);
      if (dest.writableNeedDrain === true) {
        if (state.flowing) {
          pause();
        }
      } else if (!state.flowing) {
        debug("pipe resume");
        src5.resume();
      }
      return dest;
    };
    function pipeOnDrain(src5, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src5._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src5.listenerCount("data")) {
          src5.resume();
        }
      };
    }
    Readable4.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i2 = 0; i2 < dests.length; i2++)
          dests[i2].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable4.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable4.prototype.addListener = Readable4.prototype.on;
    Readable4.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable4.prototype.off = Readable4.prototype.removeListener;
    Readable4.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable4.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable4.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable4.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j2 = 1; j2 < streamKeys.length; j2++) {
        const i2 = streamKeys[j2];
        if (this[i2] === void 0 && typeof stream[i2] === "function") {
          this[i2] = stream[i2].bind(stream);
        }
      }
      return this;
    };
    Readable4.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable4.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable4.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve5) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve5;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable4.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r2 = this._readableState;
          return !!r2 && r2.readable !== false && !r2.destroyed && !r2.errorEmitted && !r2.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable4._fromList = fromList;
    function fromList(n2, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n2 || n2 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n2, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable4.from = function(iterable, opts) {
      return from7(Readable4, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable4.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable4.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable4.wrap = function(src5, options) {
      var _ref, _src$readableObjectMo;
      return new Readable4({
        objectMode: (_ref = (_src$readableObjectMo = src5.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src5.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src5, err);
          callback(err);
        }
      }).wrap(src5);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/writable.js"(exports2, module2) {
    var process2 = require_process();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require("events");
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require("buffer");
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n2 = state.bufferedIndex; n2 < state.buffered.length; ++n2) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n2];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
        var _state$errored2;
        onfinishCallbacks[i2](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i2 = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n2 = i2; n2 < buffered.length; ++n2) {
            buffered[n2].callback(err);
          }
        };
        const chunks = state.allNoop && i2 === 0 ? buffered : ArrayPrototypeSlice(buffered, i2);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i2];
          buffered[i2++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i2 < buffered.length && !state.writing);
        if (i2 === buffered.length) {
          resetBuffer(state);
        } else if (i2 > 256) {
          buffered.splice(0, i2);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i2;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
            onfinishCallbacks[i2](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i2 = 0; i2 < onfinishCallbacks.length; i2++) {
        onfinishCallbacks[i2]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w2 = this._writableState;
          return !!w2 && w2.writable !== false && !w2.destroyed && !w2.errored && !w2.ending && !w2.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports2, module2) {
    var process2 = require_process();
    var bufferModule = require("buffer");
    var {
      isReadable,
      isWritable,
      isIterable: isIterable2,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable4 = require_readable();
    var { createDeferredPromise } = require_util();
    var from7 = require_from();
    var Blob = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob !== "undefined" ? function isBlob2(b2) {
      return b2 instanceof Blob;
    } : function isBlob2(b2) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name6) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable2(value)) {
          return from7(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d2;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d2, err);
            }
          );
          return d2 = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name6, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable2(body)) {
        return from7(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d2;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d2.push(val);
            }
            d2.push(null);
          },
          (err) => {
            destroyer(d2, err);
          }
        );
        return d2 = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name6,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve: resolve5 } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve: resolve5 } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve5;
          resolve5 = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve5;
          resolve5 = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r2 = pair.readable && typeof pair.readable.read !== "function" ? Readable4.wrap(pair.readable) : pair.readable;
      const w2 = pair.writable;
      let readable = !!isReadable(r2);
      let writable = !!isWritable(w2);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d2;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d2.destroy(err);
        } else if (!readable && !writable) {
          d2.destroy();
        }
      }
      d2 = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r2 !== null && r2 !== void 0 && r2.readableObjectMode),
        writableObjectMode: !!(w2 !== null && w2 !== void 0 && w2.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w2, (err) => {
          writable = false;
          if (err) {
            destroyer(r2, err);
          }
          onfinished(err);
        });
        d2._write = function(chunk, encoding, callback) {
          if (w2.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d2._final = function(callback) {
          w2.end();
          onfinish = callback;
        };
        w2.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w2.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r2, (err) => {
          readable = false;
          if (err) {
            destroyer(r2, err);
          }
          onfinished(err);
        });
        r2.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r2.on("end", function() {
          d2.push(null);
        });
        d2._read = function() {
          while (true) {
            const buf2 = r2.read();
            if (buf2 === null) {
              onreadable = d2._read;
              return;
            }
            if (!d2.push(buf2)) {
              return;
            }
          }
        };
      }
      d2._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w2, err);
          destroyer(r2, err);
        }
      };
      return d2;
    }
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/duplex.js"(exports2, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable4 = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable4.prototype);
    ObjectSetPrototypeOf(Duplex, Readable4);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const method = keys[i2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable4.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/transform.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length5 = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length5 === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    var process2 = require_process();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var { isIterable: isIterable2, isReadable, isReadableNodeStream, isNodeStream } = require_utils();
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough;
    var Readable4;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable2(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable4) {
        Readable4 = require_readable();
      }
      yield* Readable4.prototype[SymbolAsyncIterator].call(val);
    }
    async function pump(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve5, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve5();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
        }
        await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort);
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort);
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i2 = 0; i2 < streams.length; i2++) {
        const stream = streams[i2];
        const reading = i2 < streams.length - 1;
        const writing = i2 > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i2 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i2 === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable2(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable2(stream) || isReadableNodeStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          ret = makeAsyncIterable(ret);
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable2(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i2 - 1}]`, ret);
            }
          } else {
            var _ret;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt2 = new PassThrough({
              objectMode: true
            });
            const then = (_ret = ret) === null || _ret === void 0 ? void 0 : _ret.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt2.write(val);
                  }
                  if (end) {
                    pt2.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt2.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable2(ret, true)) {
              finishCount++;
              pump(ret, pt2, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt2;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isIterable2(ret)) {
            finishCount++;
            pump(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], ret);
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src5, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src5.pipe(dst, {
        end
      });
      if (end) {
        src5.once("end", () => {
          ended = true;
          dst.end();
        });
      } else {
        finish();
      }
      eos(
        src5,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src5._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src5.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/compose.js"(exports2, module2) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var { isNodeStream, isReadable, isWritable } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n2 = 0; n2 < streams.length; ++n2) {
        if (!isNodeStream(streams[n2])) {
          continue;
        }
        if (n2 < streams.length - 1 && !isReadable(streams[n2])) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n2}]`, orgStreams[n2], "must be readable");
        }
        if (n2 > 0 && !isWritable(streams[n2])) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n2}]`, orgStreams[n2], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d2;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d2.destroy(err);
        } else if (!readable && !writable) {
          d2.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!isWritable(head);
      const readable = !!isReadable(tail);
      d2 = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
        writable,
        readable
      });
      if (writable) {
        d2._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d2._final = function(callback) {
          head.end();
          onfinish = callback;
        };
        head.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        tail.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        tail.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        tail.on("end", function() {
          d2.push(null);
        });
        d2._read = function() {
          while (true) {
            const buf2 = tail.read();
            if (buf2 === null) {
              onreadable = d2._read;
              return;
            }
            if (!d2.push(buf2)) {
              return;
            }
          }
        };
      }
      d2._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(tail, err);
        }
      };
      return d2;
    };
  }
});

// ../../node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "../../node_modules/readable-stream/lib/stream/promises.js"(exports2, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable: isIterable2, isNodeStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    function pipeline(...streams) {
      return new Promise2((resolve5, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable2(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve5(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});

// ../../node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/readable-stream/lib/stream.js"(exports2, module2) {
    var { Buffer: Buffer2 } = require("buffer");
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils3 = require_utils();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDisturbed = utils3.isDisturbed;
    Stream.isErrored = utils3.isErrored;
    Stream.isReadable = utils3.isReadable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// ../../node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS({
  "../../node_modules/readable-stream/lib/ours/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    if (Stream && process.env.READABLE_STREAM === "disable") {
      const promises = Stream.promises;
      module2.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = Stream._isUint8Array;
      module2.exports.isDisturbed = Stream.isDisturbed;
      module2.exports.isErrored = Stream.isErrored;
      module2.exports.isReadable = Stream.isReadable;
      module2.exports.Readable = Stream.Readable;
      module2.exports.Writable = Stream.Writable;
      module2.exports.Duplex = Stream.Duplex;
      module2.exports.Transform = Stream.Transform;
      module2.exports.PassThrough = Stream.PassThrough;
      module2.exports.addAbortSignal = Stream.addAbortSignal;
      module2.exports.finished = Stream.finished;
      module2.exports.destroy = Stream.destroy;
      module2.exports.pipeline = Stream.pipeline;
      module2.exports.compose = Stream.compose;
      Object.defineProperty(Stream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = Stream.Stream;
    } else {
      const CustomStream = require_stream();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable;
      module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = CustomStream._isUint8Array;
      module2.exports.isDisturbed = CustomStream.isDisturbed;
      module2.exports.isErrored = CustomStream.isErrored;
      module2.exports.isReadable = CustomStream.isReadable;
      module2.exports.Readable = CustomStream.Readable;
      module2.exports.Writable = CustomStream.Writable;
      module2.exports.Duplex = CustomStream.Duplex;
      module2.exports.Transform = CustomStream.Transform;
      module2.exports.PassThrough = CustomStream.PassThrough;
      module2.exports.addAbortSignal = CustomStream.addAbortSignal;
      module2.exports.finished = CustomStream.finished;
      module2.exports.destroy = CustomStream.destroy;
      module2.exports.destroy = originalDestroy;
      module2.exports.pipeline = CustomStream.pipeline;
      module2.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  }
});

// ../../node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "../../node_modules/node-gyp-build/node-gyp-build.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name6 = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name6 + "_PREBUILD"])
          dir = process.env[name6 + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve5(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve5(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve5(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter2) {
      var files = readdirSync(dir).filter(filter2);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name6) {
      return /\.node$/.test(name6);
    }
    function parseTuple(name6) {
      var arr = name6.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name: name6, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a2, b2) {
      return a2.architectures.length - b2.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var tag = arr[i2];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a2, b2) {
        if (a2.runtime !== b2.runtime) {
          return a2.runtime === runtime2 ? -1 : 1;
        } else if (a2.abi !== b2.abi) {
          return a2.abi ? -1 : 1;
        } else if (a2.specificity !== b2.specificity) {
          return a2.specificity > b2.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// ../../node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "../../node_modules/node-gyp-build/index.js"(exports2, module2) {
    if (typeof process.addon === "function") {
      module2.exports = process.addon.bind(process);
    } else {
      module2.exports = require_node_gyp_build();
    }
  }
});

// ../../node_modules/secp256k1/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/secp256k1/lib/index.js"(exports2, module2) {
    var errors = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert(cond, msg) {
      if (!cond)
        throw new Error(msg);
    }
    function isUint8Array(name6, value, length5) {
      assert(value instanceof Uint8Array, `Expected ${name6} to be an Uint8Array`);
      if (length5 !== void 0) {
        if (Array.isArray(length5)) {
          const numbers = length5.join(", ");
          const msg = `Expected ${name6} to be an Uint8Array with length [${numbers}]`;
          assert(length5.includes(value.length), msg);
        } else {
          const msg = `Expected ${name6} to be an Uint8Array with length ${length5}`;
          assert(value.length === length5, msg);
        }
      }
    }
    function isCompressed(value) {
      assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length5) {
      if (typeof output === "function")
        output = output(length5);
      isUint8Array("output", output, length5);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module2.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert(
            seed === null || seed instanceof Uint8Array,
            "Expected seed to be an Uint8Array or null"
          );
          if (seed !== null)
            isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SECKEY_INVALID);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0)
            assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors.SIGN);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert(
            toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
            "Expected recovery id to be a Number within interval [0, 3]"
          );
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.RECOVER);
            case 3:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0)
              isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0)
              isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.ECDH);
          }
        }
      };
    };
  }
});

// ../../node_modules/secp256k1/bindings.js
var require_bindings = __commonJS({
  "../../node_modules/secp256k1/bindings.js"(exports2, module2) {
    var addon = require_node_gyp_build2()(__dirname);
    module2.exports = require_lib()(new addon.Secp256k1());
  }
});

// ../../node_modules/elliptic/package.json
var require_package = __commonJS({
  "../../node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// ../../node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../../node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base6, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base6 === "le" || base6 === "be") {
            endian = base6;
            base6 = 10;
          }
          this._init(number || 0, base6 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e2) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base6, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base6, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base6, endian);
        }
        if (base6 === "hex") {
          base6 = 16;
        }
        assert(base6 === (base6 | 0) && base6 >= 2 && base6 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base6 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base6, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base6, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base6, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base6, endian);
      };
      BN.prototype._initArray = function _initArray(number, base6, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
            w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
            w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string2, index) {
        var c2 = string2.charCodeAt(index);
        if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          return c2 - 48 & 15;
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w2;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w2 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w2 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r2 *= mul;
          if (c2 >= 49) {
            r2 += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r2 += c2 - 17 + 10;
          } else {
            r2 += c2;
          }
        }
        return r2;
      }
      BN.prototype._parseBase = function _parseBase(number, base6, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base6) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base6 | 0;
        var total = number.length - start;
        var mod4 = total % limbLen;
        var end = Math.min(total, total - mod4) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base6);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod4 !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base6);
          for (i2 = 0; i2 < mod4; i2++) {
            pow *= base6;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r2 = new BN(null);
        this.copy(r2);
        return r2;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString4(base6, padding) {
        base6 = base6 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base6 === 16 || base6 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w2 = this.words[i2];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base6 === (base6 | 0) && base6 >= 2 && base6 <= 36) {
          var groupSize = groupSizes[base6];
          var groupBase = groupBases[base6];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modn(groupBase).toString(base6);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length5) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length5);
      };
      BN.prototype.toArray = function toArray(endian, length5) {
        return this.toArrayLike(Array, endian, length5);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length5) {
        var byteLength = this.byteLength();
        var reqLength = length5 || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i2;
        var q2 = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[reqLength - i2 - 1] = b2;
          }
        } else {
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[i2] = b2;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN.prototype._countBits = function _countBits(w2) {
          var t2 = w2;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0)
          return 26;
        var t2 = w2;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w2;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b2 = this._zeroBits(this.words[i2]);
          r2 += b2;
          if (b2 !== 26)
            break;
        }
        return r2;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or5(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a2;
        var b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b2.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b2;
        if (cmp > 0) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a2 * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2 | 0;
            a2 = self2.words[i2] | 0;
            b2 = num.words[j2] | 0;
            r2 = a2 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b2 = num.words;
        var o2 = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w2;
        o2[3] = w3;
        o2[4] = w4;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c2 !== 0) {
          o2[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2;
            var a2 = self2.words[i2] | 0;
            var b2 = num.words[j2] | 0;
            var r2 = a2 * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      FFTM.prototype.makeRBT = function makeRBT(N10) {
        var t2 = new Array(N10);
        var l2 = BN.prototype._countBits(N10) - 1;
        for (var i2 = 0; i2 < N10; i2++) {
          t2[i2] = this.revBin(i2, l2, N10);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x2, l2, N10) {
        if (x2 === 0 || x2 === N10 - 1)
          return x2;
        var rb = 0;
        for (var i2 = 0; i2 < l2; i2++) {
          rb |= (x2 & 1) << l2 - i2 - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
        for (var i2 = 0; i2 < N10; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N10);
        for (var s2 = 1; s2 < N10; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p2 = 0; p2 < N10; p2 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s2; j2++) {
              var re2 = rtws[p2 + j2];
              var ie2 = itws[p2 + j2];
              var ro = rtws[p2 + j2 + s2];
              var io = itws[p2 + j2 + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j2] = re2 + ro;
              itws[p2 + j2] = ie2 + io;
              rtws[p2 + j2 + s2] = re2 - ro;
              itws[p2 + j2 + s2] = ie2 - io;
              if (j2 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
        var N10 = Math.max(m2, n2) | 1;
        var odd = N10 & 1;
        var i2 = 0;
        for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
        if (N10 <= 1)
          return;
        for (var i2 = 0; i2 < N10 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N10 - i2 - 1];
          rws[N10 - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N10 - i2 - 1];
          iws[N10 - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N10) {
        var carry = 0;
        for (var i2 = 0; i2 < N10 / 2; i2++) {
          var w2 = Math.round(ws[2 * i2 + 1] / N10) * 8192 + Math.round(ws[2 * i2] / N10) + carry;
          ws[i2] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N10) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N10; ++i2) {
          rws[i2] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N10) {
        var ph = new Array(N10);
        for (var i2 = 0; i2 < N10; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y2, out) {
        var N10 = 2 * this.guessLen13b(x2.length, y2.length);
        var rbt = this.makeRBT(N10);
        var _2 = this.stub(N10);
        var rws = new Array(N10);
        var rwst = new Array(N10);
        var iwst = new Array(N10);
        var nrws = new Array(N10);
        var nrwst = new Array(N10);
        var niwst = new Array(N10);
        var rmws = out.words;
        rmws.length = N10;
        this.convert13b(x2.words, x2.length, rws, N10);
        this.convert13b(y2.words, y2.length, nrws, N10);
        this.transform(rws, _2, rwst, iwst, N10, rbt);
        this.transform(nrws, _2, nrwst, niwst, N10, rbt);
        for (var i2 = 0; i2 < N10; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N10);
        this.transform(rwst, iwst, rmws, _2, N10, rbt);
        this.conjugate(rmws, _2, N10);
        this.normalize13b(rmws, N10);
        out.negative = x2.negative ^ y2.negative;
        out.length = x2.length + y2.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = (this.words[i2] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
          if (w2[i2] !== 0)
            break;
        }
        if (++i2 < w2.length) {
          for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
            if (w2[i2] === 0)
              continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c2 = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2)
          return false;
        var w2 = this.words[s2];
        return !!(w2 & q2);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w2 & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2 + shift] = w2 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w2 = -(this.words[i2] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2] = w2 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a2.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m2 = a2.length - b2.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN(null);
          q2.length = m2 + 1;
          q2.words = new Array(q2.length);
          for (var i2 = 0; i2 < q2.length; i2++) {
            q2.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
        if (diff.negative === 0) {
          a2 = diff;
          if (q2) {
            q2.words[m2] = 1;
          }
        }
        for (var j2 = m2 - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b2, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b2, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j2] = qj;
          }
        }
        if (q2) {
          q2.strip();
        }
        a2.strip();
        if (mode !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a2
        };
      };
      BN.prototype.divmod = function divmod2(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod4, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod4 = res.mod.neg();
            if (positive && mod4.negative !== 0) {
              mod4.iadd(num);
            }
          }
          return {
            div,
            mod: mod4
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod4 = res.mod.neg();
            if (positive && mod4.negative !== 0) {
              mod4.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod4
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod4(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod4 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod4.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w2 = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w2 / num | 0;
          carry = w2 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var x2 = this;
        var y2 = p2.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p2);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN(1);
        var B2 = new BN(0);
        var C2 = new BN(0);
        var D2 = new BN(1);
        var g2 = 0;
        while (x2.isEven() && y2.isEven()) {
          x2.iushrn(1);
          y2.iushrn(1);
          ++g2;
        }
        var yp = y2.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x2.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B2.isOdd()) {
                A2.iadd(yp);
                B2.isub(xp);
              }
              A2.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
            ;
          if (j2 > 0) {
            y2.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D2.isOdd()) {
                C2.iadd(yp);
                D2.isub(xp);
              }
              C2.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y2) >= 0) {
            x2.isub(y2);
            A2.isub(C2);
            B2.isub(D2);
          } else {
            y2.isub(x2);
            C2.isub(A2);
            D2.isub(B2);
          }
        }
        return {
          a: C2,
          b: D2,
          gcd: y2.iushln(g2)
        };
      };
      BN.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var a2 = this;
        var b2 = p2.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p2);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b2.clone();
        while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
            ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b2) >= 0) {
            a2.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b2 = num.clone();
        a2.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
          a2.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a2.cmp(b2);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a2.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q2;
          return this;
        }
        var carry = q2;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w2 = this.words[i2] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i2] = w2;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b2 = num.words[i2] | 0;
          if (a2 === b2)
            continue;
          if (a2 < b2) {
            res = -1;
          } else if (a2 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name6, p2) {
        this.name = name6;
        this.p = new BN(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w2 = num.words[i2] | 0;
          lo += w2 * 977;
          num.words[i2] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name6) {
        if (primes[name6])
          return primes[name6];
        var prime2;
        if (name6 === "k256") {
          prime2 = new K256();
        } else if (name6 === "p224") {
          prime2 = new P224();
        } else if (name6 === "p192") {
          prime2 = new P192();
        } else if (name6 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name6);
        }
        primes[name6] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert(a2.negative === 0, "red works only with positives");
        assert(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b2) {
        assert((a2.negative | b2.negative) === 0, "red works only with positives");
        assert(
          a2.red && a2.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.imul(b2));
      };
      Red.prototype.mul = function mul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.mul(b2));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod32 = this.m.andln(3);
        assert(mod32 % 2 === 1);
        if (mod32 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q2 = this.m.subn(1);
        var s2 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s2++;
          q2.iushrn(1);
        }
        assert(!q2.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c2 = this.pow(z2, q2);
        var r2 = this.pow(a2, q2.addn(1).iushrn(1));
        var t2 = this.pow(a2, q2);
        var m2 = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert(i2 < m2);
          var b2 = this.pow(c2, new BN(1).iushln(m2 - i2 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m2 = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b2) {
        if (a2.isZero() || b2.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b2) {
        if (a2.isZero() || b2.isZero())
          return new BN(0)._forceRed(this);
        var t2 = a2.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// ../../node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "../../node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l2, r2, msg) {
      if (l2 != r2)
        throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
    };
  }
});

// ../../node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var utils3 = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      } else {
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c2 = msg.charCodeAt(i2);
          var hi = c2 >> 8;
          var lo = c2 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils3.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils3.zero2 = zero2;
    function toHex3(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    utils3.toHex = toHex3;
    utils3.encode = function encode17(arr, enc) {
      if (enc === "hex")
        return toHex3(arr);
      else
        return arr;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var utils3 = exports2;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils3.assert = minAssert;
    utils3.toArray = minUtils.toArray;
    utils3.zero2 = minUtils.zero2;
    utils3.toHex = minUtils.toHex;
    utils3.encode = minUtils.encode;
    function getNAF(num, w2, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w2 + 1;
      var k2 = num.clone();
      for (var i2 = 0; i2 < naf.length; i2++) {
        var z2;
        var mod4 = k2.andln(ws - 1);
        if (k2.isOdd()) {
          if (mod4 > (ws >> 1) - 1)
            z2 = (ws >> 1) - mod4;
          else
            z2 = mod4;
          k2.isubn(z2);
        } else {
          z2 = 0;
        }
        naf[i2] = z2;
        k2.iushrn(1);
      }
      return naf;
    }
    utils3.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils3.getJSF = getJSF;
    function cachedProperty(obj, name6, computer) {
      var key = "_" + name6;
      obj.prototype[name6] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils3.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils3.toArray(bytes, "hex") : bytes;
    }
    utils3.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils3.intFromLE = intFromLE;
  }
});

// ../../node_modules/brorand/index.js
var require_brorand = __commonJS({
  "../../node_modules/brorand/index.js"(exports2, module2) {
    var r2;
    module2.exports = function rand(len) {
      if (!r2)
        r2 = new Rand(null);
      return r2.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n2) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n2);
      var res = new Uint8Array(n2);
      for (var i2 = 0; i2 < res.length; i2++)
        res[i2] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto6 = require("crypto");
        if (typeof crypto6.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n2) {
          return crypto6.randomBytes(n2);
        };
      } catch (e2) {
      }
    }
    var crypto6;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/base.js
var require_base3 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils3 = require_utils3();
    var getNAF = utils3.getNAF;
    var getJSF = utils3.getJSF;
    var assert = utils3.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate4() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
      assert(p2.precomputed);
      var doubles = p2._getDoubles();
      var naf = getNAF(k2, 1, this._bitLength);
      var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I2 /= 3;
      var repr = [];
      var j2;
      var nafW;
      for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
        nafW = 0;
        for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
          nafW = (nafW << 1) + naf[l2];
        repr.push(nafW);
      }
      var a2 = this.jpoint(null, null, null);
      var b2 = this.jpoint(null, null, null);
      for (var i2 = I2; i2 > 0; i2--) {
        for (j2 = 0; j2 < repr.length; j2++) {
          nafW = repr[j2];
          if (nafW === i2)
            b2 = b2.mixedAdd(doubles.points[j2]);
          else if (nafW === -i2)
            b2 = b2.mixedAdd(doubles.points[j2].neg());
        }
        a2 = a2.add(b2);
      }
      return a2.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
      var w2 = 4;
      var nafPoints = p2._getNAFPoints(w2);
      w2 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k2, w2, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i2 = naf.length - 1; i2 >= 0; i2--) {
        for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
          l2++;
        if (i2 >= 0)
          l2++;
        acc = acc.dblp(l2);
        if (i2 < 0)
          break;
        var z2 = naf[i2];
        assert(z2 !== 0);
        if (p2.type === "affine") {
          if (z2 > 0)
            acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
        } else {
          if (z2 > 0)
            acc = acc.add(wnd[z2 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z2 - 1 >> 1].neg());
        }
      }
      return p2.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i2;
      var j2;
      var p2;
      for (i2 = 0; i2 < len; i2++) {
        p2 = points[i2];
        var nafPoints = p2._getNAFPoints(defW);
        wndWidth[i2] = nafPoints.wnd;
        wnd[i2] = nafPoints.points;
      }
      for (i2 = len - 1; i2 >= 1; i2 -= 2) {
        var a2 = i2 - 1;
        var b2 = i2;
        if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
          naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
          naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
          max = Math.max(naf[a2].length, max);
          max = Math.max(naf[b2].length, max);
          continue;
        }
        var comb = [
          points[a2],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b2]
          /* 7 */
        ];
        if (points[a2].y.cmp(points[b2].y) === 0) {
          comb[1] = points[a2].add(points[b2]);
          comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
        } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
          comb[1] = points[a2].toJ().mixedAdd(points[b2]);
          comb[2] = points[a2].add(points[b2].neg());
        } else {
          comb[1] = points[a2].toJ().mixedAdd(points[b2]);
          comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a2], coeffs[b2]);
        max = Math.max(jsf[0].length, max);
        naf[a2] = new Array(max);
        naf[b2] = new Array(max);
        for (j2 = 0; j2 < max; j2++) {
          var ja = jsf[0][j2] | 0;
          var jb = jsf[1][j2] | 0;
          naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b2][j2] = 0;
          wnd[a2] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i2 = max; i2 >= 0; i2--) {
        var k2 = 0;
        while (i2 >= 0) {
          var zero = true;
          for (j2 = 0; j2 < len; j2++) {
            tmp[j2] = naf[j2][i2] | 0;
            if (tmp[j2] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k2++;
          i2--;
        }
        if (i2 >= 0)
          k2++;
        acc = acc.dblp(k2);
        if (i2 < 0)
          break;
        for (j2 = 0; j2 < len; j2++) {
          var z2 = tmp[j2];
          p2;
          if (z2 === 0)
            continue;
          else if (z2 > 0)
            p2 = wnd[j2][z2 - 1 >> 1];
          else if (z2 < 0)
            p2 = wnd[j2][-z2 - 1 >> 1].neg();
          if (p2.type === "affine")
            acc = acc.mixedAdd(p2);
          else
            acc = acc.add(p2);
        }
      }
      for (i2 = 0; i2 < len; i2++)
        wnd[i2] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate4() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils3.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x2 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x2);
      return [4].concat(x2, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode17(enc, compact) {
      return utils3.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i2 = 0; i2 < power; i2 += step) {
        for (var j2 = 0; j2 < step; j2++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i2 = 1; i2 < max; i2++)
        res[i2] = res[i2 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k2) {
      var r2 = this;
      for (var i2 = 0; i2 < k2; i2++)
        r2 = r2.dbl();
      return r2;
    };
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e2) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits();
    var Base = require_base3();
    var assert = utils3.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l2 = ntinv.redSub(s2).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u2 = lambda;
      var v2 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i2 = 0;
      var r2;
      var x3;
      while (u2.cmpn(0) !== 0) {
        var q2 = v2.div(u2);
        r2 = v2.sub(q2.mul(u2));
        x3 = x2.sub(q2.mul(x1));
        var y3 = y2.sub(q2.mul(y1));
        if (!a1 && r2.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r2.neg();
          b1 = x3;
        } else if (a1 && ++i2 === 2) {
          break;
        }
        prevR = r2;
        v2 = u2;
        u2 = r2;
        x2 = x1;
        x1 = x3;
        y2 = y1;
        y1 = y3;
      }
      a2 = r2.neg();
      b2 = x3;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k2).divRound(this.n);
      var c2 = v1.b.neg().mul(k2).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k2.sub(p1).sub(p2);
      var k22 = q1.add(q2).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
      x2 = new BN(x2, 16);
      if (!x2.red)
        x2 = x2.toRed(this.red);
      var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
      var y3 = y2.redSqrt();
      if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y3.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y3 = y3.redNeg();
      return this.point(x2, y3);
    };
    ShortCurve.prototype.validate = function validate4(point) {
      if (point.inf)
        return true;
      var x2 = point.x;
      var y2 = point.y;
      var ax = this.a.redMul(x2);
      var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
      return y2.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i2 = 0; i2 < points.length; i2++) {
        var split = this._endoSplit(coeffs[i2]);
        var p2 = points[i2];
        var beta = p2._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p2 = p2.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i2 * 2] = p2;
        npoints[i2 * 2 + 1] = beta;
        ncoeffs[i2 * 2] = split.k1;
        ncoeffs[i2 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
      for (var j2 = 0; j2 < i2 * 2; j2++) {
        npoints[j2] = null;
        ncoeffs[j2] = null;
      }
      return res;
    };
    function Point3(curve, x2, y2, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x2 === null && y2 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x2, 16);
        this.y = new BN(y2, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point3, Base.BasePoint);
    ShortCurve.prototype.point = function point(x2, y2, isRed) {
      return new Point3(this, x2, y2, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point3.fromJSON(this, obj, red);
    };
    Point3.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p2) {
          return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point3.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point3.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point3.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point3.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point3.prototype.add = function add(p2) {
      if (this.inf)
        return p2;
      if (p2.inf)
        return this;
      if (this.eq(p2))
        return this.dbl();
      if (this.neg().eq(p2))
        return this.curve.point(null, null);
      if (this.x.cmp(p2.x) === 0)
        return this.curve.point(null, null);
      var c2 = this.y.redSub(p2.y);
      if (c2.cmpn(0) !== 0)
        c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
      var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point3.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a2 = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
      var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point3.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point3.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point3.prototype.mul = function mul(k2) {
      k2 = new BN(k2, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k2]);
      else
        return this.curve._wnafMul(this, k2);
    };
    Point3.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point3.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point3.prototype.eq = function eq(p2) {
      return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
    };
    Point3.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p2) {
          return p2.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point3.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x2, y2, z2) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x2 === null && y2 === null && z2 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x2, 16);
        this.y = new BN(y2, 16);
        this.z = new BN(z2, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x2, y2, z2) {
      return new JPoint(this, x2, y2, z2);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p2) {
      if (this.isInfinity())
        return p2;
      if (p2.isInfinity())
        return this;
      var pz2 = p2.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p2.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p2.z));
      var s2 = p2.y.redMul(z2.redMul(this.z));
      var h2 = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h2.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h2.redSqr();
      var h3 = h22.redMul(h2);
      var v2 = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
      var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p2.z).redMul(h2);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p2) {
      if (this.isInfinity())
        return p2.toJ();
      if (p2.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p2.x.redMul(z2);
      var s1 = this.y;
      var s2 = p2.y.redMul(z2).redMul(this.z);
      var h2 = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h2.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h2.redSqr();
      var h3 = h22.redMul(h2);
      var v2 = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
      var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h2);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i2;
      if (this.curve.zeroA || this.curve.threeA) {
        var r2 = this;
        for (i2 = 0; i2 < pow; i2++)
          r2 = r2.dbl();
        return r2;
      }
      var a2 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i2 = 0; i2 < pow; i2++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c2.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c2.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i2 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx);
        var t2 = m2.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t2;
        ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a2 = this.x.redSqr();
        var b2 = this.y.redSqr();
        var c2 = b2.redSqr();
        var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
        d2 = d2.redIAdd(d2);
        var e2 = a2.redAdd(a2).redIAdd(a2);
        var f2 = e2.redSqr();
        var c8 = c2.redIAdd(c2);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f2.redISub(d2).redISub(d2);
        ny = e2.redMul(d2.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t2 = m2.redSqr().redISub(s2).redISub(s2);
        nx = t2;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a2 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c2.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c2.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m2 = xx.redAdd(xx).redIAdd(xx);
      var mm = m2.redSqr();
      var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e2 = e2.redIAdd(e2);
      e2 = e2.redAdd(e2).redIAdd(e2);
      e2 = e2.redISub(mm);
      var ee2 = e2.redSqr();
      var t2 = yyyy.redIAdd(yyyy);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
      var yyu4 = yy.redMul(u2);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee2).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k2, kbase) {
      k2 = new BN(k2, kbase);
      return this.curve._wnafMul(this, k2);
    };
    JPoint.prototype.eq = function eq(p2) {
      if (p2.type === "affine")
        return this.eq(p2.toJ());
      if (this === p2)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p2.z.redSqr();
      if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p2.z);
      return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x2) {
      var zs = this.z.redSqr();
      var rx = x2.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x2.clone();
      var t2 = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var inherits = require_inherits();
    var Base = require_base3();
    var utils3 = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate4(point) {
      var x2 = point.normalize().x;
      var x22 = x2.redSqr();
      var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
      var y2 = rhs.redSqrt();
      return y2.redSqr().cmp(rhs) === 0;
    };
    function Point3(curve, x2, z2) {
      Base.BasePoint.call(this, curve, "projective");
      if (x2 === null && z2 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x2, 16);
        this.z = new BN(z2, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point3, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils3.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x2, z2) {
      return new Point3(this, x2, z2);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point3.fromJSON(this, obj);
    };
    Point3.prototype.precompute = function precompute() {
    };
    Point3.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point3.fromJSON = function fromJSON(curve, obj) {
      return new Point3(curve, obj[0], obj[1] || curve.one);
    };
    Point3.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point3.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point3.prototype.dbl = function dbl() {
      var a2 = this.x.redAdd(this.z);
      var aa = a2.redSqr();
      var b2 = this.x.redSub(this.z);
      var bb = b2.redSqr();
      var c2 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
      return this.curve.point(nx, nz);
    };
    Point3.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point3.prototype.diffAdd = function diffAdd(p2, diff) {
      var a2 = this.x.redAdd(this.z);
      var b2 = this.x.redSub(this.z);
      var c2 = p2.x.redAdd(p2.z);
      var d2 = p2.x.redSub(p2.z);
      var da = d2.redMul(a2);
      var cb = c2.redMul(b2);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point3.prototype.mul = function mul(k2) {
      var t2 = k2.clone();
      var a2 = this;
      var b2 = this.curve.point(null, null);
      var c2 = this;
      for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
        bits.push(t2.andln(1));
      for (var i2 = bits.length - 1; i2 >= 0; i2--) {
        if (bits[i2] === 0) {
          a2 = a2.diffAdd(b2, c2);
          b2 = b2.dbl();
        } else {
          b2 = a2.diffAdd(b2, c2);
          a2 = a2.dbl();
        }
      }
      return b2;
    };
    Point3.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point3.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point3.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point3.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point3.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits();
    var Base = require_base3();
    var assert = utils3.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x2, y2, z2, t2) {
      return this.point(x2, y2, z2, t2);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x2, odd) {
      x2 = new BN(x2, 16);
      if (!x2.red)
        x2 = x2.toRed(this.red);
      var x22 = x2.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y2 = rhs.redMul(lhs.redInvm());
      var y3 = y2.redSqrt();
      if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y3.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y3 = y3.redNeg();
      return this.point(x2, y3);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y2, odd) {
      y2 = new BN(y2, 16);
      if (!y2.red)
        y2 = y2.toRed(this.red);
      var y22 = y2.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y2);
      }
      var x3 = x2.redSqrt();
      if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x3.fromRed().isOdd() !== odd)
        x3 = x3.redNeg();
      return this.point(x3, y2);
    };
    EdwardsCurve.prototype.validate = function validate4(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point3(curve, x2, y2, z2, t2) {
      Base.BasePoint.call(this, curve, "projective");
      if (x2 === null && y2 === null && z2 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x2, 16);
        this.y = new BN(y2, 16);
        this.z = z2 ? new BN(z2, 16) : this.curve.one;
        this.t = t2 && new BN(t2, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point3, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point3.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x2, y2, z2, t2) {
      return new Point3(this, x2, y2, z2, t2);
    };
    Point3.fromJSON = function fromJSON(curve, obj) {
      return new Point3(curve, obj[0], obj[1], obj[2]);
    };
    Point3.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point3.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point3.prototype._extDbl = function _extDbl() {
      var a2 = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c2 = this.z.redSqr();
      c2 = c2.redIAdd(c2);
      var d2 = this.curve._mulA(a2);
      var e2 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b2);
      var g2 = d2.redAdd(b2);
      var f2 = g2.redSub(c2);
      var h2 = d2.redSub(b2);
      var nx = e2.redMul(f2);
      var ny = g2.redMul(h2);
      var nt2 = e2.redMul(h2);
      var nz = f2.redMul(g2);
      return this.curve.point(nx, ny, nz, nt2);
    };
    Point3.prototype._projDbl = function _projDbl() {
      var b2 = this.x.redAdd(this.y).redSqr();
      var c2 = this.x.redSqr();
      var d2 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e2;
      var h2;
      var j2;
      if (this.curve.twisted) {
        e2 = this.curve._mulA(c2);
        var f2 = e2.redAdd(d2);
        if (this.zOne) {
          nx = b2.redSub(c2).redSub(d2).redMul(f2.redSub(this.curve.two));
          ny = f2.redMul(e2.redSub(d2));
          nz = f2.redSqr().redSub(f2).redSub(f2);
        } else {
          h2 = this.z.redSqr();
          j2 = f2.redSub(h2).redISub(h2);
          nx = b2.redSub(c2).redISub(d2).redMul(j2);
          ny = f2.redMul(e2.redSub(d2));
          nz = f2.redMul(j2);
        }
      } else {
        e2 = c2.redAdd(d2);
        h2 = this.curve._mulC(this.z).redSqr();
        j2 = e2.redSub(h2).redSub(h2);
        nx = this.curve._mulC(b2.redISub(e2)).redMul(j2);
        ny = this.curve._mulC(e2).redMul(c2.redISub(d2));
        nz = e2.redMul(j2);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point3.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point3.prototype._extAdd = function _extAdd(p2) {
      var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
      var b2 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
      var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
      var d2 = this.z.redMul(p2.z.redAdd(p2.z));
      var e2 = b2.redSub(a2);
      var f2 = d2.redSub(c2);
      var g2 = d2.redAdd(c2);
      var h2 = b2.redAdd(a2);
      var nx = e2.redMul(f2);
      var ny = g2.redMul(h2);
      var nt2 = e2.redMul(h2);
      var nz = f2.redMul(g2);
      return this.curve.point(nx, ny, nz, nt2);
    };
    Point3.prototype._projAdd = function _projAdd(p2) {
      var a2 = this.z.redMul(p2.z);
      var b2 = a2.redSqr();
      var c2 = this.x.redMul(p2.x);
      var d2 = this.y.redMul(p2.y);
      var e2 = this.curve.d.redMul(c2).redMul(d2);
      var f2 = b2.redSub(e2);
      var g2 = b2.redAdd(e2);
      var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d2);
      var nx = a2.redMul(f2).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a2.redMul(g2).redMul(d2.redSub(this.curve._mulA(c2)));
        nz = f2.redMul(g2);
      } else {
        ny = a2.redMul(g2).redMul(d2.redSub(c2));
        nz = this.curve._mulC(f2).redMul(g2);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point3.prototype.add = function add(p2) {
      if (this.isInfinity())
        return p2;
      if (p2.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p2);
      else
        return this._projAdd(p2);
    };
    Point3.prototype.mul = function mul(k2) {
      if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else
        return this.curve._wnafMul(this, k2);
    };
    Point3.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, false);
    };
    Point3.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, true);
    };
    Point3.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point3.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point3.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point3.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point3.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point3.prototype.eqXToP = function eqXToP(x2) {
      var rx = x2.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x2.clone();
      var t2 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point3.prototype.toP = Point3.prototype.normalize;
    Point3.prototype.mixedAdd = Point3.prototype.add;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var curve = exports2;
    curve.base = require_base3();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// ../../node_modules/hash.js/lib/hash/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i2) {
      if ((msg.charCodeAt(i2) & 64512) !== 55296) {
        return false;
      }
      if (i2 < 0 || i2 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p2 = 0;
          for (var i2 = 0; i2 < msg.length; i2++) {
            var c2 = msg.charCodeAt(i2);
            if (c2 < 128) {
              res[p2++] = c2;
            } else if (c2 < 2048) {
              res[p2++] = c2 >> 6 | 192;
              res[p2++] = c2 & 63 | 128;
            } else if (isSurrogatePair(msg, i2)) {
              c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
              res[p2++] = c2 >> 18 | 240;
              res[p2++] = c2 >> 12 & 63 | 128;
              res[p2++] = c2 >> 6 & 63 | 128;
              res[p2++] = c2 & 63 | 128;
            } else {
              res[p2++] = c2 >> 12 | 224;
              res[p2++] = c2 >> 6 & 63 | 128;
              res[p2++] = c2 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i2 = 0; i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        }
      } else {
        for (i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex3(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    exports2.toHex = toHex3;
    function htonl(w2) {
      var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++) {
        var w2 = msg[i2];
        if (endian === "little")
          w2 = htonl(w2);
        res += zero8(w2.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
        var w2;
        if (endian === "big")
          w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
        else
          w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
        res[i2] = w2 >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
        var m2 = msg[i2];
        if (endian === "big") {
          res[k2] = m2 >>> 24;
          res[k2 + 1] = m2 >>> 16 & 255;
          res[k2 + 2] = m2 >>> 8 & 255;
          res[k2 + 3] = m2 & 255;
        } else {
          res[k2 + 3] = m2 >>> 24;
          res[k2 + 2] = m2 >>> 16 & 255;
          res[k2 + 1] = m2 >>> 8 & 255;
          res[k2] = m2 & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w2, b2) {
      return w2 >>> b2 | w2 << 32 - b2;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w2, b2) {
      return w2 << b2 | w2 >>> 32 - b2;
    }
    exports2.rotl32 = rotl32;
    function sum32(a2, b2) {
      return a2 + b2 >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a2, b2, c2) {
      return a2 + b2 + c2 >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a2, b2, c2, d2) {
      return a2 + b2 + c2 + d2 >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a2, b2, c2, d2, e2) {
      return a2 + b2 + c2 + d2 + e2 >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf2, pos, ah, al) {
      var bh = buf2[pos];
      var bl = buf2[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf2[pos] = hi >>> 0;
      buf2[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r2 = al << 32 - num | ah >>> num;
      return r2 >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// ../../node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "../../node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils3 = require_utils4();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils3.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r2 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r2, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils3.join32(msg, 0, msg.length - r2, this.endian);
        for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
          this._update(msg, i2, i2 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest3(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k2 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k2 + this.padLength);
      res[0] = 128;
      for (var i2 = 1; i2 < k2; i2++)
        res[i2] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t2 = 8; t2 < this.padLength; t2++)
          res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len & 255;
      } else {
        res[i2++] = len & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        for (t2 = 8; t2 < this.padLength; t2++)
          res[i2++] = 0;
      }
      return res;
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils3 = require_utils4();
    var rotr32 = utils3.rotr32;
    function ft_1(s2, x2, y2, z2) {
      if (s2 === 0)
        return ch32(x2, y2, z2);
      if (s2 === 1 || s2 === 3)
        return p32(x2, y2, z2);
      if (s2 === 2)
        return maj32(x2, y2, z2);
    }
    exports2.ft_1 = ft_1;
    function ch32(x2, y2, z2) {
      return x2 & y2 ^ ~x2 & z2;
    }
    exports2.ch32 = ch32;
    function maj32(x2, y2, z2) {
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    }
    exports2.maj32 = maj32;
    function p32(x2, y2, z2) {
      return x2 ^ y2 ^ z2;
    }
    exports2.p32 = p32;
    function s0_256(x2) {
      return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x2) {
      return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x2) {
      return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x2) {
      return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// ../../node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils3.rotl32;
    var sum32 = utils3.sum32;
    var sum32_5 = utils3.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils3.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W2[i2] = msg[start + i2];
      for (; i2 < W2.length; i2++)
        W2[i2] = rotl32(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
      var a2 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d2 = this.h[3];
      var e2 = this.h[4];
      for (i2 = 0; i2 < W2.length; i2++) {
        var s2 = ~~(i2 / 20);
        var t2 = sum32_5(rotl32(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i2], sha1_K[s2]);
        e2 = d2;
        d2 = c2;
        c2 = rotl32(b2, 30);
        b2 = a2;
        a2 = t2;
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d2);
      this.h[4] = sum32(this.h[4], e2);
    };
    SHA1.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils3.toHex32(this.h, "big");
      else
        return utils3.split32(this.h, "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils3.sum32;
    var sum32_4 = utils3.sum32_4;
    var sum32_5 = utils3.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils3.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W2[i2] = msg[start + i2];
      for (; i2 < W2.length; i2++)
        W2[i2] = sum32_4(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
      var a2 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d2 = this.h[3];
      var e2 = this.h[4];
      var f2 = this.h[5];
      var g2 = this.h[6];
      var h2 = this.h[7];
      assert(this.k.length === W2.length);
      for (i2 = 0; i2 < W2.length; i2++) {
        var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
        var T2 = sum32(s0_256(a2), maj32(a2, b2, c2));
        h2 = g2;
        g2 = f2;
        f2 = e2;
        e2 = sum32(d2, T1);
        d2 = c2;
        c2 = b2;
        b2 = a2;
        a2 = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d2);
      this.h[4] = sum32(this.h[4], e2);
      this.h[5] = sum32(this.h[5], f2);
      this.h[6] = sum32(this.h[6], g2);
      this.h[7] = sum32(this.h[7], h2);
    };
    SHA256.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils3.toHex32(this.h, "big");
      else
        return utils3.split32(this.h, "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils4();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils3.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils3.toHex32(this.h.slice(0, 7), "big");
      else
        return utils3.split32(this.h.slice(0, 7), "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils4();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils3.rotr64_hi;
    var rotr64_lo = utils3.rotr64_lo;
    var shr64_hi = utils3.shr64_hi;
    var shr64_lo = utils3.shr64_lo;
    var sum64 = utils3.sum64;
    var sum64_hi = utils3.sum64_hi;
    var sum64_lo = utils3.sum64_lo;
    var sum64_4_hi = utils3.sum64_4_hi;
    var sum64_4_lo = utils3.sum64_4_lo;
    var sum64_5_hi = utils3.sum64_5_hi;
    var sum64_5_lo = utils3.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils3.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W2 = this.W;
      for (var i2 = 0; i2 < 32; i2++)
        W2[i2] = msg[start + i2];
      for (; i2 < W2.length; i2 += 2) {
        var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
        var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
        var c1_hi = W2[i2 - 14];
        var c1_lo = W2[i2 - 13];
        var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
        var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
        var c3_hi = W2[i2 - 32];
        var c3_lo = W2[i2 - 31];
        W2[i2] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W2[i2 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W2 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W2.length);
      for (var i2 = 0; i2 < W2.length; i2 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i2];
        var c3_lo = this.k[i2 + 1];
        var c4_hi = W2[i2];
        var c4_lo = W2[i2 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils3.toHex32(this.h, "big");
      else
        return utils3.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ ~xh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ ~xl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ xh & zh ^ yh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ xl & zl ^ yl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
  }
});

// ../../node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils4();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils3.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils3.toHex32(this.h.slice(0, 12), "big");
      else
        return utils3.split32(this.h.slice(0, 12), "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// ../../node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "../../node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils3 = require_utils4();
    var common = require_common();
    var rotl32 = utils3.rotl32;
    var sum32 = utils3.sum32;
    var sum32_3 = utils3.sum32_3;
    var sum32_4 = utils3.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils3.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A2 = this.h[0];
      var B2 = this.h[1];
      var C2 = this.h[2];
      var D2 = this.h[3];
      var E2 = this.h[4];
      var Ah = A2;
      var Bh = B2;
      var Ch = C2;
      var Dh = D2;
      var Eh = E2;
      for (var j2 = 0; j2 < 80; j2++) {
        var T2 = sum32(
          rotl32(
            sum32_4(A2, f2(j2, B2, C2, D2), msg[r2[j2] + start], K2(j2)),
            s2[j2]
          ),
          E2
        );
        A2 = E2;
        E2 = D2;
        D2 = rotl32(C2, 10);
        C2 = B2;
        B2 = T2;
        T2 = sum32(
          rotl32(
            sum32_4(Ah, f2(79 - j2, Bh, Ch, Dh), msg[rh[j2] + start], Kh(j2)),
            sh[j2]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T2;
      }
      T2 = sum32_3(this.h[1], C2, Dh);
      this.h[1] = sum32_3(this.h[2], D2, Eh);
      this.h[2] = sum32_3(this.h[3], E2, Ah);
      this.h[3] = sum32_3(this.h[4], A2, Bh);
      this.h[4] = sum32_3(this.h[0], B2, Ch);
      this.h[0] = T2;
    };
    RIPEMD160.prototype._digest = function digest3(enc) {
      if (enc === "hex")
        return utils3.toHex32(this.h, "little");
      else
        return utils3.split32(this.h, "little");
    };
    function f2(j2, x2, y2, z2) {
      if (j2 <= 15)
        return x2 ^ y2 ^ z2;
      else if (j2 <= 31)
        return x2 & y2 | ~x2 & z2;
      else if (j2 <= 47)
        return (x2 | ~y2) ^ z2;
      else if (j2 <= 63)
        return x2 & z2 | y2 & ~z2;
      else
        return x2 ^ (y2 | ~z2);
    }
    function K2(j2) {
      if (j2 <= 15)
        return 0;
      else if (j2 <= 31)
        return 1518500249;
      else if (j2 <= 47)
        return 1859775393;
      else if (j2 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j2) {
      if (j2 <= 15)
        return 1352829926;
      else if (j2 <= 31)
        return 1548603684;
      else if (j2 <= 47)
        return 1836072691;
      else if (j2 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s2 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// ../../node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils4();
    var assert = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils3.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i2 = key.length; i2 < this.blockSize; i2++)
        key.push(0);
      for (i2 = 0; i2 < key.length; i2++)
        key[i2] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i2 = 0; i2 < key.length; i2++)
        key[i2] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest3(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// ../../node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "../../node_modules/hash.js/lib/hash.js"(exports2) {
    var hash = exports2;
    hash.utils = require_utils4();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// ../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var curves = exports2;
    var hash = require_hash();
    var curve = require_curve();
    var utils3 = require_utils3();
    var assert = utils3.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name6, options) {
      Object.defineProperty(curves, name6, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name6, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e2) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// ../../node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "../../node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var hash = require_hash();
    var utils3 = require_utils2();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils3.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils3.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils3.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i2 = 0; i2 < this.V.length; i2++) {
        this.K[i2] = 0;
        this.V[i2] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils3.toArray(entropy, entropyEnc);
      add = utils3.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils3.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils3.encode(res, enc);
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils3 = require_utils3();
    var assert = utils3.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate4() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign3(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify3(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils3 = require_utils3();
    var assert = utils3.assert;
    function Signature3(options, enc) {
      if (options instanceof Signature3)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature3;
    function Position() {
      this.place = 0;
    }
    function getLength(buf2, p2) {
      var initial = buf2[p2.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
        val <<= 8;
        val |= buf2[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p2.place = off;
      return val;
    }
    function rmPadding(buf2) {
      var i2 = 0;
      var len = buf2.length - 1;
      while (!buf2[i2] && !(buf2[i2 + 1] & 128) && i2 < len) {
        i2++;
      }
      if (i2 === 0) {
        return buf2;
      }
      return buf2.slice(i2);
    }
    Signature3.prototype._importDER = function _importDER(data, enc) {
      data = utils3.toArray(data, enc);
      var p2 = new Position();
      if (data[p2.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p2);
      if (len === false) {
        return false;
      }
      if (len + p2.place !== data.length) {
        return false;
      }
      if (data[p2.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p2);
      if (rlen === false) {
        return false;
      }
      var r2 = data.slice(p2.place, rlen + p2.place);
      p2.place += rlen;
      if (data[p2.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p2);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p2.place) {
        return false;
      }
      var s2 = data.slice(p2.place, slen + p2.place);
      if (r2[0] === 0) {
        if (r2[1] & 128) {
          r2 = r2.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r2);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature3.prototype.toDER = function toDER(enc) {
      var r2 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r2[0] & 128)
        r2 = [0].concat(r2);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r2 = rmPadding(r2);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r2.length);
      arr = arr.concat(r2);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils3.encode(res, enc);
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils3 = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils3.assert;
    var KeyPair = require_key();
    var Signature3 = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign3(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k2 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k2 = this._truncateToN(k2, true);
        if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k2);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r2 = kpX.umod(this.n);
        if (r2.cmpn(0) === 0)
          continue;
        var s2 = k2.invm(this.n).mul(r2.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature3({ r: r2, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify3(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature3(signature, "hex");
      var r2 = signature.r;
      var s2 = signature.s;
      if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r2).umod(this.n);
      var p2;
      if (!this.curve._maxwellTrick) {
        p2 = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p2.isInfinity())
          return false;
        return p2.getX().umod(this.n).cmp(r2) === 0;
      }
      p2 = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.eqXToP(r2);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j2, enc) {
      assert((3 & j2) === j2, "The recovery param is more than two bits");
      signature = new Signature3(signature, enc);
      var n2 = this.n;
      var e2 = new BN(msg);
      var r2 = signature.r;
      var s2 = signature.s;
      var isYOdd = j2 & 1;
      var isSecondKey = j2 >> 1;
      if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
      else
        r2 = this.curve.pointFromX(r2, isYOdd);
      var rInv = signature.r.invm(n2);
      var s1 = n2.sub(e2).mul(rInv).umod(n2);
      var s22 = s2.mul(rInv).umod(n2);
      return this.g.mulAdd(s1, r2, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e2, signature, Q2, enc) {
      signature = new Signature3(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i2 = 0; i2 < 4; i2++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e2, signature, i2);
        } catch (e3) {
          continue;
        }
        if (Qprime.eq(Q2))
          return i2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var utils3 = require_utils3();
    var assert = utils3.assert;
    var parseBytes = utils3.parseBytes;
    var cachedProperty = utils3.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a2 = hash.slice(0, eddsa.encodingLength);
      a2[0] &= 248;
      a2[lastIx] &= 127;
      a2[lastIx] |= 64;
      return a2;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign3(message2) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message2, this);
    };
    KeyPair.prototype.verify = function verify3(message2, sig) {
      return this.eddsa.verify(message2, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils3.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils3.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils3 = require_utils3();
    var assert = utils3.assert;
    var cachedProperty = utils3.cachedProperty;
    var parseBytes = utils3.parseBytes;
    function Signature3(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature3, "S", function S2() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature3, "R", function R2() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature3, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature3, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature3.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature3.prototype.toHex = function toHex3() {
      return utils3.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature3;
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils3 = require_utils3();
    var assert = utils3.assert;
    var parseBytes = utils3.parseBytes;
    var KeyPair = require_key2();
    var Signature3 = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign3(message2, secret) {
      message2 = parseBytes(message2);
      var key = this.keyFromSecret(secret);
      var r2 = this.hashInt(key.messagePrefix(), message2);
      var R2 = this.g.mul(r2);
      var Rencoded = this.encodePoint(R2);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message2).mul(key.priv());
      var S2 = r2.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R2, S: S2, Rencoded });
    };
    EDDSA.prototype.verify = function verify3(message2, sig, pub) {
      message2 = parseBytes(message2);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h2 = this.hashInt(sig.Rencoded(), key.pubBytes(), message2);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h2));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i2 = 0; i2 < arguments.length; i2++)
        hash2.update(arguments[i2]);
      return utils3.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature3)
        return sig;
      return new Signature3(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils3.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y2 = utils3.intFromLE(normed);
      return this.curve.pointFromY(y2, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils3.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "../../node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var elliptic = exports2;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// ../../node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "../../node_modules/secp256k1/lib/elliptic.js"(exports2, module2) {
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    var BN = ecparams.n.constructor;
    function loadCompressedPublicKey(first2, xbuf) {
      let x2 = new BN(xbuf);
      if (x2.cmp(ecparams.p) >= 0)
        return null;
      x2 = x2.toRed(ecparams.red);
      let y2 = x2.redSqr().redIMul(x2).redIAdd(ecparams.b).redSqrt();
      if (first2 === 3 !== y2.isOdd())
        y2 = y2.redNeg();
      return ec.keyPair({ pub: { x: x2, y: y2 } });
    }
    function loadUncompressedPublicKey(first2, xbuf, ybuf) {
      let x2 = new BN(xbuf);
      let y2 = new BN(ybuf);
      if (x2.cmp(ecparams.p) >= 0 || y2.cmp(ecparams.p) >= 0)
        return null;
      x2 = x2.toRed(ecparams.red);
      y2 = y2.toRed(ecparams.red);
      if ((first2 === 6 || first2 === 7) && y2.isOdd() !== (first2 === 7))
        return null;
      const x3 = x2.redSqr().redIMul(x2);
      if (!y2.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
        return null;
      return ec.keyPair({ pub: { x: x2, y: y2 } });
    }
    function loadPublicKey(pubkey) {
      const first2 = pubkey[0];
      switch (first2) {
        case 2:
        case 3:
          if (pubkey.length !== 33)
            return null;
          return loadCompressedPublicKey(first2, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first2, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i2 = 0; i2 < output.length; ++i2)
        output[i2] = pubkey[i2];
    }
    module2.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn = new BN(seckey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn = new BN(seckey);
        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0)
          return 1;
        bn.iadd(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn.isub(ecparams.n);
        if (bn.isZero())
          return 1;
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        bn.imul(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn = bn.umod(ecparams.n);
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn = new BN(seckey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        const point = ec.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs = new Array(pubkeys.length);
        for (let i2 = 0; i2 < pubkeys.length; ++i2) {
          pairs[i2] = loadPublicKey(pubkeys[i2]);
          if (pairs[i2] === null)
            return 1;
        }
        let point = pairs[0].getPublic();
        for (let i2 = 1; i2 < pairs.length; ++i2)
          point = point.add(pairs[i2].pub);
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0)
          return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
          return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r2 = new BN(sig.subarray(0, 32));
        const s2 = new BN(sig.subarray(32, 64));
        if (r2.cmp(ecparams.n) >= 0 || s2.cmp(ecparams.n) >= 0)
          return 1;
        if (s2.cmp(ec.nh) === 1) {
          sig.set(ecparams.n.sub(s2).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN(sigR).cmp(ecparams.n) >= 0)
          return 1;
        if (new BN(sigS).cmp(ecparams.n) >= 0)
          return 1;
        const { output } = obj;
        let r2 = output.subarray(4, 4 + 33);
        r2[0] = 0;
        r2.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r2[posR] === 0 && !(r2[posR + 1] & 128); --lenR, ++posR)
          ;
        r2 = r2.subarray(posR);
        if (r2[0] & 128)
          return 1;
        if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
          return 1;
        let s2 = output.subarray(6 + 33, 6 + 33 + 33);
        s2[0] = 0;
        s2.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s2[posS] === 0 && !(s2[posS + 1] & 128); --lenS, ++posS)
          ;
        s2 = s2.subarray(posS);
        if (s2[0] & 128)
          return 1;
        if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128))
          return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r2.length;
        output.set(r2, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s2.length;
        output.set(s2, 6 + lenR);
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureImport(output, sig) {
        if (sig.length < 8)
          return 1;
        if (sig.length > 72)
          return 1;
        if (sig[0] !== 48)
          return 1;
        if (sig[1] !== sig.length - 2)
          return 1;
        if (sig[2] !== 2)
          return 1;
        const lenR = sig[3];
        if (lenR === 0)
          return 1;
        if (5 + lenR >= sig.length)
          return 1;
        if (sig[4 + lenR] !== 2)
          return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0)
          return 1;
        if (6 + lenR + lenS !== sig.length)
          return 1;
        if (sig[4] & 128)
          return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
          return 1;
        if (sig[lenR + 6] & 128)
          return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
          return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0)
          sigR = sigR.subarray(1);
        if (sigR.length > 32)
          return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0)
          sigS = sigS.slice(1);
        if (sigS.length > 32)
          throw new Error("S length is too long");
        let r2 = new BN(sigR);
        if (r2.cmp(ecparams.n) >= 0)
          r2 = new BN(0);
        let s2 = new BN(sig.subarray(6 + lenR));
        if (s2.cmp(ecparams.n) >= 0)
          s2 = new BN(0);
        output.set(r2.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s2.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message2, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message2, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid)
              throw new Error("This is the way");
            return new BN(nonce);
          };
        }
        const d2 = new BN(seckey);
        if (d2.cmp(ecparams.n) >= 0 || d2.isZero())
          return 1;
        let sig;
        try {
          sig = ec.sign(message2, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
          return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 2;
        const point = pair.getPublic();
        const isValid = ec.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigr.isZero() || sigs.isZero())
          return 2;
        let point;
        try {
          point = ec.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const scalar = new BN(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
          return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha2562 = ec.hash().update(data2).digest();
          for (let i2 = 0; i2 < 32; ++i2)
            output[i2] = sha2562[i2];
        } else {
          if (!xbuf)
            xbuf = new Uint8Array(32);
          const x2 = point.getX().toArray("be", 32);
          for (let i2 = 0; i2 < 32; ++i2)
            xbuf[i2] = x2[i2];
          if (!ybuf)
            ybuf = new Uint8Array(32);
          const y2 = point.getY().toArray("be", 32);
          for (let i2 = 0; i2 < 32; ++i2)
            ybuf[i2] = y2[i2];
          const hash = hashfn(xbuf, ybuf, data);
          const isValid = hash instanceof Uint8Array && hash.length === output.length;
          if (!isValid)
            return 2;
          output.set(hash);
        }
        return 0;
      }
    };
  }
});

// ../../node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "../../node_modules/secp256k1/elliptic.js"(exports2, module2) {
    module2.exports = require_lib()(require_elliptic2());
  }
});

// ../../node_modules/secp256k1/index.js
var require_secp256k12 = __commonJS({
  "../../node_modules/secp256k1/index.js"(exports2, module2) {
    try {
      module2.exports = require_bindings();
    } catch (err) {
      module2.exports = require_elliptic3();
    }
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "../../node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject2;
  }
});

// ../../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e2 = { type, target: this };
          this.onabort(e2);
          this._listeners.forEach((f2) => f2(e2), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f2) => f2 !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code9 = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code9)) {
        warn(code9, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code9 = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code9)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code9, `${method} method`, `cache.${instead}()`, get2);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code9 = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code9)) {
        const { prototype } = LRUCache;
        const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code9, `${field} property`, `cache.${instead}`, get2);
      }
    };
    var emitWarning = (...a2) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a2) : console.error(...a2);
    };
    var shouldWarn = (code9) => !warned.has(code9);
    var warn = (code9, what, instead, fn) => {
      warned.add(code9);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code9, fn);
    };
    var isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n2) {
        this.heap[this.length++] = n2;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet
        } = options;
        const { length: length5, maxAge, stale } = options instanceof LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length5;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError(
              "maxSize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code9 = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code9)) {
            warned.add(code9);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code9, LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length5) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t2 = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t2.unref) {
              t2.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n2 = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n2;
            const t2 = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t2.unref) {
              t2.unref();
            }
          }
          return n2;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => this.calculatedSize -= this.sizes[index];
        this.requireSize = (k2, v2, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v2, k2);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, v2, k2, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, v2, k2, size) {
      }
      requireSize(k2, v2, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.tail; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.head) {
              break;
            } else {
              i2 = this.prev[i2];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i2 = this.head; true; ) {
            if (!this.isValidIndex(i2)) {
              break;
            }
            if (allowStale || !this.isStale(i2)) {
              yield i2;
            }
            if (i2 === this.tail) {
              break;
            } else {
              i2 = this.next[i2];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i2 of this.indexes()) {
          yield [this.keyList[i2], this.valList[i2]];
        }
      }
      *rentries() {
        for (const i2 of this.rindexes()) {
          yield [this.keyList[i2], this.valList[i2]];
        }
      }
      *keys() {
        for (const i2 of this.indexes()) {
          yield this.keyList[i2];
        }
      }
      *rkeys() {
        for (const i2 of this.rindexes()) {
          yield this.keyList[i2];
        }
      }
      *values() {
        for (const i2 of this.indexes()) {
          yield this.valList[i2];
        }
      }
      *rvalues() {
        for (const i2 of this.rindexes()) {
          yield this.valList[i2];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i2 of this.indexes()) {
          if (fn(this.valList[i2], this.keyList[i2], this)) {
            return this.get(this.keyList[i2], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i2 of this.indexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i2 of this.rindexes()) {
          fn.call(thisp, this.valList[i2], this.keyList[i2], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i2 of this.rindexes({ allowStale: true })) {
          if (this.isStale(i2)) {
            this.delete(this.keyList[i2]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i2 of this.indexes({ allowStale: true })) {
          const key = this.keyList[i2];
          const v2 = this.valList[i2];
          const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i2];
            const age = perf.now() - this.starts[i2];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i2];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v2, k2, reason) {
      }
      set(k2, v2, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k2, v2, size, sizeCalculation);
        let index = this.size === 0 ? void 0 : this.keyMap.get(k2);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k2;
          this.valList[index] = v2;
          this.keyMap.set(k2, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, v2, k2, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v2 !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k2, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k2, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v2;
            this.addItemSize(index, v2, k2, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k2 = this.keyList[head];
        const v2 = this.valList[head];
        if (this.isBackgroundFetch(v2)) {
          v2.__abortController.abort();
        } else {
          this.dispose(v2, k2, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v2, k2, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k2);
        this.size--;
        return head;
      }
      has(k2, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k2);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k2, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k2);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          return this.valList[index];
        }
      }
      backgroundFetch(k2, index, options, context) {
        const v2 = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v2)) {
          return v2;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v3) => {
          if (!ac.signal.aborted) {
            this.set(k2, v3, fetchOpts.options);
          }
          return v3;
        };
        const eb = (er) => {
          if (this.valList[index] === p2) {
            const del = !options.noDeleteOnFetchRejection || p2.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k2);
            } else {
              this.valList[index] = p2.__staleWhileFetching;
            }
          }
          if (p2.__returned === p2) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k2, v2, fetchOpts));
        const p2 = new Promise(pcall).then(cb, eb);
        p2.__abortController = ac;
        p2.__staleWhileFetching = v2;
        p2.__returned = null;
        if (index === void 0) {
          this.set(k2, p2, fetchOpts.options);
          index = this.keyMap.get(k2);
        } else {
          this.valList[index] = p2;
        }
        return p2;
      }
      isBackgroundFetch(p2) {
        return p2 && typeof p2 === "object" && typeof p2.then === "function" && Object.prototype.hasOwnProperty.call(
          p2,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p2, "__returned") && (p2.__returned === p2 || p2.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k2, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k2, { allowStale, updateAgeOnGet, noDeleteOnStaleGet });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k2);
        if (index === void 0) {
          const p2 = this.backgroundFetch(k2, index, options, fetchContext);
          return p2.__returned = p2;
        } else {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            return allowStale && v2.__staleWhileFetching !== void 0 ? v2.__staleWhileFetching : v2.__returned = v2;
          }
          if (!this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v2;
          }
          const p2 = this.backgroundFetch(k2, index, options, fetchContext);
          return allowStale && p2.__staleWhileFetching !== void 0 ? p2.__staleWhileFetching : p2.__returned = p2;
        }
      }
      get(k2, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k2);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k2);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p2, n2) {
        this.prev[n2] = p2;
        this.next[p2] = n2;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k2) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k2);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v2 = this.valList[index];
              if (this.isBackgroundFetch(v2)) {
                v2.__abortController.abort();
              } else {
                this.dispose(v2, k2, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v2, k2, "delete"]);
                }
              }
              this.keyMap.delete(k2);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v2 = this.valList[index];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort();
          } else {
            const k2 = this.keyList[index];
            this.dispose(v2, k2, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v2, k2, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// ../../node_modules/varint/encode.js
var require_encode = __commonJS({
  "../../node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode17;
    var MSB5 = 128;
    var REST5 = 127;
    var MSBALL5 = ~REST5;
    var INT5 = Math.pow(2, 31);
    function encode17(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode17.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT5) {
        out[offset++] = num & 255 | MSB5;
        num /= 128;
      }
      while (num & MSBALL5) {
        out[offset++] = num & 255 | MSB5;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode17.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/varint/decode.js
var require_decode = __commonJS({
  "../../node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read5;
    var MSB5 = 128;
    var REST5 = 127;
    function read5(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
      do {
        if (counter >= l2 || shift > 49) {
          read5.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b2 = buf2[counter++];
        res += shift < 28 ? (b2 & REST5) << shift : (b2 & REST5) * Math.pow(2, shift);
        shift += 7;
      } while (b2 >= MSB5);
      read5.bytes = counter - offset;
      return res;
    }
  }
});

// ../../node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/varint/length.js"(exports2, module2) {
    var N15 = Math.pow(2, 7);
    var N25 = Math.pow(2, 14);
    var N35 = Math.pow(2, 21);
    var N45 = Math.pow(2, 28);
    var N55 = Math.pow(2, 35);
    var N65 = Math.pow(2, 42);
    var N75 = Math.pow(2, 49);
    var N85 = Math.pow(2, 56);
    var N95 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
    };
  }
});

// ../../node_modules/varint/index.js
var require_varint3 = __commonJS({
  "../../node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// ../../node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign3(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function evenRound(x2) {
      if (x2 % 1 === 0.5 && (x2 & 1) === 0) {
        return Math.floor(x2);
      } else {
        return Math.round(x2);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V2, opts) {
        if (!opts)
          opts = {};
        let x2 = +V2;
        if (opts.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw new TypeError("Argument is not a finite number");
          }
          x2 = sign3(x2) * Math.floor(Math.abs(x2));
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x2;
        }
        if (!isNaN(x2) && opts.clamp) {
          x2 = evenRound(x2);
          if (x2 < lowerBound)
            x2 = lowerBound;
          if (x2 > upperBound)
            x2 = upperBound;
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        x2 = sign3(x2) * Math.floor(Math.abs(x2));
        x2 = x2 % moduloVal;
        if (!typeOpts.unsigned && x2 >= moduloBound) {
          return x2 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x2 < 0) {
            x2 += moduloVal;
          } else if (x2 === -0) {
            return 0;
          }
        }
        return x2;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V2) {
      const x2 = +V2;
      if (!Number.isFinite(x2)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x2;
    };
    conversions["unrestricted double"] = function(V2) {
      const x2 = +V2;
      if (isNaN(x2)) {
        throw new TypeError("Argument is NaN");
      }
      return x2;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V2, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V2 === null) {
        return "";
      }
      return String(V2);
    };
    conversions["ByteString"] = function(V2, opts) {
      const x2 = String(V2);
      let c2 = void 0;
      for (let i2 = 0; (c2 = x2.codePointAt(i2)) !== void 0; ++i2) {
        if (c2 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x2;
    };
    conversions["USVString"] = function(V2) {
      const S2 = String(V2);
      const n2 = S2.length;
      const U2 = [];
      for (let i2 = 0; i2 < n2; ++i2) {
        const c2 = S2.charCodeAt(i2);
        if (c2 < 55296 || c2 > 57343) {
          U2.push(String.fromCodePoint(c2));
        } else if (56320 <= c2 && c2 <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else {
          if (i2 === n2 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            const d2 = S2.charCodeAt(i2 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a2 = c2 & 1023;
              const b2 = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
              ++i2;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U2.join("");
    };
    conversions["Date"] = function(V2, opts) {
      if (!(V2 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V2)) {
        return void 0;
      }
      return V2;
    };
    conversions["RegExp"] = function(V2, opts) {
      if (!(V2 instanceof RegExp)) {
        V2 = new RegExp(V2);
      }
      return V2;
    };
  }
});

// ../../node_modules/whatwg-url/lib/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// ../../node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../../node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../../node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../../node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string2) {
      return string2.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2) {
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e2) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e2) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i2 = 0; i2 < labels.length; ++i2) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../../node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../../node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at2(input, idx) {
      const c2 = input[idx];
      return isNaN(c2) ? void 0 : String.fromCodePoint(c2);
    }
    function isASCIIDigit(c2) {
      return c2 >= 48 && c2 <= 57;
    }
    function isASCIIAlpha(c2) {
      return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122;
    }
    function isASCIIAlphanumeric(c2) {
      return isASCIIAlpha(c2) || isASCIIDigit(c2);
    }
    function isASCIIHex(c2) {
      return isASCIIDigit(c2) || c2 >= 65 && c2 <= 70 || c2 >= 97 && c2 <= 102;
    }
    function isSingleDot(buffer2) {
      return buffer2 === "." || buffer2.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer2) {
      buffer2 = buffer2.toLowerCase();
      return buffer2 === ".." || buffer2 === "%2e." || buffer2 === ".%2e" || buffer2 === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string2) {
      return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && (string2[1] === ":" || string2[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string2) {
      return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && string2[1] === ":";
    }
    function containsForbiddenHostCodePoint(string2) {
      return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string2) {
      return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c2) {
      let hex = c2.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c2) {
      const buf2 = new Buffer(c2);
      let str = "";
      for (let i2 = 0; i2 < buf2.length; ++i2) {
        str += percentEncode(buf2[i2]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2) {
        if (input[i2] !== 37) {
          output.push(input[i2]);
        } else if (input[i2] === 37 && isASCIIHex(input[i2 + 1]) && isASCIIHex(input[i2 + 2])) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else {
          output.push(input[i2]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c2) {
      return c2 <= 31 || c2 > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c2) {
      return isC0ControlPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c2) {
      return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
    }
    function percentEncodeChar(c2, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c2);
      if (encodeSetPredicate(c2)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R2 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R2 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R2 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R2 === 10 ? /[^0-9]/ : R2 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R2);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n2 = parseIPv4Number(part);
        if (n2 === failure) {
          return input;
        }
        numbers.push(n2);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2) {
        if (numbers[i2] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n2 of numbers) {
        ipv4 += n2 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n2 = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n2 % 256) + output;
        if (i2 !== 4) {
          output = "." + output;
        }
        n2 = Math.floor(n2 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length5 = 0;
        while (length5 < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at2(input, pointer), 16);
          ++pointer;
          ++length5;
        }
        if (input[pointer] === 46) {
          if (length5 === 0) {
            return failure;
          }
          pointer -= length5;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at2(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2) {
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i2;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path = url.path;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string2) {
      return /^[A-Za-z]:$/.test(string2);
    }
    function URLStateMachine(input, base6, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base6 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c2 = this.input[this.pointer];
        const cStr = isNaN(c2) ? void 0 : String.fromCodePoint(c2);
        const ret = this["parse " + this.state](c2, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c2, cStr) {
      if (isASCIIAlpha(c2)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
      if (isASCIIAlphanumeric(c2) || c2 === 43 || c2 === 45 || c2 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c2 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
      if (this.base === null || this.base.cannotBeABaseURL && c2 !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c2 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c2) {
      if (c2 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c2)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c2 === 47) {
        this.state = "relative slash";
      } else if (c2 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c2 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c2) {
      if (isSpecial(this.url) && (c2 === 47 || c2 === 92)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c2 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c2) {
      if (c2 !== 47 && c2 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c2, cStr) {
      if (c2 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c2, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c2 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c2 === 91) {
          this.arrFlag = true;
        } else if (c2 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
      if (isASCIIDigit(c2)) {
        this.buffer += cStr;
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c2) {
      this.url.scheme = "file";
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c2)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c2 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c2 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c2, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c2) {
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c2, cStr) {
      if (isNaN(c2) || c2 === 47 || c2 === 92 || c2 === 63 || c2 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c2) {
      if (isSpecial(this.url)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c2 !== 47 && c2 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c2 !== void 0) {
        this.state = "path";
        if (c2 !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c2) {
      if (isNaN(c2) || c2 === 47 || isSpecial(this.url) && c2 === 92 || !this.stateOverride && (c2 === 63 || c2 === 35)) {
        if (isSpecial(this.url) && c2 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c2 === void 0 || c2 === 63 || c2 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c2 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c2, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c2) {
      if (c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c2) && c2 !== 37) {
          this.parseError = true;
        }
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c2)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c2, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
      if (isNaN(c2) || !this.stateOverride && c2 === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer2 = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer2.length; ++i2) {
          if (buffer2[i2] < 33 || buffer2[i2] > 126 || buffer2[i2] === 34 || buffer2[i2] === 35 || buffer2[i2] === 60 || buffer2[i2] === 62) {
            this.url.query += percentEncode(buffer2[i2]);
          } else {
            this.url.query += String.fromCodePoint(buffer2[i2]);
          }
        }
        this.buffer = "";
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
      if (isNaN(c2)) {
      } else if (c2 === 0) {
        this.parseError = true;
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c2, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string2 of url.path) {
          output += "/" + string2;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e2) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.username += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.password += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../../node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base6 = constructorArgs[1];
        let parsedBase = null;
        if (base6 !== void 0) {
          parsedBase = usm.basicURLParse(base6);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v2) {
        const parsedURL = usm.basicURLParse(v2);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v2) {
        usm.basicURLParse(v2 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v2);
      }
      get password() {
        return this._url.password;
      }
      set password(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v2);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v2 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v2) {
        const url = this._url;
        if (v2 === "") {
          url.query = null;
          return;
        }
        const input = v2[0] === "?" ? v2.substring(1) : v2;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v2) {
        if (v2 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v2[0] === "#" ? v2.substring(1) : v2;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../../node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib2();
    var utils3 = require_utils5();
    var Impl = require_URL_impl();
    var impl = utils3.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
        args[i2] = arguments[i2];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2) {
        args[i2] = arguments[i2];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].href = V2;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].protocol = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].username = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].password = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].host = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hostname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].port = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].pathname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].search = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hash = V2;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils3.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// ../../node_modules/node-fetch/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable4 = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a2 = blobParts;
          const length5 = Number(a2.length);
          for (let i2 = 0; i2 < length5; i2++) {
            const element = a2[i2];
            let buffer2;
            if (element instanceof Buffer) {
              buffer2 = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer2 = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer2 = Buffer.from(element);
            } else if (element instanceof Blob) {
              buffer2 = element[BUFFER];
            } else {
              buffer2 = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer2.length;
            buffers.push(buffer2);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf2 = this[BUFFER];
        const ab = buf2.buffer.slice(buf2.byteOffset, buf2.byteOffset + buf2.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable4();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer2 = this[BUFFER];
        const slicedBuffer = buffer2.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message2, type, systemError) {
      Error.call(this, message2);
      this.message = message2;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e2) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf2) {
          return buf2.buffer.slice(buf2.byteOffset, buf2.byteOffset + buf2.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct2 = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf2) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct2.toLowerCase()
            }),
            {
              [BUFFER]: buf2
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer2) {
          try {
            return JSON.parse(buffer2.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer2) {
          return buffer2.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer2) {
          return convertBody(buffer2, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name6 of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name6 in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name6);
          Object.defineProperty(proto, name6, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve5, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve5(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer2, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct2 = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct2) {
        res = /charset=([^;]*)/i.exec(ct2);
      }
      str = buffer2.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer2, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name6) {
      name6 = `${name6}`;
      if (invalidTokenRegex.test(name6) || name6 === "") {
        throw new TypeError(`${name6} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name6) {
      name6 = name6.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name6) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name6) {
        name6 = `${name6}`;
        validateName(name6);
        const key = find(this[MAP], name6);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name6 = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name6, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name6, value) {
        name6 = `${name6}`;
        value = `${value}`;
        validateName(name6);
        validateValue(value);
        const key = find(this[MAP], name6);
        this[MAP][key !== void 0 ? key : name6] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name6, value) {
        name6 = `${name6}`;
        value = `${value}`;
        validateName(name6);
        validateValue(value);
        const key = find(this[MAP], name6);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name6] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name6) {
        name6 = `${name6}`;
        validateName(name6);
        return find(this[MAP], name6) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name6) {
        name6 = `${name6}`;
        validateName(name6);
        const key = find(this[MAP], name6);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k2) {
        return k2.toLowerCase();
      } : kind === "value" ? function(k2) {
        return headers[MAP][k2].join(", ");
      } : function(k2) {
        return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name6 of Object.keys(obj)) {
        if (invalidTokenRegex.test(name6)) {
          continue;
        }
        if (Array.isArray(obj[name6])) {
          for (const val of obj[name6]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name6] === void 0) {
              headers[MAP][name6] = [val];
            } else {
              headers[MAP][name6].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name6])) {
          headers[MAP][name6] = [obj[name6]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message2) {
      Error.call(this, message2);
      this.type = "aborted";
      this.message = message2;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve5, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL)) {
                  for (const name6 of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name6);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve5(fetch2(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve5(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          response = new Response(body, response_options);
          resolve5(response);
        });
        writeToStream(req, request);
      });
    }
    fetch2.isRedirect = function(code9) {
      return code9 === 301 || code9 === 302 || code9 === 303 || code9 === 307 || code9 === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports2 = fetch2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
  }
});

// ../../node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "../../node_modules/cross-fetch/dist/node-ponyfill.js"(exports2, module2) {
    var nodeFetch = require_lib3();
    var realFetch = nodeFetch.default || nodeFetch;
    var fetch2 = function(url, options) {
      if (/^\/\//.test(url)) {
        url = "https:" + url;
      }
      return realFetch.call(this, url, options);
    };
    fetch2.ponyfill = true;
    module2.exports = exports2 = fetch2;
    exports2.fetch = fetch2;
    exports2.Headers = nodeFetch.Headers;
    exports2.Request = nodeFetch.Request;
    exports2.Response = nodeFetch.Response;
    exports2.default = fetch2;
  }
});

// ../../node_modules/ulid/dist/index.umd.js
var require_index_umd = __commonJS({
  "../../node_modules/ulid/dist/index.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.ULID = {});
    })(exports2, function(exports3) {
      "use strict";
      function createError(message2) {
        var err = new Error(message2);
        err.source = "ulid";
        return err;
      }
      var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
      var ENCODING_LEN = ENCODING.length;
      var TIME_MAX = Math.pow(2, 48) - 1;
      var TIME_LEN = 10;
      var RANDOM_LEN = 16;
      function replaceCharAt(str, index, char) {
        if (index > str.length - 1) {
          return str;
        }
        return str.substr(0, index) + char + str.substr(index + 1);
      }
      function incrementBase32(str) {
        var done = void 0;
        var index = str.length;
        var char = void 0;
        var charIndex = void 0;
        var maxCharIndex = ENCODING_LEN - 1;
        while (!done && index-- >= 0) {
          char = str[index];
          charIndex = ENCODING.indexOf(char);
          if (charIndex === -1) {
            throw createError("incorrectly encoded string");
          }
          if (charIndex === maxCharIndex) {
            str = replaceCharAt(str, index, ENCODING[0]);
            continue;
          }
          done = replaceCharAt(str, index, ENCODING[charIndex + 1]);
        }
        if (typeof done === "string") {
          return done;
        }
        throw createError("cannot increment this string");
      }
      function randomChar(prng) {
        var rand = Math.floor(prng() * ENCODING_LEN);
        if (rand === ENCODING_LEN) {
          rand = ENCODING_LEN - 1;
        }
        return ENCODING.charAt(rand);
      }
      function encodeTime(now, len) {
        if (isNaN(now)) {
          throw new Error(now + " must be a number");
        }
        if (now > TIME_MAX) {
          throw createError("cannot encode time greater than " + TIME_MAX);
        }
        if (now < 0) {
          throw createError("time must be positive");
        }
        if (Number.isInteger(now) === false) {
          throw createError("time must be an integer");
        }
        var mod4 = void 0;
        var str = "";
        for (; len > 0; len--) {
          mod4 = now % ENCODING_LEN;
          str = ENCODING.charAt(mod4) + str;
          now = (now - mod4) / ENCODING_LEN;
        }
        return str;
      }
      function encodeRandom(len, prng) {
        var str = "";
        for (; len > 0; len--) {
          str = randomChar(prng) + str;
        }
        return str;
      }
      function decodeTime(id) {
        if (id.length !== TIME_LEN + RANDOM_LEN) {
          throw createError("malformed ulid");
        }
        var time = id.substr(0, TIME_LEN).split("").reverse().reduce(function(carry, char, index) {
          var encodingIndex = ENCODING.indexOf(char);
          if (encodingIndex === -1) {
            throw createError("invalid character found: " + char);
          }
          return carry += encodingIndex * Math.pow(ENCODING_LEN, index);
        }, 0);
        if (time > TIME_MAX) {
          throw createError("malformed ulid, timestamp too large");
        }
        return time;
      }
      function detectPrng() {
        var allowInsecure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var root = arguments[1];
        if (!root) {
          root = typeof window !== "undefined" ? window : null;
        }
        var browserCrypto = root && (root.crypto || root.msCrypto);
        if (browserCrypto) {
          return function() {
            var buffer2 = new Uint8Array(1);
            browserCrypto.getRandomValues(buffer2);
            return buffer2[0] / 255;
          };
        } else {
          try {
            var nodeCrypto3 = require("crypto");
            return function() {
              return nodeCrypto3.randomBytes(1).readUInt8() / 255;
            };
          } catch (e2) {
          }
        }
        if (allowInsecure) {
          try {
            console.error("secure crypto unusable, falling back to insecure Math.random()!");
          } catch (e2) {
          }
          return function() {
            return Math.random();
          };
        }
        throw createError("secure crypto unusable, insecure Math.random not allowed");
      }
      function factory(currPrng) {
        if (!currPrng) {
          currPrng = detectPrng();
        }
        return function ulid2(seedTime) {
          if (isNaN(seedTime)) {
            seedTime = Date.now();
          }
          return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);
        };
      }
      function monotonicFactory2(currPrng) {
        if (!currPrng) {
          currPrng = detectPrng();
        }
        var lastTime = 0;
        var lastRandom = void 0;
        return function ulid2(seedTime) {
          if (isNaN(seedTime)) {
            seedTime = Date.now();
          }
          if (seedTime <= lastTime) {
            var incrementedRandom = lastRandom = incrementBase32(lastRandom);
            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;
          }
          lastTime = seedTime;
          var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);
          return encodeTime(seedTime, TIME_LEN) + newRandom;
        };
      }
      var ulid = factory();
      exports3.replaceCharAt = replaceCharAt;
      exports3.incrementBase32 = incrementBase32;
      exports3.randomChar = randomChar;
      exports3.encodeTime = encodeTime;
      exports3.encodeRandom = encodeRandom;
      exports3.decodeTime = decodeTime;
      exports3.detectPrng = detectPrng;
      exports3.factory = factory;
      exports3.monotonicFactory = monotonicFactory2;
      exports3.ulid = ulid;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/es6-promise/dist/es6-promise.js
var require_es6_promise = __commonJS({
  "../../node_modules/es6-promise/dist/es6-promise.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.ES6Promise = factory();
    })(exports2, function() {
      "use strict";
      function objectOrFunction(x2) {
        var type = typeof x2;
        return x2 !== null && (type === "object" || type === "function");
      }
      function isFunction(x2) {
        return typeof x2 === "function";
      }
      var _isArray = void 0;
      if (Array.isArray) {
        _isArray = Array.isArray;
      } else {
        _isArray = function(x2) {
          return Object.prototype.toString.call(x2) === "[object Array]";
        };
      }
      var isArray = _isArray;
      var len = 0;
      var vertxNext = void 0;
      var customSchedulerFn = void 0;
      var asap = function asap2(callback, arg) {
        queue[len] = callback;
        queue[len + 1] = arg;
        len += 2;
        if (len === 2) {
          if (customSchedulerFn) {
            customSchedulerFn(flush2);
          } else {
            scheduleFlush();
          }
        }
      };
      function setScheduler(scheduleFn) {
        customSchedulerFn = scheduleFn;
      }
      function setAsap(asapFn) {
        asap = asapFn;
      }
      var browserWindow = typeof window !== "undefined" ? window : void 0;
      var browserGlobal = browserWindow || {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var isNode = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
      var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
      function useNextTick() {
        return function() {
          return process.nextTick(flush2);
        };
      }
      function useVertxTimer() {
        if (typeof vertxNext !== "undefined") {
          return function() {
            vertxNext(flush2);
          };
        }
        return useSetTimeout();
      }
      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush2);
        var node = document.createTextNode("");
        observer.observe(node, { characterData: true });
        return function() {
          node.data = iterations = ++iterations % 2;
        };
      }
      function useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = flush2;
        return function() {
          return channel.port2.postMessage(0);
        };
      }
      function useSetTimeout() {
        var globalSetTimeout = setTimeout;
        return function() {
          return globalSetTimeout(flush2, 1);
        };
      }
      var queue = new Array(1e3);
      function flush2() {
        for (var i2 = 0; i2 < len; i2 += 2) {
          var callback = queue[i2];
          var arg = queue[i2 + 1];
          callback(arg);
          queue[i2] = void 0;
          queue[i2 + 1] = void 0;
        }
        len = 0;
      }
      function attemptVertx() {
        try {
          var vertx = Function("return this")().require("vertx");
          vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return useVertxTimer();
        } catch (e2) {
          return useSetTimeout();
        }
      }
      var scheduleFlush = void 0;
      if (isNode) {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else if (isWorker) {
        scheduleFlush = useMessageChannel();
      } else if (browserWindow === void 0 && typeof require === "function") {
        scheduleFlush = attemptVertx();
      } else {
        scheduleFlush = useSetTimeout();
      }
      function then(onFulfillment, onRejection) {
        var parent = this;
        var child = new this.constructor(noop);
        if (child[PROMISE_ID] === void 0) {
          makePromise(child);
        }
        var _state = parent._state;
        if (_state) {
          var callback = arguments[_state - 1];
          asap(function() {
            return invokeCallback(_state, child, callback, parent._result);
          });
        } else {
          subscribe(parent, child, onFulfillment, onRejection);
        }
        return child;
      }
      function resolve$1(object) {
        var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor(noop);
        resolve5(promise, object);
        return promise;
      }
      var PROMISE_ID = Math.random().toString(36).substring(2);
      function noop() {
      }
      var PENDING = void 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      function selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.");
      }
      function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
        try {
          then$$1.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e2) {
          return e2;
        }
      }
      function handleForeignThenable(promise, thenable, then$$1) {
        asap(function(promise2) {
          var sealed = false;
          var error = tryThen(then$$1, thenable, function(value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              resolve5(promise2, value);
            } else {
              fulfill(promise2, value);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            reject(promise2, reason);
          }, "Settle: " + (promise2._label || " unknown promise"));
          if (!sealed && error) {
            sealed = true;
            reject(promise2, error);
          }
        }, promise);
      }
      function handleOwnThenable(promise, thenable) {
        if (thenable._state === FULFILLED) {
          fulfill(promise, thenable._result);
        } else if (thenable._state === REJECTED) {
          reject(promise, thenable._result);
        } else {
          subscribe(thenable, void 0, function(value) {
            return resolve5(promise, value);
          }, function(reason) {
            return reject(promise, reason);
          });
        }
      }
      function handleMaybeThenable(promise, maybeThenable, then$$1) {
        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
          handleOwnThenable(promise, maybeThenable);
        } else {
          if (then$$1 === void 0) {
            fulfill(promise, maybeThenable);
          } else if (isFunction(then$$1)) {
            handleForeignThenable(promise, maybeThenable, then$$1);
          } else {
            fulfill(promise, maybeThenable);
          }
        }
      }
      function resolve5(promise, value) {
        if (promise === value) {
          reject(promise, selfFulfillment());
        } else if (objectOrFunction(value)) {
          var then$$1 = void 0;
          try {
            then$$1 = value.then;
          } catch (error) {
            reject(promise, error);
            return;
          }
          handleMaybeThenable(promise, value, then$$1);
        } else {
          fulfill(promise, value);
        }
      }
      function publishRejection(promise) {
        if (promise._onerror) {
          promise._onerror(promise._result);
        }
        publish(promise);
      }
      function fulfill(promise, value) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._result = value;
        promise._state = FULFILLED;
        if (promise._subscribers.length !== 0) {
          asap(publish, promise);
        }
      }
      function reject(promise, reason) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._state = REJECTED;
        promise._result = reason;
        asap(publishRejection, promise);
      }
      function subscribe(parent, child, onFulfillment, onRejection) {
        var _subscribers = parent._subscribers;
        var length5 = _subscribers.length;
        parent._onerror = null;
        _subscribers[length5] = child;
        _subscribers[length5 + FULFILLED] = onFulfillment;
        _subscribers[length5 + REJECTED] = onRejection;
        if (length5 === 0 && parent._state) {
          asap(publish, parent);
        }
      }
      function publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
          return;
        }
        var child = void 0, callback = void 0, detail = promise._result;
        for (var i2 = 0; i2 < subscribers.length; i2 += 3) {
          child = subscribers[i2];
          callback = subscribers[i2 + settled];
          if (child) {
            invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = true;
        if (hasCallback) {
          try {
            value = callback(detail);
          } catch (e2) {
            succeeded = false;
            error = e2;
          }
          if (promise === value) {
            reject(promise, cannotReturnOwn());
            return;
          }
        } else {
          value = detail;
        }
        if (promise._state !== PENDING) {
        } else if (hasCallback && succeeded) {
          resolve5(promise, value);
        } else if (succeeded === false) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          fulfill(promise, value);
        } else if (settled === REJECTED) {
          reject(promise, value);
        }
      }
      function initializePromise(promise, resolver) {
        try {
          resolver(function resolvePromise(value) {
            resolve5(promise, value);
          }, function rejectPromise(reason) {
            reject(promise, reason);
          });
        } catch (e2) {
          reject(promise, e2);
        }
      }
      var id = 0;
      function nextId() {
        return id++;
      }
      function makePromise(promise) {
        promise[PROMISE_ID] = id++;
        promise._state = void 0;
        promise._result = void 0;
        promise._subscribers = [];
      }
      function validationError() {
        return new Error("Array Methods must be provided an Array");
      }
      var Enumerator = function() {
        function Enumerator2(Constructor, input) {
          this._instanceConstructor = Constructor;
          this.promise = new Constructor(noop);
          if (!this.promise[PROMISE_ID]) {
            makePromise(this.promise);
          }
          if (isArray(input)) {
            this.length = input.length;
            this._remaining = input.length;
            this._result = new Array(this.length);
            if (this.length === 0) {
              fulfill(this.promise, this._result);
            } else {
              this.length = this.length || 0;
              this._enumerate(input);
              if (this._remaining === 0) {
                fulfill(this.promise, this._result);
              }
            }
          } else {
            reject(this.promise, validationError());
          }
        }
        Enumerator2.prototype._enumerate = function _enumerate(input) {
          for (var i2 = 0; this._state === PENDING && i2 < input.length; i2++) {
            this._eachEntry(input[i2], i2);
          }
        };
        Enumerator2.prototype._eachEntry = function _eachEntry(entry, i2) {
          var c2 = this._instanceConstructor;
          var resolve$$1 = c2.resolve;
          if (resolve$$1 === resolve$1) {
            var _then = void 0;
            var error = void 0;
            var didError = false;
            try {
              _then = entry.then;
            } catch (e2) {
              didError = true;
              error = e2;
            }
            if (_then === then && entry._state !== PENDING) {
              this._settledAt(entry._state, i2, entry._result);
            } else if (typeof _then !== "function") {
              this._remaining--;
              this._result[i2] = entry;
            } else if (c2 === Promise$1) {
              var promise = new c2(noop);
              if (didError) {
                reject(promise, error);
              } else {
                handleMaybeThenable(promise, entry, _then);
              }
              this._willSettleAt(promise, i2);
            } else {
              this._willSettleAt(new c2(function(resolve$$12) {
                return resolve$$12(entry);
              }), i2);
            }
          } else {
            this._willSettleAt(resolve$$1(entry), i2);
          }
        };
        Enumerator2.prototype._settledAt = function _settledAt(state, i2, value) {
          var promise = this.promise;
          if (promise._state === PENDING) {
            this._remaining--;
            if (state === REJECTED) {
              reject(promise, value);
            } else {
              this._result[i2] = value;
            }
          }
          if (this._remaining === 0) {
            fulfill(promise, this._result);
          }
        };
        Enumerator2.prototype._willSettleAt = function _willSettleAt(promise, i2) {
          var enumerator = this;
          subscribe(promise, void 0, function(value) {
            return enumerator._settledAt(FULFILLED, i2, value);
          }, function(reason) {
            return enumerator._settledAt(REJECTED, i2, reason);
          });
        };
        return Enumerator2;
      }();
      function all2(entries) {
        return new Enumerator(this, entries).promise;
      }
      function race(entries) {
        var Constructor = this;
        if (!isArray(entries)) {
          return new Constructor(function(_2, reject2) {
            return reject2(new TypeError("You must pass an array to race."));
          });
        } else {
          return new Constructor(function(resolve6, reject2) {
            var length5 = entries.length;
            for (var i2 = 0; i2 < length5; i2++) {
              Constructor.resolve(entries[i2]).then(resolve6, reject2);
            }
          });
        }
      }
      function reject$1(reason) {
        var Constructor = this;
        var promise = new Constructor(noop);
        reject(promise, reason);
        return promise;
      }
      function needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      }
      function needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var Promise$1 = function() {
        function Promise2(resolver) {
          this[PROMISE_ID] = nextId();
          this._result = this._state = void 0;
          this._subscribers = [];
          if (noop !== resolver) {
            typeof resolver !== "function" && needsResolver();
            this instanceof Promise2 ? initializePromise(this, resolver) : needsNew();
          }
        }
        Promise2.prototype.catch = function _catch(onRejection) {
          return this.then(null, onRejection);
        };
        Promise2.prototype.finally = function _finally(callback) {
          var promise = this;
          var constructor = promise.constructor;
          if (isFunction(callback)) {
            return promise.then(function(value) {
              return constructor.resolve(callback()).then(function() {
                return value;
              });
            }, function(reason) {
              return constructor.resolve(callback()).then(function() {
                throw reason;
              });
            });
          }
          return promise.then(callback, callback);
        };
        return Promise2;
      }();
      Promise$1.prototype.then = then;
      Promise$1.all = all2;
      Promise$1.race = race;
      Promise$1.resolve = resolve$1;
      Promise$1.reject = reject$1;
      Promise$1._setScheduler = setScheduler;
      Promise$1._setAsap = setAsap;
      Promise$1._asap = asap;
      function polyfill() {
        var local = void 0;
        if (typeof global !== "undefined") {
          local = global;
        } else if (typeof self !== "undefined") {
          local = self;
        } else {
          try {
            local = Function("return this")();
          } catch (e2) {
            throw new Error("polyfill failed because global object is unavailable in this environment");
          }
        }
        var P2 = local.Promise;
        if (P2) {
          var promiseToString = null;
          try {
            promiseToString = Object.prototype.toString.call(P2.resolve());
          } catch (e2) {
          }
          if (promiseToString === "[object Promise]" && !P2.cast) {
            return;
          }
        }
        local.Promise = Promise$1;
      }
      Promise$1.polyfill = polyfill;
      Promise$1.Promise = Promise$1;
      return Promise$1;
    });
  }
});

// ../../node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "../../node_modules/file-uri-to-path/index.js"(exports2, module2) {
    var sep = require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if ("localhost" == host)
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// ../../node_modules/bindings/bindings.js
var require_bindings2 = __commonJS({
  "../../node_modules/bindings/bindings.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists2 = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e2) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        // node-gyp's linked version in the "build" dir
        ["module_root", "build", "bindings"],
        // node-waf and gyp_addon (a.k.a node-gyp)
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        // Debug files, for development (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        // Legacy from node-waf, node <= 0.4.x
        ["module_root", "build", "default", "bindings"],
        // Production "Release" buildtype binary (meh...)
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        // node-qbs builds
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i3) {
        if (!(i3 in opts))
          opts[i3] = defaults[i3];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      var tries = [], i2 = 0, l2 = opts.try.length, n2, b2, err;
      for (; i2 < l2; i2++) {
        n2 = join.apply(
          null,
          opts.try[i2].map(function(p2) {
            return opts[p2] || p2;
          })
        );
        tries.push(n2);
        try {
          b2 = opts.path ? requireFunc.resolve(n2) : requireFunc(n2);
          if (!opts.path) {
            b2.path = n2;
          }
          return b2;
        } catch (e2) {
          if (e2.code !== "MODULE_NOT_FOUND" && e2.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e2.message)) {
            throw e2;
          }
        }
      }
      err = new Error(
        "Could not locate the bindings file. Tried:\n" + tries.map(function(a2) {
          return opts.arrow + a2;
        }).join("\n")
      );
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e2, st2) {
        for (var i2 = 0, l2 = st2.length; i2 < l2; i2++) {
          fileName = st2[i2].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists2(join(dir, "package.json")) || exists2(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error(
            'Could not find module root given file: "' + file + '". Do you have a `package.json` file? '
          );
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/bindings.js
var require_bindings3 = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/bindings.js"(exports2, module2) {
    "use strict";
    module2.exports = require_bindings2()("secp256k1");
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/lib/assert.js
var require_assert = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/lib/assert.js"(exports2) {
    "use strict";
    var toString4 = Object.prototype.toString;
    exports2.isArray = function(value, message2) {
      if (!Array.isArray(value))
        throw TypeError(message2);
    };
    exports2.isBoolean = function(value, message2) {
      if (toString4.call(value) !== "[object Boolean]")
        throw TypeError(message2);
    };
    exports2.isBuffer = function(value, message2) {
      if (!Buffer.isBuffer(value))
        throw TypeError(message2);
    };
    exports2.isFunction = function(value, message2) {
      if (toString4.call(value) !== "[object Function]")
        throw TypeError(message2);
    };
    exports2.isNumber = function(value, message2) {
      if (toString4.call(value) !== "[object Number]")
        throw TypeError(message2);
    };
    exports2.isObject = function(value, message2) {
      if (toString4.call(value) !== "[object Object]")
        throw TypeError(message2);
    };
    exports2.isBufferLength = function(buffer2, length5, message2) {
      if (buffer2.length !== length5)
        throw RangeError(message2);
    };
    exports2.isBufferLength2 = function(buffer2, length1, length22, message2) {
      if (buffer2.length !== length1 && buffer2.length !== length22)
        throw RangeError(message2);
    };
    exports2.isLengthGTZero = function(value, message2) {
      if (value.length === 0)
        throw RangeError(message2);
    };
    exports2.isNumberInInterval = function(number, x2, y2, message2) {
      if (number <= x2 || number >= y2)
        throw RangeError(message2);
    };
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer2 = require("buffer");
    var Buffer2 = buffer2.Buffer;
    function copyProps(src5, dst) {
      for (var key in src5) {
        dst[key] = src5[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length5) {
      return Buffer2(arg, encodingOrOffset, length5);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length5) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length5);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// ../../node_modules/bip66/index.js
var require_bip66 = __commonJS({
  "../../node_modules/bip66/index.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    function check(buffer2) {
      if (buffer2.length < 8)
        return false;
      if (buffer2.length > 72)
        return false;
      if (buffer2[0] !== 48)
        return false;
      if (buffer2[1] !== buffer2.length - 2)
        return false;
      if (buffer2[2] !== 2)
        return false;
      var lenR = buffer2[3];
      if (lenR === 0)
        return false;
      if (5 + lenR >= buffer2.length)
        return false;
      if (buffer2[4 + lenR] !== 2)
        return false;
      var lenS = buffer2[5 + lenR];
      if (lenS === 0)
        return false;
      if (6 + lenR + lenS !== buffer2.length)
        return false;
      if (buffer2[4] & 128)
        return false;
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
        return false;
      if (buffer2[lenR + 6] & 128)
        return false;
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        return false;
      return true;
    }
    function decode25(buffer2) {
      if (buffer2.length < 8)
        throw new Error("DER sequence length is too short");
      if (buffer2.length > 72)
        throw new Error("DER sequence length is too long");
      if (buffer2[0] !== 48)
        throw new Error("Expected DER sequence");
      if (buffer2[1] !== buffer2.length - 2)
        throw new Error("DER sequence length is invalid");
      if (buffer2[2] !== 2)
        throw new Error("Expected DER integer");
      var lenR = buffer2[3];
      if (lenR === 0)
        throw new Error("R length is zero");
      if (5 + lenR >= buffer2.length)
        throw new Error("R length is too long");
      if (buffer2[4 + lenR] !== 2)
        throw new Error("Expected DER integer (2)");
      var lenS = buffer2[5 + lenR];
      if (lenS === 0)
        throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer2.length)
        throw new Error("S length is invalid");
      if (buffer2[4] & 128)
        throw new Error("R value is negative");
      if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
        throw new Error("R value excessively padded");
      if (buffer2[lenR + 6] & 128)
        throw new Error("S value is negative");
      if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
        throw new Error("S value excessively padded");
      return {
        r: buffer2.slice(4, 4 + lenR),
        s: buffer2.slice(6 + lenR)
      };
    }
    function encode17(r2, s2) {
      var lenR = r2.length;
      var lenS = s2.length;
      if (lenR === 0)
        throw new Error("R length is zero");
      if (lenS === 0)
        throw new Error("S length is zero");
      if (lenR > 33)
        throw new Error("R length is too long");
      if (lenS > 33)
        throw new Error("S length is too long");
      if (r2[0] & 128)
        throw new Error("R value is negative");
      if (s2[0] & 128)
        throw new Error("S value is negative");
      if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
        throw new Error("R value excessively padded");
      if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128))
        throw new Error("S value excessively padded");
      var signature = Buffer2.allocUnsafe(6 + lenR + lenS);
      signature[0] = 48;
      signature[1] = signature.length - 2;
      signature[2] = 2;
      signature[3] = r2.length;
      r2.copy(signature, 4);
      signature[4 + lenR] = 2;
      signature[5 + lenR] = s2.length;
      s2.copy(signature, 6 + lenR);
      return signature;
    }
    module2.exports = {
      check,
      decode: decode25,
      encode: encode17
    };
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/lib/der.js
var require_der = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/lib/der.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var bip66 = require_bip66();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer2.from([
      // begin
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      // private key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // middle
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      // public key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer2.from([
      // begin
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      // private key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // middle
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      // public key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports2.privateKeyExport = function(privateKey, publicKey, compressed) {
      var result = Buffer2.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports2.privateKeyImport = function(privateKey) {
      var length5 = privateKey.length;
      var index = 0;
      if (length5 < index + 1 || privateKey[index] !== 48)
        return;
      index += 1;
      if (length5 < index + 1 || !(privateKey[index] & 128))
        return;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return;
      if (length5 < index + lenb)
        return;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length5 < index + len)
        return;
      if (length5 < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return;
      }
      index += 3;
      if (length5 < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length5 < index + 2 + privateKey[index + 1]) {
        return;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports2.signatureExport = function(sigObj) {
      var r2 = Buffer2.concat([Buffer2.from([0]), sigObj.r]);
      for (var lenR = 33, posR = 0; lenR > 1 && r2[posR] === 0 && !(r2[posR + 1] & 128); --lenR, ++posR)
        ;
      var s2 = Buffer2.concat([Buffer2.from([0]), sigObj.s]);
      for (var lenS = 33, posS = 0; lenS > 1 && s2[posS] === 0 && !(s2[posS + 1] & 128); --lenS, ++posS)
        ;
      return bip66.encode(r2.slice(posR), s2.slice(posS));
    };
    exports2.signatureImport = function(sig) {
      var r2 = Buffer2.alloc(32, 0);
      var s2 = Buffer2.alloc(32, 0);
      try {
        var sigObj = bip66.decode(sig);
        if (sigObj.r.length === 33 && sigObj.r[0] === 0)
          sigObj.r = sigObj.r.slice(1);
        if (sigObj.r.length > 32)
          throw new Error("R length is too long");
        if (sigObj.s.length === 33 && sigObj.s[0] === 0)
          sigObj.s = sigObj.s.slice(1);
        if (sigObj.s.length > 32)
          throw new Error("S length is too long");
      } catch (err) {
        return;
      }
      sigObj.r.copy(r2, 32 - sigObj.r.length);
      sigObj.s.copy(s2, 32 - sigObj.s.length);
      return { r: r2, s: s2 };
    };
    exports2.signatureImportLax = function(sig) {
      var r2 = Buffer2.alloc(32, 0);
      var s2 = Buffer2.alloc(32, 0);
      var length5 = sig.length;
      var index = 0;
      if (sig[index++] !== 48)
        return;
      var lenbyte = sig[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length5)
          return;
      }
      if (sig[index++] !== 2)
        return;
      var rlen = sig[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length5)
          return;
        for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          rlen = (rlen << 8) + sig[index];
      }
      if (rlen > length5 - index)
        return;
      var rindex = index;
      index += rlen;
      if (sig[index++] !== 2)
        return;
      var slen = sig[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length5)
          return;
        for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          slen = (slen << 8) + sig[index];
      }
      if (slen > length5 - index)
        return;
      var sindex = index;
      index += slen;
      for (; rlen > 0 && sig[rindex] === 0; rlen -= 1, rindex += 1)
        ;
      if (rlen > 32)
        return;
      var rvalue = sig.slice(rindex, rindex + rlen);
      rvalue.copy(r2, 32 - rvalue.length);
      for (; slen > 0 && sig[sindex] === 0; slen -= 1, sindex += 1)
        ;
      if (slen > 32)
        return;
      var svalue = sig.slice(sindex, sindex + slen);
      svalue.copy(s2, 32 - svalue.length);
      return { r: r2, s: s2 };
    };
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/lib/messages.json
var require_messages = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/lib/messages.json"(exports2, module2) {
    module2.exports = {
      COMPRESSED_TYPE_INVALID: "compressed should be a boolean",
      EC_PRIVATE_KEY_TYPE_INVALID: "private key should be a Buffer",
      EC_PRIVATE_KEY_LENGTH_INVALID: "private key length is invalid",
      EC_PRIVATE_KEY_RANGE_INVALID: "private key range is invalid",
      EC_PRIVATE_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting private key is invalid",
      EC_PRIVATE_KEY_TWEAK_MUL_FAIL: "tweak out of range",
      EC_PRIVATE_KEY_EXPORT_DER_FAIL: "couldn't export to DER format",
      EC_PRIVATE_KEY_IMPORT_DER_FAIL: "couldn't import from DER format",
      EC_PUBLIC_KEYS_TYPE_INVALID: "public keys should be an Array",
      EC_PUBLIC_KEYS_LENGTH_INVALID: "public keys Array should have at least 1 element",
      EC_PUBLIC_KEY_TYPE_INVALID: "public key should be a Buffer",
      EC_PUBLIC_KEY_LENGTH_INVALID: "public key length is invalid",
      EC_PUBLIC_KEY_PARSE_FAIL: "the public key could not be parsed or is invalid",
      EC_PUBLIC_KEY_CREATE_FAIL: "private was invalid, try again",
      EC_PUBLIC_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting public key is invalid",
      EC_PUBLIC_KEY_TWEAK_MUL_FAIL: "tweak out of range",
      EC_PUBLIC_KEY_COMBINE_FAIL: "the sum of the public keys is not valid",
      ECDH_FAIL: "scalar was invalid (zero or overflow)",
      ECDSA_SIGNATURE_TYPE_INVALID: "signature should be a Buffer",
      ECDSA_SIGNATURE_LENGTH_INVALID: "signature length is invalid",
      ECDSA_SIGNATURE_PARSE_FAIL: "couldn't parse signature",
      ECDSA_SIGNATURE_PARSE_DER_FAIL: "couldn't parse DER signature",
      ECDSA_SIGNATURE_SERIALIZE_DER_FAIL: "couldn't serialize signature to DER format",
      ECDSA_SIGN_FAIL: "nonce generation function failed or private key is invalid",
      ECDSA_RECOVER_FAIL: "couldn't recover public key from signature",
      MSG32_TYPE_INVALID: "message should be a Buffer",
      MSG32_LENGTH_INVALID: "message length is invalid",
      OPTIONS_TYPE_INVALID: "options should be an Object",
      OPTIONS_DATA_TYPE_INVALID: "options.data should be a Buffer",
      OPTIONS_DATA_LENGTH_INVALID: "options.data length is invalid",
      OPTIONS_NONCEFN_TYPE_INVALID: "options.noncefn should be a Function",
      RECOVERY_ID_TYPE_INVALID: "recovery should be a Number",
      RECOVERY_ID_VALUE_INVALID: "recovery should have value between -1 and 4",
      TWEAK_TYPE_INVALID: "tweak should be a Buffer",
      TWEAK_LENGTH_INVALID: "tweak length is invalid"
    };
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/lib/index.js"(exports2, module2) {
    "use strict";
    var assert = require_assert();
    var der = require_der();
    var messages = require_messages();
    function initCompressedValue(value, defaultValue) {
      if (value === void 0)
        return defaultValue;
      assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID);
      return value;
    }
    module2.exports = function(secp256k1) {
      return {
        privateKeyVerify: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey);
        },
        privateKeyExport: function(privateKey, compressed) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          var publicKey = secp256k1.privateKeyExport(privateKey, compressed);
          return der.privateKeyExport(privateKey, publicKey, compressed);
        },
        privateKeyImport: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          privateKey = der.privateKeyImport(privateKey);
          if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey))
            return privateKey;
          throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL);
        },
        privateKeyNegate: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k1.privateKeyNegate(privateKey);
        },
        privateKeyModInverse: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k1.privateKeyModInverse(privateKey);
        },
        privateKeyTweakAdd: function(privateKey, tweak) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          return secp256k1.privateKeyTweakAdd(privateKey, tweak);
        },
        privateKeyTweakMul: function(privateKey, tweak) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          return secp256k1.privateKeyTweakMul(privateKey, tweak);
        },
        publicKeyCreate: function(privateKey, compressed) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyCreate(privateKey, compressed);
        },
        publicKeyConvert: function(publicKey, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyConvert(publicKey, compressed);
        },
        publicKeyVerify: function(publicKey) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          return secp256k1.publicKeyVerify(publicKey);
        },
        publicKeyTweakAdd: function(publicKey, tweak, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed);
        },
        publicKeyTweakMul: function(publicKey, tweak, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed);
        },
        publicKeyCombine: function(publicKeys, compressed) {
          assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID);
          assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID);
          for (var i2 = 0; i2 < publicKeys.length; ++i2) {
            assert.isBuffer(publicKeys[i2], messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert.isBufferLength2(publicKeys[i2], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          }
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyCombine(publicKeys, compressed);
        },
        signatureNormalize: function(signature) {
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          return secp256k1.signatureNormalize(signature);
        },
        signatureExport: function(signature) {
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = secp256k1.signatureExport(signature);
          return der.signatureExport(sigObj);
        },
        signatureImport: function(sig) {
          assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = der.signatureImport(sig);
          if (sigObj)
            return secp256k1.signatureImport(sigObj);
          throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
        },
        signatureImportLax: function(sig) {
          assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = der.signatureImportLax(sig);
          if (sigObj)
            return secp256k1.signatureImport(sigObj);
          throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
        },
        sign: function(message2, privateKey, options) {
          assert.isBuffer(message2, messages.MSG32_TYPE_INVALID);
          assert.isBufferLength(message2, 32, messages.MSG32_LENGTH_INVALID);
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          var data = null;
          var noncefn = null;
          if (options !== void 0) {
            assert.isObject(options, messages.OPTIONS_TYPE_INVALID);
            if (options.data !== void 0) {
              assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID);
              assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID);
              data = options.data;
            }
            if (options.noncefn !== void 0) {
              assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID);
              noncefn = options.noncefn;
            }
          }
          return secp256k1.sign(message2, privateKey, noncefn, data);
        },
        verify: function(message2, signature, publicKey) {
          assert.isBuffer(message2, messages.MSG32_TYPE_INVALID);
          assert.isBufferLength(message2, 32, messages.MSG32_LENGTH_INVALID);
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          return secp256k1.verify(message2, signature, publicKey);
        },
        recover: function(message2, signature, recovery, compressed) {
          assert.isBuffer(message2, messages.MSG32_TYPE_INVALID);
          assert.isBufferLength(message2, 32, messages.MSG32_LENGTH_INVALID);
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID);
          assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.recover(message2, signature, recovery, compressed);
        },
        ecdh: function(publicKey, privateKey) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k1.ecdh(publicKey, privateKey);
        },
        ecdhUnsafe: function(publicKey, privateKey, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);
        }
      };
    };
  }
});

// ../../node_modules/create-hash/index.js
var require_create_hash = __commonJS({
  "../../node_modules/create-hash/index.js"(exports2, module2) {
    module2.exports = require("crypto").createHash;
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/lib/elliptic/index.js
var require_elliptic4 = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/lib/elliptic/index.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var createHash = require_create_hash();
    var BN = require_bn();
    var EC = require_elliptic().ec;
    var messages = require_messages();
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    function loadCompressedPublicKey(first2, xBuffer) {
      var x2 = new BN(xBuffer);
      if (x2.cmp(ecparams.p) >= 0)
        return null;
      x2 = x2.toRed(ecparams.red);
      var y2 = x2.redSqr().redIMul(x2).redIAdd(ecparams.b).redSqrt();
      if (first2 === 3 !== y2.isOdd())
        y2 = y2.redNeg();
      return ec.keyPair({ pub: { x: x2, y: y2 } });
    }
    function loadUncompressedPublicKey(first2, xBuffer, yBuffer) {
      var x2 = new BN(xBuffer);
      var y2 = new BN(yBuffer);
      if (x2.cmp(ecparams.p) >= 0 || y2.cmp(ecparams.p) >= 0)
        return null;
      x2 = x2.toRed(ecparams.red);
      y2 = y2.toRed(ecparams.red);
      if ((first2 === 6 || first2 === 7) && y2.isOdd() !== (first2 === 7))
        return null;
      var x3 = x2.redSqr().redIMul(x2);
      if (!y2.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
        return null;
      return ec.keyPair({ pub: { x: x2, y: y2 } });
    }
    function loadPublicKey(publicKey) {
      var first2 = publicKey[0];
      switch (first2) {
        case 2:
        case 3:
          if (publicKey.length !== 33)
            return null;
          return loadCompressedPublicKey(first2, publicKey.slice(1, 33));
        case 4:
        case 6:
        case 7:
          if (publicKey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first2, publicKey.slice(1, 33), publicKey.slice(33, 65));
        default:
          return null;
      }
    }
    exports2.privateKeyVerify = function(privateKey) {
      var bn = new BN(privateKey);
      return bn.cmp(ecparams.n) < 0 && !bn.isZero();
    };
    exports2.privateKeyExport = function(privateKey, compressed) {
      var d2 = new BN(privateKey);
      if (d2.cmp(ecparams.n) >= 0 || d2.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL);
      return Buffer2.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
    };
    exports2.privateKeyNegate = function(privateKey) {
      var bn = new BN(privateKey);
      return bn.isZero() ? Buffer2.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports2.privateKeyModInverse = function(privateKey) {
      var bn = new BN(privateKey);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID);
      return bn.invm(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports2.privateKeyTweakAdd = function(privateKey, tweak) {
      var bn = new BN(tweak);
      if (bn.cmp(ecparams.n) >= 0)
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      bn.iadd(new BN(privateKey));
      if (bn.cmp(ecparams.n) >= 0)
        bn.isub(ecparams.n);
      if (bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      return bn.toArrayLike(Buffer2, "be", 32);
    };
    exports2.privateKeyTweakMul = function(privateKey, tweak) {
      var bn = new BN(tweak);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);
      bn.imul(new BN(privateKey));
      if (bn.cmp(ecparams.n))
        bn = bn.umod(ecparams.n);
      return bn.toArrayLike(Buffer2, "be", 32);
    };
    exports2.publicKeyCreate = function(privateKey, compressed) {
      var d2 = new BN(privateKey);
      if (d2.cmp(ecparams.n) >= 0 || d2.isZero())
        throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL);
      return Buffer2.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
    };
    exports2.publicKeyConvert = function(publicKey, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      return Buffer2.from(pair.getPublic(compressed, true));
    };
    exports2.publicKeyVerify = function(publicKey) {
      return loadPublicKey(publicKey) !== null;
    };
    exports2.publicKeyTweakAdd = function(publicKey, tweak, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0)
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      var point = ecparams.g.mul(tweak).add(pair.pub);
      if (point.isInfinity())
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      return Buffer2.from(point.encode(true, compressed));
    };
    exports2.publicKeyTweakMul = function(publicKey, tweak, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
      return Buffer2.from(pair.pub.mul(tweak).encode(true, compressed));
    };
    exports2.publicKeyCombine = function(publicKeys, compressed) {
      var pairs = new Array(publicKeys.length);
      for (var i2 = 0; i2 < publicKeys.length; ++i2) {
        pairs[i2] = loadPublicKey(publicKeys[i2]);
        if (pairs[i2] === null)
          throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      }
      var point = pairs[0].pub;
      for (var j2 = 1; j2 < pairs.length; ++j2)
        point = point.add(pairs[j2].pub);
      if (point.isInfinity())
        throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL);
      return Buffer2.from(point.encode(true, compressed));
    };
    exports2.signatureNormalize = function(signature) {
      var r2 = new BN(signature.slice(0, 32));
      var s2 = new BN(signature.slice(32, 64));
      if (r2.cmp(ecparams.n) >= 0 || s2.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      var result = Buffer2.from(signature);
      if (s2.cmp(ec.nh) === 1)
        ecparams.n.sub(s2).toArrayLike(Buffer2, "be", 32).copy(result, 32);
      return result;
    };
    exports2.signatureExport = function(signature) {
      var r2 = signature.slice(0, 32);
      var s2 = signature.slice(32, 64);
      if (new BN(r2).cmp(ecparams.n) >= 0 || new BN(s2).cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      return { r: r2, s: s2 };
    };
    exports2.signatureImport = function(sigObj) {
      var r2 = new BN(sigObj.r);
      if (r2.cmp(ecparams.n) >= 0)
        r2 = new BN(0);
      var s2 = new BN(sigObj.s);
      if (s2.cmp(ecparams.n) >= 0)
        s2 = new BN(0);
      return Buffer2.concat([
        r2.toArrayLike(Buffer2, "be", 32),
        s2.toArrayLike(Buffer2, "be", 32)
      ]);
    };
    exports2.sign = function(message2, privateKey, noncefn, data) {
      if (typeof noncefn === "function") {
        var getNonce = noncefn;
        noncefn = function(counter) {
          var nonce = getNonce(message2, privateKey, null, data, counter);
          if (!Buffer2.isBuffer(nonce) || nonce.length !== 32)
            throw new Error(messages.ECDSA_SIGN_FAIL);
          return new BN(nonce);
        };
      }
      var d2 = new BN(privateKey);
      if (d2.cmp(ecparams.n) >= 0 || d2.isZero())
        throw new Error(messages.ECDSA_SIGN_FAIL);
      var result = ec.sign(message2, privateKey, { canonical: true, k: noncefn, pers: data });
      return {
        signature: Buffer2.concat([
          result.r.toArrayLike(Buffer2, "be", 32),
          result.s.toArrayLike(Buffer2, "be", 32)
        ]),
        recovery: result.recoveryParam
      };
    };
    exports2.verify = function(message2, signature, publicKey) {
      var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) };
      var sigr = new BN(sigObj.r);
      var sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
        return false;
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      return ec.verify(message2, sigObj, { x: pair.pub.x, y: pair.pub.y });
    };
    exports2.recover = function(message2, signature, recovery, compressed) {
      var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) };
      var sigr = new BN(sigObj.r);
      var sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      try {
        if (sigr.isZero() || sigs.isZero())
          throw new Error();
        var point = ec.recoverPubKey(message2, sigObj, recovery);
        return Buffer2.from(point.encode(true, compressed));
      } catch (err) {
        throw new Error(messages.ECDSA_RECOVER_FAIL);
      }
    };
    exports2.ecdh = function(publicKey, privateKey) {
      var shared = exports2.ecdhUnsafe(publicKey, privateKey, true);
      return createHash("sha256").update(shared).digest();
    };
    exports2.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      var scalar = new BN(privateKey);
      if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
        throw new Error(messages.ECDH_FAIL);
      return Buffer2.from(pair.pub.mul(scalar).encode(true, compressed));
    };
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/elliptic.js
var require_elliptic5 = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/elliptic.js"(exports2, module2) {
    "use strict";
    module2.exports = require_lib4()(require_elliptic4());
  }
});

// ../../node_modules/eccrypto/node_modules/secp256k1/index.js
var require_secp256k13 = __commonJS({
  "../../node_modules/eccrypto/node_modules/secp256k1/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_bindings3();
    } catch (err) {
      if (process.env.DEBUG) {
        console.error("Secp256k1 bindings are not compiled. Pure JS implementation will be used.");
      }
      module2.exports = require_elliptic5();
    }
  }
});

// ../../node_modules/eccrypto/browser.js
var require_browser = __commonJS({
  "../../node_modules/eccrypto/browser.js"(exports2) {
    "use strict";
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var browserCrypto = global.crypto || global.msCrypto || {};
    var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    var nodeCrypto3 = require("crypto");
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var ZERO32 = Buffer.alloc(32, 0);
    function assert(condition, message2) {
      if (!condition) {
        throw new Error(message2 || "Assertion failed");
      }
    }
    function isScalar(x2) {
      return Buffer.isBuffer(x2) && x2.length === 32;
    }
    function isValidPrivateKey(privateKey) {
      if (!isScalar(privateKey)) {
        return false;
      }
      return privateKey.compare(ZERO32) > 0 && // > 0
      privateKey.compare(EC_GROUP_ORDER) < 0;
    }
    function equalConstTime(b1, b2) {
      if (b1.length !== b2.length) {
        return false;
      }
      var res = 0;
      for (var i2 = 0; i2 < b1.length; i2++) {
        res |= b1[i2] ^ b2[i2];
      }
      return res === 0;
    }
    function randomBytes(size) {
      var arr = new Uint8Array(size);
      if (typeof browserCrypto.getRandomValues === "undefined") {
        return Buffer.from(nodeCrypto3.randomBytes(size));
      } else {
        browserCrypto.getRandomValues(arr);
      }
      return Buffer.from(arr);
    }
    function sha5122(msg) {
      return new Promise(function(resolve5) {
        var hash = nodeCrypto3.createHash("sha512");
        var result = hash.update(msg).digest();
        resolve5(new Uint8Array(result));
      });
    }
    function getAes(op) {
      return function(iv, key, data) {
        return new Promise(function(resolve5) {
          if (subtle) {
            var importAlgorithm = { name: "AES-CBC" };
            var keyp = subtle.importKey("raw", key, importAlgorithm, false, [op]);
            return keyp.then(function(cryptoKey) {
              var encAlgorithm = { name: "AES-CBC", iv };
              return subtle[op](encAlgorithm, cryptoKey, data);
            }).then(function(result) {
              resolve5(Buffer.from(new Uint8Array(result)));
            });
          } else {
            if (op === "encrypt") {
              var cipher = nodeCrypto3.createCipheriv("aes-256-cbc", key, iv);
              let firstChunk = cipher.update(data);
              let secondChunk = cipher.final();
              resolve5(Buffer.concat([firstChunk, secondChunk]));
            } else if (op === "decrypt") {
              var decipher = nodeCrypto3.createDecipheriv("aes-256-cbc", key, iv);
              let firstChunk = decipher.update(data);
              let secondChunk = decipher.final();
              resolve5(Buffer.concat([firstChunk, secondChunk]));
            }
          }
        });
      };
    }
    var aesCbcEncrypt = getAes("encrypt");
    var aesCbcDecrypt = getAes("decrypt");
    function hmacSha256Sign(key, msg) {
      return new Promise(function(resolve5) {
        var hmac = nodeCrypto3.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var result = hmac.digest();
        resolve5(result);
      });
    }
    function hmacSha256Verify(key, msg, sig) {
      return new Promise(function(resolve5) {
        var hmac = nodeCrypto3.createHmac("sha256", Buffer.from(key));
        hmac.update(msg);
        var expectedSig = hmac.digest();
        resolve5(equalConstTime(expectedSig, sig));
      });
    }
    exports2.generatePrivate = function() {
      var privateKey = randomBytes(32);
      while (!isValidPrivateKey(privateKey)) {
        privateKey = randomBytes(32);
      }
      return privateKey;
    };
    var getPublic = exports2.getPublic = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      return Buffer.from(ec.keyFromPrivate(privateKey).getPublic("arr"));
    };
    var getPublicCompressed = exports2.getPublicCompressed = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      let compressed = true;
      return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, "arr"));
    };
    exports2.sign = function(privateKey, msg) {
      return new Promise(function(resolve5) {
        assert(privateKey.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKey), "Bad private key");
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        resolve5(Buffer.from(ec.sign(msg, privateKey, { canonical: true }).toDER()));
      });
    };
    exports2.verify = function(publicKey, msg, sig) {
      return new Promise(function(resolve5, reject) {
        assert(publicKey.length === 65 || publicKey.length === 33, "Bad public key");
        if (publicKey.length === 65) {
          assert(publicKey[0] === 4, "Bad public key");
        }
        if (publicKey.length === 33) {
          assert(publicKey[0] === 2 || publicKey[0] === 3, "Bad public key");
        }
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        if (ec.verify(msg, sig, publicKey)) {
          resolve5(null);
        } else {
          reject(new Error("Bad signature"));
        }
      });
    };
    var derive = exports2.derive = function(privateKeyA, publicKeyB) {
      return new Promise(function(resolve5) {
        assert(Buffer.isBuffer(privateKeyA), "Bad private key");
        assert(Buffer.isBuffer(publicKeyB), "Bad public key");
        assert(privateKeyA.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKeyA), "Bad private key");
        assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
        if (publicKeyB.length === 65) {
          assert(publicKeyB[0] === 4, "Bad public key");
        }
        if (publicKeyB.length === 33) {
          assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
        }
        var keyA = ec.keyFromPrivate(privateKeyA);
        var keyB = ec.keyFromPublic(publicKeyB);
        var Px = keyA.derive(keyB.getPublic());
        resolve5(Buffer.from(Px.toArray()));
      });
    };
    exports2.encrypt = function(publicKeyTo, msg, opts) {
      opts = opts || {};
      var iv, ephemPublicKey, ciphertext, macKey;
      return new Promise(function(resolve5) {
        var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        while (!isValidPrivateKey(ephemPrivateKey)) {
          ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
        }
        ephemPublicKey = getPublic(ephemPrivateKey);
        resolve5(derive(ephemPrivateKey, publicKeyTo));
      }).then(function(Px) {
        return sha5122(Px);
      }).then(function(hash) {
        iv = opts.iv || randomBytes(16);
        var encryptionKey = hash.slice(0, 32);
        macKey = hash.slice(32);
        return aesCbcEncrypt(iv, encryptionKey, msg);
      }).then(function(data) {
        ciphertext = data;
        var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
        return hmacSha256Sign(macKey, dataToMac);
      }).then(function(mac) {
        return {
          iv,
          ephemPublicKey,
          ciphertext,
          mac
        };
      });
    };
    exports2.decrypt = function(privateKey, opts) {
      var encryptionKey;
      return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
        return sha5122(Px);
      }).then(function(hash) {
        encryptionKey = hash.slice(0, 32);
        var macKey = hash.slice(32);
        var dataToMac = Buffer.concat([
          opts.iv,
          opts.ephemPublicKey,
          opts.ciphertext
        ]);
        return hmacSha256Verify(macKey, dataToMac, opts.mac);
      }).then(function(macGood) {
        assert(macGood, "Bad MAC");
        return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);
      }).then(function(msg) {
        return Buffer.from(new Uint8Array(msg));
      });
    };
  }
});

// ../../node_modules/eccrypto/index.js
var require_eccrypto = __commonJS({
  "../../node_modules/eccrypto/index.js"(exports2, module2) {
    "use strict";
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var ZERO32 = Buffer.alloc(32, 0);
    var promise = typeof Promise === "undefined" ? require_es6_promise().Promise : Promise;
    var crypto6 = require("crypto");
    try {
      secp256k1 = require_secp256k13();
      ecdh = require("./build/Release/ecdh");
    } catch (e2) {
      if (process.env.ECCRYPTO_NO_FALLBACK) {
        throw e2;
      } else {
        console.info("secp256k1 unavailable, reverting to browser version");
        return module2.exports = require_browser();
      }
    }
    var secp256k1;
    var ecdh;
    function isScalar(x2) {
      return Buffer.isBuffer(x2) && x2.length === 32;
    }
    function isValidPrivateKey(privateKey) {
      if (!isScalar(privateKey)) {
        return false;
      }
      return privateKey.compare(ZERO32) > 0 && // > 0
      privateKey.compare(EC_GROUP_ORDER) < 0;
    }
    function assert(condition, message2) {
      if (!condition) {
        throw new Error(message2 || "Assertion failed");
      }
    }
    function sha5122(msg) {
      return crypto6.createHash("sha512").update(msg).digest();
    }
    function aes256CbcEncrypt(iv, key, plaintext) {
      var cipher = crypto6.createCipheriv("aes-256-cbc", key, iv);
      var firstChunk = cipher.update(plaintext);
      var secondChunk = cipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    }
    function aes256CbcDecrypt(iv, key, ciphertext) {
      var cipher = crypto6.createDecipheriv("aes-256-cbc", key, iv);
      var firstChunk = cipher.update(ciphertext);
      var secondChunk = cipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    }
    function hmacSha256(key, msg) {
      return crypto6.createHmac("sha256", key).update(msg).digest();
    }
    function equalConstTime(b1, b2) {
      if (b1.length !== b2.length) {
        return false;
      }
      var res = 0;
      for (var i2 = 0; i2 < b1.length; i2++) {
        res |= b1[i2] ^ b2[i2];
      }
      return res === 0;
    }
    function pad32(msg) {
      var buf2;
      if (msg.length < 32) {
        buf2 = Buffer.alloc(32);
        buf2.fill(0);
        msg.copy(buf2, 32 - msg.length);
        return buf2;
      } else {
        return msg;
      }
    }
    exports2.generatePrivate = function() {
      var privateKey = crypto6.randomBytes(32);
      while (!isValidPrivateKey(privateKey)) {
        privateKey = crypto6.randomBytes(32);
      }
      return privateKey;
    };
    var getPublic = exports2.getPublic = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      var compressed = secp256k1.publicKeyCreate(privateKey);
      return secp256k1.publicKeyConvert(compressed, false);
    };
    var getPublicCompressed = exports2.getPublicCompressed = function(privateKey) {
      assert(privateKey.length === 32, "Bad private key");
      assert(isValidPrivateKey(privateKey), "Bad private key");
      return secp256k1.publicKeyCreate(privateKey);
    };
    exports2.sign = function(privateKey, msg) {
      return new promise(function(resolve5) {
        assert(privateKey.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKey), "Bad private key");
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        msg = pad32(msg);
        var sig = secp256k1.sign(msg, privateKey).signature;
        resolve5(secp256k1.signatureExport(sig));
      });
    };
    exports2.verify = function(publicKey, msg, sig) {
      return new promise(function(resolve5, reject) {
        assert(msg.length > 0, "Message should not be empty");
        assert(msg.length <= 32, "Message is too long");
        msg = pad32(msg);
        sig = secp256k1.signatureImport(sig);
        if (secp256k1.verify(msg, sig, publicKey)) {
          resolve5(null);
        } else {
          reject(new Error("Bad signature"));
        }
      });
    };
    var derive = exports2.derive = function(privateKeyA, publicKeyB) {
      return new promise(function(resolve5) {
        assert(privateKeyA.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKeyA), "Bad private key");
        resolve5(ecdh.derive(privateKeyA, publicKeyB));
      });
    };
    exports2.encrypt = function(publicKeyTo, msg, opts) {
      opts = opts || {};
      var ephemPublicKey;
      return new promise(function(resolve5) {
        var ephemPrivateKey = opts.ephemPrivateKey || crypto6.randomBytes(32);
        while (!isValidPrivateKey(ephemPrivateKey)) {
          ephemPrivateKey = opts.ephemPrivateKey || crypto6.randomBytes(32);
        }
        ephemPublicKey = getPublic(ephemPrivateKey);
        resolve5(derive(ephemPrivateKey, publicKeyTo));
      }).then(function(Px) {
        var hash = sha5122(Px);
        var iv = opts.iv || crypto6.randomBytes(16);
        var encryptionKey = hash.slice(0, 32);
        var macKey = hash.slice(32);
        var ciphertext = aes256CbcEncrypt(iv, encryptionKey, msg);
        var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
        var mac = Buffer.from(hmacSha256(macKey, dataToMac));
        return {
          iv,
          ephemPublicKey,
          ciphertext,
          mac
        };
      });
    };
    exports2.decrypt = function(privateKey, opts) {
      return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
        assert(privateKey.length === 32, "Bad private key");
        assert(isValidPrivateKey(privateKey), "Bad private key");
        var hash = sha5122(Px);
        var encryptionKey = hash.slice(0, 32);
        var macKey = hash.slice(32);
        var dataToMac = Buffer.concat([
          opts.iv,
          opts.ephemPublicKey,
          opts.ciphertext
        ]);
        var realMac = hmacSha256(macKey, dataToMac);
        assert(equalConstTime(opts.mac, realMac), "Bad MAC");
        return aes256CbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);
      });
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ProfileApi: () => ProfileApi,
  ProfileStore: () => ProfileStore,
  Web5UserAgent: () => Web5UserAgent
});
module.exports = __toCommonJS(main_exports);

// src/profile-store.ts
var import_level2 = require("level");

// src/profile-index.ts
var import_level = require("level");
var import_flat = __toESM(require_flat(), 1);
var { flatten } = import_flat.default;
var ProfileIndex = class {
  constructor(location = "data/agent/profiles-index") {
    this.location = location;
    this.level = new import_level.Level(location);
  }
  delete(id) {
    return __async(this, null, function* () {
      const ops = [];
      let keyPrefixes = yield this.level.get(`__${id}__meta`);
      if (!keyPrefixes) {
        return;
      }
      keyPrefixes = keyPrefixes.split("@");
      for (let keyPrefix of keyPrefixes) {
        const op = { type: "del", key: `${keyPrefix}~${id}` };
        ops.push(op);
      }
      ops.push({ type: "del", key: `__${id}__meta` });
      yield this.level.batch(ops);
    });
  }
  put(record) {
    return __async(this, null, function* () {
      const flattenedRecord = flatten(record);
      let { id } = flattenedRecord;
      let keyPrefixes = [];
      const ops = [];
      for (let property in flattenedRecord) {
        if (property === "id") {
          continue;
        }
        const propVal = flattenedRecord[property];
        const keyPrefix = `${property}~${propVal}`;
        const key = `${keyPrefix}~${id}`;
        ops.push({ type: "put", key, value: id });
        keyPrefixes.push(keyPrefix);
      }
      ops.push({ type: "put", key: `__${id}__meta`, value: keyPrefixes.join("@") });
      yield this.level.batch(ops);
    });
  }
  query(filter2) {
    return __async(this, null, function* () {
      const matches = {};
      const promises = [];
      for (let propertyName in filter2) {
        const propertyValue = filter2[propertyName];
        if (typeof propertyValue === "object" && propertyValue !== null) {
          if (Array.isArray(propertyValue)) {
            for (let value of propertyValue) {
              const promise = this.buildTermQuery(propertyName, value, matches);
              promises.push(promise);
            }
          } else {
            const promise = this.buildRangeQuery(propertyName, propertyValue, matches);
            promises.push(promise);
          }
        } else {
          const promise = this.buildTermQuery(propertyName, propertyValue, matches);
          promises.push(promise);
        }
      }
      const numFilters = Object.keys(filter2).length;
      const docIds = [];
      yield Promise.all(promises);
      for (let docId in matches) {
        if (matches[docId] === numFilters) {
          docIds.push(docId);
        }
      }
      return docIds;
    });
  }
  buildTermQuery(propertyName, propertyValue, matches) {
    return __async(this, null, function* () {
      const key = `${propertyName}~${propertyValue}`;
      const iteratorOptions = {
        gt: `${key}~`
      };
      try {
        for (var iter = __forAwait(this.level.iterator(iteratorOptions)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          let doc = temp.value;
          const [k2, val] = doc;
          if (!k2.includes(key)) {
            break;
          }
          if (val in matches) {
            matches[val] += 1;
          } else {
            matches[val] = 1;
          }
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  buildRangeQuery(propertyName, range, matches) {
    return __async(this, null, function* () {
      const key = `${propertyName}`;
      const iteratorOptions = {};
      for (let inequality in range) {
        iteratorOptions[inequality] = `${propertyName}~${range[inequality]}`;
      }
      try {
        for (var iter = __forAwait(this.level.iterator(iteratorOptions)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          let doc = temp.value;
          const [k2, val] = doc;
          if (!k2.includes(key)) {
            break;
          }
          if (val in matches) {
            matches[val] += 1;
          } else {
            matches[val] = 1;
          }
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  clear() {
    return __async(this, null, function* () {
      this.level.clear();
    });
  }
  close() {
    return __async(this, null, function* () {
      return this.level.close();
    });
  }
};

// src/profile-store.ts
var _ProfileStore = class {
  constructor(options = {}) {
    options = __spreadValues(__spreadValues({}, _ProfileStore._defaultOptions), options);
    this.db = new import_level2.Level(options.location);
    this.index = new ProfileIndex(options.indexLocation);
  }
  put(entry) {
    return __async(this, null, function* () {
      const key = this.generateKey(entry.id);
      const value = JSON.stringify(entry);
      yield this.db.put(key, value);
      yield this.index.put(entry);
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const key = this.generateKey(id);
      try {
        const value = yield this.db.get(key);
        return JSON.parse(value);
      } catch (e2) {
        if (e2.code === "LEVEL_NOT_FOUND") {
          return void 0;
        }
      }
    });
  }
  query(filter2) {
    return __async(this, null, function* () {
      const results = yield this.index.query(filter2);
      const profiles = [];
      const serializedProfiles = yield this.db.getMany(results);
      for (let serializedProfile of serializedProfiles) {
        profiles.push(JSON.parse(serializedProfile));
      }
      return profiles;
    });
  }
  all() {
    return __async(this, null, function* () {
      const serializedProfiles = yield this.db.values().all();
      const profiles = [];
      for (let serializedProfile of serializedProfiles) {
        profiles.push(JSON.parse(serializedProfile));
      }
      return profiles;
    });
  }
  delete() {
    return __async(this, null, function* () {
      throw new Error("Method not implemented.");
    });
  }
  clear() {
    return __async(this, null, function* () {
      yield this.index.clear();
      yield this.db.clear();
      return;
    });
  }
  close() {
    return __async(this, null, function* () {
      yield this.index.close();
      yield this.db.close();
      return;
    });
  }
  generateKey(id) {
    return `PROFILE_${id}`;
  }
};
var ProfileStore = _ProfileStore;
ProfileStore._defaultOptions = {
  location: "data/agent/profiles",
  indexLocation: "data/agent/profiles-index"
};

// src/profile-api.ts
var ProfileApi = class {
  constructor(store) {
    this.store = store || (store = new ProfileStore());
  }
  createProfile(options) {
    return __async(this, null, function* () {
      var _a2;
      if (!options.did && !options.didMethod) {
        throw new Error("must provide did or didMethod");
      }
      const profile = {
        name: options.name,
        icon: options.icon,
        dateCreated: new Date()
      };
      if (options.did) {
        profile.did = options.did;
      } else {
      }
      profile.id = (_a2 = options.did) == null ? void 0 : _a2.id;
      yield this.store.put(profile);
      return profile;
    });
  }
  getProfile(id) {
    return this.store.get(id);
  }
  // TODO: discuss whether we want to rename this to getProfiles instead
  listProfiles() {
    return this.store.all();
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/core/tenant-gate.js
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AllowAllTenantGate = class {
  isTenant(_did) {
    return __awaiter(this, void 0, void 0, function* () {
      return true;
    });
  }
};

// ../../node_modules/@ipld/dag-cbor/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code,
  decode: () => decode6,
  encode: () => encode4,
  name: () => name
});

// ../../node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// ../../node_modules/cborg/esm/lib/token.js
var Type = class {
  constructor(major, name6, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name6;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// ../../node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString = useBuffer ? (bytes, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice(bytes, start, end);
} : (bytes, start, end) => {
  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
};
var fromString = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder.encode(string2) : utf8ToBytes(string2);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes, start, end) => {
  if (isBuffer2(bytes)) {
    return new Uint8Array(bytes.subarray(start, end));
  }
  return bytes.slice(start, end);
} : (bytes, start, end) => {
  return bytes.slice(start, end);
};
var concat = useBuffer ? (chunks, length5) => {
  chunks = chunks.map((c2) => c2 instanceof Uint8Array ? c2 : globalThis.Buffer.from(c2));
  return asU8A(globalThis.Buffer.concat(chunks, length5));
} : (chunks, length5) => {
  const out = new Uint8Array(length5);
  let off = 0;
  for (let b2 of chunks) {
    if (off + b2.length > out.length) {
      b2 = b2.subarray(0, out.length - off);
    }
    out.set(b2, off);
    off += b2.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length5 = string2.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i2 = 0; i2 < length5; ++i2) {
    codePoint = string2.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length5) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// ../../node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// ../../node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// ../../node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// ../../node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// ../../node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length5) {
  assertEnoughData(data, pos, prefix + length5);
  const buf2 = slice(data, pos + prefix, pos + prefix + length5);
  return new Token(Type.bytes, buf2, prefix + length5);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l2);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// ../../node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length5, options) {
  const totLength = prefix + length5;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l2, options);
}
var encodeString = encodeBytes;

// ../../node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length5) {
  return new Token(Type.array, length5, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l2);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length5) {
  return new Token(Type.map, length5, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l2);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// ../../node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token(Type.negint, i2, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// ../../node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p2 = this;
    do {
      if (p2.obj === obj) {
        return true;
      }
    } while (p2 = p2.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e2 of obj) {
      entries[i2++] = objectToTokens(e2, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length5 = isMap ? obj.size : keys.length;
    if (!length5) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys) {
      entries[i2++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length5),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length5),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// ../../node_modules/cborg/esm/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i2 = 0; i2 < token.value; i2++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
    }
    arr[i2] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token.value; i2++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m2.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m2 : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// ../../node_modules/multiformats/vendor/varint.js
var encode_1 = encode2;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode2(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode2.bytes = offset - oldOffset + 1;
  return out;
}
var decode2 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1) << shift : (b2 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode2,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/multiformats/src/varint.js
var decode3 = (data, offset = 0) => {
  const code9 = varint_default.decode(data, offset);
  return [code9, varint_default.decode.bytes];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/multiformats/src/bytes.js
var bytes_exports2 = {};
__export(bytes_exports2, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString2,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString2
});
var empty = new Uint8Array(0);
var toHex = (d2) => d2.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
var fromHex = (hex) => {
  const hexes3 = hex.match(/../g);
  return hexes3 ? new Uint8Array(hexes3.map((b2) => parseInt(b2, 16))) : empty;
};
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var isBinary = (o2) => o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
var fromString2 = (str) => new TextEncoder().encode(str);
var toString2 = (b2) => new TextDecoder().decode(b2);

// ../../node_modules/multiformats/src/hashes/digest.js
var create = (code9, digest3) => {
  const size = digest3.byteLength;
  const sizeOffset = encodingLength(code9);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code9, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest3, digestOffset);
  return new Digest(code9, size, digest3, bytes);
};
var decode4 = (multihash) => {
  const bytes = coerce(multihash);
  const [code9, sizeOffset] = decode3(bytes);
  const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
  const digest3 = bytes.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code9, size, digest3, bytes);
};
var equals2 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b2
    );
    return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals(a2.bytes, data.bytes);
  }
};
var Digest = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code9, size, digest3, bytes) {
    this.code = code9;
    this.size = size;
    this.digest = digest3;
    this.bytes = bytes;
  }
};

// ../../node_modules/multiformats/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});

// ../../node_modules/multiformats/vendor/base-x.js
function base(ALPHABET, name6) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode17(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length5) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      pbegin++;
    }
    var it2 = size - length5;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length5) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length5;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode25(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name6} character`);
  }
  return {
    encode: encode17,
    decodeUnsafe,
    decode: decode25
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// ../../node_modules/multiformats/src/bases/base.js
var Encoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name6, prefix, baseEncode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name6, prefix, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name6, prefix, baseEncode, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name6, prefix, baseEncode);
    this.decoder = new Decoder(name6, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name6, prefix, encode: encode17, decode: decode25 }) => new Codec(name6, prefix, encode17, decode25);
var baseX = ({ prefix, name: name6, alphabet: alphabet2 }) => {
  const { encode: encode17, decode: decode25 } = base_x_default(alphabet2, name6);
  return from({
    prefix,
    name: name6,
    encode: encode17,
    /**
     * @param {string} text
     */
    decode: (text) => coerce(decode25(text))
  });
};
var decode5 = (string2, alphabet2, bitsPerChar, name6) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes[alphabet2[i2]] = i2;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name6} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode3 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name6,
    encode(input) {
      return encode3(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode5(input, alphabet2, bitsPerChar, name6);
    }
  });
};

// ../../node_modules/multiformats/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/multiformats/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/multiformats/src/cid.js
var format = (link, base6) => {
  const { bytes, version: version4 } = link;
  switch (version4) {
    case 0:
      return toStringV0(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base6 || base58btc.encoder
      );
    default:
      return toStringV1(
        bytes,
        baseCache(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base6 || base32.encoder
      );
  }
};
var cache = /* @__PURE__ */ new WeakMap();
var baseCache = (cid) => {
  const baseCache2 = cache.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
};
var CID = class {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version4, code9, multihash, bytes) {
    this.code = code9;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code9, multihash } = this;
        if (code9 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code9, digest: digest3 } = this.multihash;
        const multihash = create(code9, digest3);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base6) {
    return format(this, base6);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version4, code: code9, multihash, bytes } = value;
      return new CID(
        version4,
        code9,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes || encodeCID(version4, code9, multihash.bytes)
      );
    } else if (value[cidSymbol] === true) {
      const { version: version4, multihash, code: code9 } = value;
      const digest3 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode4(multihash)
      );
      return CID.create(version4, code9, digest3);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version4, code9, digest3) {
    if (typeof code9 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest3.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version4) {
      case 0: {
        if (code9 !== DAG_PB_CODE) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
          );
        } else {
          return new CID(version4, code9, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version4, code9, digest3.bytes);
        return new CID(version4, code9, digest3, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest3) {
    return CID.create(0, DAG_PB_CODE, digest3);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code9, digest3) {
    return CID.create(1, code9, digest3);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes) {
    const specs = CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(
      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest3 = new Digest(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest3
    ) : CID.createV1(specs.codec, digest3);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length5] = decode3(initialBytes.subarray(offset));
      offset += length5;
      return i2;
    };
    let version4 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE
    );
    if (
      /** @type {number} */
      version4 === 18
    ) {
      version4 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version4, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base6) {
    const [prefix, bytes] = parseCIDtoBytes(source, base6);
    const cid = CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base6) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base6 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base6 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base6 || base32;
      return [
        /** @type {Prefix} */
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base6 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base6.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version4, code9, multihash) => {
  const codeOffset = encodingLength(version4);
  const hashOffset = codeOffset + encodingLength(code9);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version4, bytes, 0);
  encodeTo(code9, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");

// ../../node_modules/@ipld/dag-cbor/src/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name = "dag-cbor";
var code = 113;
var encode4 = (node) => encode(node, encodeOptions);
var decode6 = (data) => decode(data, decodeOptions);

// ../../node_modules/it-batch/dist/src/index.js
async function* batch(source, size = 1) {
  let things = [];
  if (size < 1) {
    size = 1;
  }
  for await (const thing of source) {
    things.push(thing);
    while (things.length >= size) {
      yield things.slice(0, size);
      things = things.slice(size);
    }
  }
  while (things.length > 0) {
    yield things.slice(0, size);
    things = things.slice(size);
  }
}

// ../../node_modules/it-parallel-batch/dist/src/index.js
async function* parallelBatch(source, size = 1) {
  for await (const tasks of batch(source, size)) {
    const things = tasks.map(async (p2) => {
      return await p2().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
    });
    for (let i2 = 0; i2 < things.length; i2++) {
      const result = await things[i2];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/ipfs-unixfs/dist/src/index.js
var import_err_code = __toESM(require_err_code(), 1);

// ../../node_modules/protons-runtime/dist/src/utils.js
var import_reader = __toESM(require_reader(), 1);
var import_reader_buffer = __toESM(require_reader_buffer(), 1);
var import_minimal = __toESM(require_minimal(), 1);
var import_writer = __toESM(require_writer(), 1);
var import_writer_buffer = __toESM(require_writer_buffer(), 1);
function configure() {
  import_minimal.default._configure();
  import_reader.default._configure(import_reader_buffer.default);
  import_writer.default._configure(import_writer_buffer.default);
}
configure();
var methods = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader(buf2) {
  return patchReader(new import_reader.default(buf2));
}
function patchWriter(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer() {
  return patchWriter(import_writer.default.create());
}

// ../../node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf2, codec) {
  const r2 = reader(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  return codec.decode(r2);
}

// ../../node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message2, codec) {
  const w2 = writer();
  codec.encode(message2, w2, {
    lengthDelimited: false
  });
  return w2.finish();
}

// ../../node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec(name6, type, encode17, decode25) {
  return {
    name: name6,
    type,
    encode: encode17,
    decode: decode25
  };
}

// ../../node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v2) {
  function findValue(val) {
    if (v2[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v2[val];
  }
  const encode17 = function enumEncode(val, writer2) {
    const enumValue = findValue(val);
    writer2.int32(enumValue);
  };
  const decode25 = function enumDecode(reader2) {
    const val = reader2.int32();
    return findValue(val);
  };
  return createCodec("enum", CODEC_TYPES.VARINT, encode17, decode25);
}

// ../../node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode17, decode25) {
  return createCodec("message", CODEC_TYPES.LENGTH_DELIMITED, encode17, decode25);
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/ipfs-unixfs/dist/src/unixfs.js
var Data;
(function(Data3) {
  let DataType;
  (function(DataType2) {
    DataType2["Raw"] = "Raw";
    DataType2["Directory"] = "Directory";
    DataType2["File"] = "File";
    DataType2["Metadata"] = "Metadata";
    DataType2["Symlink"] = "Symlink";
    DataType2["HAMTShard"] = "HAMTShard";
  })(DataType = Data3.DataType || (Data3.DataType = {}));
  let __DataTypeValues;
  (function(__DataTypeValues2) {
    __DataTypeValues2[__DataTypeValues2["Raw"] = 0] = "Raw";
    __DataTypeValues2[__DataTypeValues2["Directory"] = 1] = "Directory";
    __DataTypeValues2[__DataTypeValues2["File"] = 2] = "File";
    __DataTypeValues2[__DataTypeValues2["Metadata"] = 3] = "Metadata";
    __DataTypeValues2[__DataTypeValues2["Symlink"] = 4] = "Symlink";
    __DataTypeValues2[__DataTypeValues2["HAMTShard"] = 5] = "HAMTShard";
  })(__DataTypeValues || (__DataTypeValues = {}));
  (function(DataType2) {
    DataType2.codec = () => {
      return enumeration(__DataTypeValues);
    };
  })(DataType = Data3.DataType || (Data3.DataType = {}));
  let _codec;
  Data3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          Data3.DataType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (obj.filesize != null) {
          w2.uint32(24);
          w2.uint64(obj.filesize);
        }
        if (obj.blocksizes != null) {
          for (const value of obj.blocksizes) {
            w2.uint32(32);
            w2.uint64(value);
          }
        }
        if (obj.hashType != null) {
          w2.uint32(40);
          w2.uint64(obj.hashType);
        }
        if (obj.fanout != null) {
          w2.uint32(48);
          w2.uint64(obj.fanout);
        }
        if (obj.mode != null) {
          w2.uint32(56);
          w2.uint32(obj.mode);
        }
        if (obj.mtime != null) {
          w2.uint32(66);
          UnixTime.codec().encode(obj.mtime, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          blocksizes: []
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = Data3.DataType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            case 3:
              obj.filesize = reader2.uint64();
              break;
            case 4:
              obj.blocksizes.push(reader2.uint64());
              break;
            case 5:
              obj.hashType = reader2.uint64();
              break;
            case 6:
              obj.fanout = reader2.uint64();
              break;
            case 7:
              obj.mode = reader2.uint32();
              break;
            case 8:
              obj.mtime = UnixTime.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Data3.encode = (obj) => {
    return encodeMessage(obj, Data3.codec());
  };
  Data3.decode = (buf2) => {
    return decodeMessage(buf2, Data3.codec());
  };
})(Data || (Data = {}));
var UnixTime;
(function(UnixTime3) {
  let _codec;
  UnixTime3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Seconds != null) {
          w2.uint32(8);
          w2.int64(obj.Seconds);
        }
        if (obj.FractionalNanoseconds != null) {
          w2.uint32(21);
          w2.fixed32(obj.FractionalNanoseconds);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Seconds = reader2.int64();
              break;
            case 2:
              obj.FractionalNanoseconds = reader2.fixed32();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  UnixTime3.encode = (obj) => {
    return encodeMessage(obj, UnixTime3.codec());
  };
  UnixTime3.decode = (buf2) => {
    return decodeMessage(buf2, UnixTime3.codec());
  };
})(UnixTime || (UnixTime = {}));
var Metadata;
(function(Metadata3) {
  let _codec;
  Metadata3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.MimeType != null) {
          w2.uint32(10);
          w2.string(obj.MimeType);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.MimeType = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata3.encode = (obj) => {
    return encodeMessage(obj, Metadata3.codec());
  };
  Metadata3.decode = (buf2) => {
    return decodeMessage(buf2, Metadata3.codec());
  };
})(Metadata || (Metadata = {}));

// ../../node_modules/ipfs-unixfs-importer/node_modules/ipfs-unixfs/dist/src/index.js
var types = {
  Raw: "raw",
  Directory: "directory",
  File: "file",
  Metadata: "metadata",
  Symlink: "symlink",
  HAMTShard: "hamt-sharded-directory"
};
var dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
var UnixFS = class {
  /**
   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
   */
  static unmarshal(marshaled) {
    const message2 = Data.decode(marshaled);
    const data = new UnixFS({
      type: types[message2.Type != null ? message2.Type.toString() : "File"],
      data: message2.Data,
      blockSizes: message2.blocksizes,
      mode: message2.mode,
      mtime: message2.mtime != null ? {
        secs: message2.mtime.Seconds ?? 0n,
        nsecs: message2.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = message2.mode ?? 0;
    return data;
  }
  constructor(options = {
    type: "file"
  }) {
    const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
    if (type != null && !Object.values(types).includes(type)) {
      throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type ?? "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes ?? [];
    this._originalMode = 0;
    this.mode = mode;
    this.mtime = mtime;
  }
  set mode(mode) {
    if (mode == null) {
      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    } else {
      this._mode = mode & 4095;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return dirTypes.includes(this.type);
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  /**
   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else
   */
  fileSize() {
    if (this.isDirectory()) {
      return 0n;
    }
    let sum = 0n;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data != null) {
      sum += BigInt(this.data.length);
    }
    return sum;
  }
  /**
   * encode to protobuf Uint8Array
   */
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = Data.DataType.Raw;
        break;
      case "directory":
        type = Data.DataType.Directory;
        break;
      case "file":
        type = Data.DataType.File;
        break;
      case "metadata":
        type = Data.DataType.Metadata;
        break;
      case "symlink":
        type = Data.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = Data.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code.default)(new Error(`Type: ${type} is not valid`), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (this.data == null || this.data.length === 0) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (this.mode ?? 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      mtime = {
        Seconds: this.mtime.secs,
        FractionalNanoseconds: this.mtime.nsecs
      };
    }
    return Data.encode({
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    });
  }
};

// ../../node_modules/ipfs-unixfs-importer/node_modules/@ipld/dag-pb/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  code: () => code2,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode7,
  encode: () => encode5,
  name: () => name2,
  prepare: () => prepare,
  validate: () => validate
});

// ../../node_modules/ipfs-unixfs-importer/node_modules/@ipld/dag-pb/src/pb-decode.js
var textDecoder2 = new TextDecoder();
function decodeVarint(bytes, offset) {
  let v2 = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b2 = bytes[offset++];
    v2 += shift < 28 ? (b2 & 127) << shift : (b2 & 127) * 2 ** shift;
    if (b2 < 128) {
      break;
    }
  }
  return [v2, offset];
}
function decodeBytes(bytes, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes, index) {
  let wire;
  [wire, index] = decodeVarint(bytes, index);
  return [wire & 7, wire >> 3, index];
}
function decodeLink(bytes) {
  const link = {};
  const l2 = bytes.length;
  let index = 0;
  while (index < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index] = decodeBytes(bytes, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      link.Name = textDecoder2.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index] = decodeVarint(bytes, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l2) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes) {
  const l2 = bytes.length;
  let index = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index] = decodeBytes(bytes, index);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l2) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/@ipld/dag-pb/src/pb-encode.js
var textEncoder2 = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes) {
  let i2 = bytes.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i2 = encodeVarint(bytes, i2, link.Tsize) - 1;
    bytes[i2] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder2.encode(link.Name);
    i2 -= nameBytes.length;
    bytes.set(nameBytes, i2);
    i2 = encodeVarint(bytes, i2, nameBytes.length) - 1;
    bytes[i2] = 18;
  }
  if (link.Hash) {
    i2 -= link.Hash.length;
    bytes.set(link.Hash, i2);
    i2 = encodeVarint(bytes, i2, link.Hash.length) - 1;
    bytes[i2] = 10;
  }
  return bytes.length - i2;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes = new Uint8Array(size);
  let i2 = size;
  if (node.Data) {
    i2 -= node.Data.length;
    bytes.set(node.Data, i2);
    i2 = encodeVarint(bytes, i2, node.Data.length) - 1;
    bytes[i2] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes.subarray(0, i2));
      i2 -= size2;
      i2 = encodeVarint(bytes, i2, size2) - 1;
      bytes[i2] = 18;
    }
  }
  return bytes;
}
function sizeLink(link) {
  let n2 = 0;
  if (link.Hash) {
    const l2 = link.Hash.length;
    n2 += 1 + l2 + sov(l2);
  }
  if (typeof link.Name === "string") {
    const l2 = textEncoder2.encode(link.Name).length;
    n2 += 1 + l2 + sov(l2);
  }
  if (typeof link.Tsize === "number") {
    n2 += 1 + sov(link.Tsize);
  }
  return n2;
}
function sizeNode(node) {
  let n2 = 0;
  if (node.Data) {
    const l2 = node.Data.length;
    n2 += 1 + l2 + sov(l2);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l2 = sizeLink(link);
      n2 += 1 + l2 + sov(l2);
    }
  }
  return n2;
}
function encodeVarint(bytes, offset, v2) {
  offset -= sov(v2);
  const base6 = offset;
  while (v2 >= maxUInt32) {
    bytes[offset++] = v2 & 127 | 128;
    v2 /= 128;
  }
  while (v2 >= 128) {
    bytes[offset++] = v2 & 127 | 128;
    v2 >>>= 7;
  }
  bytes[offset] = v2;
  return base6;
}
function sov(x2) {
  if (x2 % 2 === 0) {
    x2++;
  }
  return Math.floor((len64(x2) + 6) / 7);
}
function len64(x2) {
  let n2 = 0;
  if (x2 >= maxInt32) {
    x2 = Math.floor(x2 / maxInt32);
    n2 = 32;
  }
  if (x2 >= 1 << 16) {
    x2 >>>= 16;
    n2 += 16;
  }
  if (x2 >= 1 << 8) {
    x2 >>>= 8;
    n2 += 8;
  }
  return n2 + len8tab[x2];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// ../../node_modules/ipfs-unixfs-importer/node_modules/@ipld/dag-pb/src/util.js
var pbNodeProperties = ["Data", "Links"];
var pbLinkProperties = ["Hash", "Name", "Tsize"];
var textEncoder3 = new TextEncoder();
function linkComparator(a2, b2) {
  if (a2 === b2) {
    return 0;
  }
  const abuf = a2.Name ? textEncoder3.encode(a2.Name) : [];
  const bbuf = b2.Name ? textEncoder3.encode(b2.Name) : [];
  let x2 = abuf.length;
  let y2 = bbuf.length;
  for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
    if (abuf[i2] !== bbuf[i2]) {
      x2 = abuf[i2];
      y2 = bbuf[i2];
      break;
    }
  }
  return x2 < y2 ? -1 : y2 < x2 ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p2) => !properties.includes(p2));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e2) {
      throw new TypeError(`Invalid DAG-PB form: ${e2.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder3.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be a list)");
  }
  for (let i2 = 0; i2 < node.Links.length; i2++) {
    const link = node.Links[i2];
    if (!link || typeof link !== "object" || Array.isArray(link) || link instanceof Uint8Array || link["/"] && link["/"] === link.bytes) {
      throw new TypeError("Invalid DAG-PB form (bad link)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
    }
    if (link.Hash === void 0) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash == null || !link.Hash["/"] || link.Hash["/"] !== link.Hash.bytes) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0) {
      if (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (link.Tsize < 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
      }
    }
    if (i2 > 0 && linkComparator(link, node.Links[i2 - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links2 = []) {
  return prepare({ Data: data, Links: links2 });
}
function createLink(name6, size, cid) {
  return asLink({ Hash: cid, Name: name6, Tsize: size });
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/@ipld/dag-pb/src/index.js
var name2 = "dag-pb";
var code2 = 112;
function encode5(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l2) => {
      const link = {};
      if (l2.Hash) {
        link.Hash = l2.Hash.bytes;
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode7(bytes) {
  const pbn = decodeNode(bytes);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l2) => {
      const link = {};
      try {
        link.Hash = CID.decode(l2.Hash);
      } catch (e2) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  return node;
}

// ../../node_modules/multiformats/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var import_crypto = __toESM(require("crypto"), 1);

// ../../node_modules/multiformats/src/hashes/hasher.js
var from2 = ({ name: name6, code: code9, encode: encode17 }) => new Hasher(name6, code9, encode17);
var Hasher = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name6, code9, encode17) {
    this.name = name6;
    this.code = code9;
    this.encode = encode17;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest3) => create(this.code, digest3));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/multiformats/src/hashes/sha2.js
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce(import_crypto.default.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce(import_crypto.default.createHash("sha512").update(input).digest())
});

// ../../node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js
var persist = async (buffer2, blockstore, options) => {
  if (options.codec == null) {
    options.codec = src_exports2;
  }
  const multihash = await sha256.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  await blockstore.put(cid, buffer2, {
    signal: options.signal
  });
  return cid;
};

// ../../node_modules/ipfs-unixfs-importer/dist/src/dag-builder/dir.js
var dirBuilder = async (dir, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: dir.mtime,
    mode: dir.mode
  });
  const buffer2 = encode5(prepare({ Data: unixfs.marshal() }));
  const cid = await persist(buffer2, blockstore, options);
  const path = dir.path;
  return {
    cid,
    path,
    unixfs,
    size: BigInt(buffer2.length),
    originalPath: dir.originalPath
  };
};

// ../../node_modules/multiformats/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code3,
  decode: () => decode8,
  encode: () => encode6,
  name: () => name3
});
var name3 = "raw";
var code3 = 85;
var encode6 = (node) => coerce(node);
var decode8 = (data) => coerce(data);

// ../../node_modules/ipfs-unixfs-importer/dist/src/dag-builder/file.js
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  for await (const entry of parallelBatch(options.bufferImporter(file, blockstore), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous != null) {
      yield previous;
      previous = void 0;
    }
    yield entry;
  }
  if (previous != null) {
    previous.single = true;
    yield previous;
  }
}
var reduce = (file, blockstore, options) => {
  const reducer = async function(leaves) {
    if (leaves.length === 1 && leaves[0]?.single === true && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer3 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer3
        });
        buffer3 = encode5(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist(buffer3, blockstore, {
          ...options,
          cidVersion: options.cidVersion
        });
        leaf.size = BigInt(buffer3.length);
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size,
        originalPath: leaf.originalPath
      };
    }
    const f2 = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links2 = leaves.filter((leaf) => {
      if (leaf.cid.code === code3 && leaf.size > 0) {
        return true;
      }
      if (leaf.unixfs != null && leaf.unixfs.data == null && leaf.unixfs.fileSize() > 0n) {
        return true;
      }
      return Boolean(leaf.unixfs?.data?.length);
    }).map((leaf) => {
      if (leaf.cid.code === code3) {
        f2.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: Number(leaf.size),
          Hash: leaf.cid
        };
      }
      if (leaf.unixfs == null || leaf.unixfs.data == null) {
        f2.addBlockSize(leaf.unixfs?.fileSize() ?? 0n);
      } else {
        f2.addBlockSize(BigInt(leaf.unixfs.data.length));
      }
      return {
        Name: "",
        Tsize: Number(leaf.size),
        Hash: leaf.cid
      };
    });
    const node = {
      Data: f2.marshal(),
      Links: links2
    };
    const buffer2 = encode5(prepare(node));
    const cid = await persist(buffer2, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f2,
      size: BigInt(buffer2.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)),
      originalPath: file.originalPath
    };
  };
  return reducer;
};
var fileBuilder = async (file, block, options) => {
  return await options.layout(buildFileBatch(file, block, options), reduce(file, block, options));
};

// ../../node_modules/ipfs-unixfs-importer/dist/src/dag-builder/index.js
var import_err_code2 = __toESM(require_err_code(), 1);
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw (0, import_err_code2.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code2.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
function defaultDagBuilder(options) {
  return async function* dagBuilder(source, blockstore) {
    for await (const entry of source) {
      let originalPath;
      if (entry.path != null) {
        originalPath = entry.path;
        entry.path = entry.path.split("/").filter((path) => path != null && path !== ".").join("/");
      }
      if (isFileCandidate(entry)) {
        const file = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode,
          content: options.chunker(options.chunkValidator(contentAsAsyncIterable(entry.content))),
          originalPath
        };
        yield async () => await fileBuilder(file, blockstore, options);
      } else if (entry.path != null) {
        const dir = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode,
          originalPath
        };
        yield async () => await dirBuilder(dir, blockstore, options);
      } else {
        throw new Error("Import candidate must have content or path or both");
      }
    }
  };
}
function isFileCandidate(entry) {
  return entry.content != null;
}

// ../../node_modules/ipfs-unixfs-importer/dist/src/dir.js
var Dir = class {
  constructor(props, options) {
    this.options = options ?? {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
  }
};
var CID_V0 = CID.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn");
var CID_V1 = CID.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");

// ../../node_modules/ipfs-unixfs-importer/dist/src/dir-flat.js
var DirFlat = class extends Dir {
  constructor(props, options) {
    super(props, options);
    this._children = /* @__PURE__ */ new Map();
  }
  async put(name6, value) {
    this.cid = void 0;
    this.size = void 0;
    this.nodeSize = void 0;
    this._children.set(name6, value);
  }
  async get(name6) {
    return await Promise.resolve(this._children.get(name6));
  }
  childCount() {
    return this._children.size;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children.values().next().value;
  }
  async *eachChildSeries() {
    for (const [key, child] of this._children.entries()) {
      yield {
        key,
        child
      };
    }
  }
  estimateNodeSize() {
    if (this.nodeSize !== void 0) {
      return this.nodeSize;
    }
    this.nodeSize = 0;
    for (const [name6, child] of this._children.entries()) {
      if (child.size != null && child.cid != null) {
        this.nodeSize += name6.length + (this.options.cidVersion === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength);
      }
    }
    return this.nodeSize;
  }
  async *flush(block) {
    const links2 = [];
    for (let [name6, child] of this._children.entries()) {
      if (child instanceof Dir) {
        for await (const entry of child.flush(block)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid != null) {
        links2.push({
          Name: name6,
          Tsize: Number(child.size),
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node = { Data: unixfs.marshal(), Links: links2 };
    const buffer2 = encode5(prepare(node));
    const cid = await persist(buffer2, block, this.options);
    const size = buffer2.length + node.Links.reduce(
      /**
       * @param {number} acc
       * @param {PBLink} curr
       */
      (acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize),
      0
    );
    this.cid = cid;
    this.size = size;
    yield {
      cid,
      unixfs,
      path: this.path,
      size: BigInt(size)
    };
  }
};

// ../../node_modules/ipfs-unixfs-importer/node_modules/hamt-sharding/dist/src/bucket.js
var import_sparse_array = __toESM(require_sparse_array(), 1);

// ../../node_modules/multiformats/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString2(buf2),
  decode: (str) => fromString2(str)
});

// ../../node_modules/multiformats/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// ../../node_modules/multiformats/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// ../../node_modules/multiformats/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// ../../node_modules/multiformats/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// ../../node_modules/multiformats/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// ../../node_modules/multiformats/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = (
  /** @type {string[]} */
  alphabet.reduce(
    (p2, c2, i2) => {
      p2[i2] = c2;
      return p2;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes = (
  /** @type {number[]} */
  alphabet.reduce(
    (p2, c2, i2) => {
      p2[
        /** @type {number} */
        c2.codePointAt(0)
      ] = i2;
      return p2;
    },
    /** @type {number[]} */
    []
  )
);
function encode7(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode9(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode7,
  decode: decode9
});

// ../../node_modules/multiformats/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code4 = 0;
var name4 = "identity";
var encode8 = coerce;
var digest = (input) => create(code4, encode8(input));
var identity2 = { code: code4, name: name4, encode: encode8, digest };

// ../../node_modules/multiformats/src/codecs/json.js
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// ../../node_modules/multiformats/src/basics.js
var bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_exports, ...identity_exports2 };

// ../../node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec2(name6, prefix, encode17, decode25) {
  return {
    name: name6,
    prefix,
    encoder: {
      name: name6,
      prefix,
      encode: encode17
    },
    decoder: {
      decode: decode25
    }
  };
}
var string = createCodec2("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec2("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// ../../node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/dist/src/from-string.js
function fromString3(string2, encoding = "utf8") {
  const base6 = bases_default[encoding];
  if (base6 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base6.decoder.decode(`${base6.prefix}${string2}`);
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/hamt-sharding/dist/src/bucket.js
var Bucket = class {
  constructor(options, parent, posAtParent = 0) {
    this._options = options;
    this._popCount = 0;
    this._parent = parent;
    this._posAtParent = posAtParent;
    this._children = new import_sparse_array.default();
    this.key = null;
  }
  async put(key, value) {
    const place = await this._findNewBucketAndPos(key);
    await place.bucket._putAt(place, key, value);
  }
  async get(key) {
    const child = await this._findChild(key);
    if (child != null) {
      return child.value;
    }
  }
  async del(key) {
    const place = await this._findPlace(key);
    const child = place.bucket._at(place.pos);
    if (child != null && child.key === key) {
      place.bucket._delAt(place.pos);
    }
  }
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
  }
  serialize(map, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index) => {
      if (child != null) {
        if (child instanceof Bucket) {
          acc2.push(child.serialize(map, reduce2));
        } else {
          acc2.push(map(child, index));
        }
      }
      return acc2;
    }, acc));
  }
  async asyncTransform(asyncMap, asyncReduce) {
    return await asyncTransformBucket(this, asyncMap, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  async _findChild(key) {
    const result = await this._findPlace(key);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket) {
      return void 0;
    }
    if (child != null && child.key === key) {
      return child;
    }
  }
  async _findPlace(key) {
    const hashValue = this._options.hash(typeof key === "string" ? fromString3(key) : key);
    const index = await hashValue.take(this._options.bits);
    const child = this._children.get(index);
    if (child instanceof Bucket) {
      return await child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index,
      hash: hashValue,
      existingChild: child
    };
  }
  async _findNewBucketAndPos(key) {
    const place = await this._findPlace(key);
    if (place.existingChild != null && place.existingChild.key !== key) {
      const bucket = new Bucket(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket);
      const newPlace = await bucket._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return await bucket._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  _putAt(place, key, value) {
    this._putObjectAt(place.pos, {
      key,
      value,
      hash: place.hash
    });
  }
  _putObjectAt(pos, object) {
    if (this._children.get(pos) == null) {
      this._popCount++;
    }
    this._children.set(pos, object);
  }
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos) != null) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent != null && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists);
        if (onlyChild != null && !(onlyChild instanceof Bucket)) {
          const hash = onlyChild.hash;
          hash.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  _at(index) {
    return this._children.get(index);
  }
};
function exists(o2) {
  return Boolean(o2);
}
function mapNode(node, _2) {
  return node.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
  const output = [];
  for (const child of bucket._children.compactArray()) {
    if (child instanceof Bucket) {
      await asyncTransformBucket(child, asyncMap, asyncReduce);
    } else {
      const mappedChildren = await asyncMap(child);
      output.push({
        bitField: bucket._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return await asyncReduce(output);
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/hamt-sharding/dist/src/consumable-buffer.js
var START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
var STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
var ConsumableBuffer = class {
  constructor(value) {
    this._value = value;
    this._currentBytePos = value.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  take(bits) {
    let pendingBits = bits;
    let result = 0;
    while (pendingBits > 0 && this._haveBits()) {
      const byte = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value = byteBitsToInt(byte, availableBits - taking, taking);
      result = (result << taking) + value;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  untake(bits) {
    this._currentBitPos += bits;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
};
function byteBitsToInt(byte, start, length5) {
  const mask = maskFor(start, length5);
  return (byte & mask) >>> start;
}
function maskFor(start, length5) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length5 + start - 1, 7)];
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/dist/src/concat.js
function concat2(arrays, length5) {
  if (length5 == null) {
    length5 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length5);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/hamt-sharding/dist/src/consumable-hash.js
function wrapHash(hashFn2) {
  function hashing(value) {
    if (value instanceof InfiniteHash) {
      return value;
    } else {
      return new InfiniteHash(value, hashFn2);
    }
  }
  return hashing;
}
var InfiniteHash = class {
  constructor(value, hashFn2) {
    if (!(value instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value;
    this._hashFn = hashFn2;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  async take(bits) {
    let pendingBits = bits;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash.availableBits(), pendingBits);
      const took = hash.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  untake(bits) {
    let pendingBits = bits;
    while (pendingBits > 0) {
      const hash = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
      hash.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value = this._depth > 0 ? concat2([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value);
    const buffer2 = new ConsumableBuffer(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
};

// ../../node_modules/ipfs-unixfs-importer/node_modules/hamt-sharding/dist/src/index.js
function createHAMT(options) {
  if (options == null || options.hashFn == null) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options.bits ?? 8,
    hash: wrapHash(options.hashFn)
  };
  return new Bucket(bucketOptions);
}

// ../../node_modules/ipfs-unixfs-importer/node_modules/@multiformats/murmur3/src/index.js
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
function fromNumberTo32BitBuf(number) {
  const bytes = new Array(4);
  for (let i2 = 0; i2 < 4; i2++) {
    bytes[i2] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes);
}
var murmur332 = from2({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
});
var murmur3128 = from2({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports2.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
});
var murmur364 = from2({
  name: "murmur3-x64-64",
  code: 34,
  encode: (input) => bytes_exports2.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input)).subarray(0, 8)
});

// ../../node_modules/ipfs-unixfs-importer/dist/src/dir-sharded.js
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
var HAMT_HASH_CODE = BigInt(34);
var DirSharded = class extends Dir {
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: hamtHashFn,
      bits: 8
    });
  }
  async put(name6, value) {
    this.cid = void 0;
    this.size = void 0;
    this.nodeSize = void 0;
    await this._bucket.put(name6, value);
  }
  async get(name6) {
    return await this._bucket.get(name6);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  estimateNodeSize() {
    if (this.nodeSize !== void 0) {
      return this.nodeSize;
    }
    this.nodeSize = calculateSize(this._bucket, this, this.options);
    return this.nodeSize;
  }
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
};
var dir_sharded_default = DirSharded;
async function* flush(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links2 = [];
  let childrenSize = 0n;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (child == null) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of flush(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (shard == null) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: Number(shard.size),
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (isDir(child.value)) {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      if (flushedDir == null) {
        throw new Error("Did not flush dir");
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: Number(flushedDir.size),
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (value.cid == null) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links2.push({
        Name: label,
        Tsize: Number(size2),
        Hash: value.cid
      });
      childrenSize += BigInt(size2 ?? 0);
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: BigInt(bucket.tableSize()),
    hashType: HAMT_HASH_CODE,
    mtime: shardRoot?.mtime,
    mode: shardRoot?.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode5(prepare(node));
  const cid = await persist(buffer2, blockstore, options);
  const size = BigInt(buffer2.byteLength) + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}
function isDir(obj) {
  return typeof obj.flush === "function";
}
function calculateSize(bucket, shardRoot, options) {
  const children = bucket._children;
  const links2 = [];
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children.get(i2);
    if (child == null) {
      continue;
    }
    const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      const size = calculateSize(child, null, options);
      links2.push({
        Name: labelPrefix,
        Tsize: Number(size),
        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1
      });
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      const size = dir2.nodeSize();
      links2.push({
        Name: labelPrefix + child.key,
        Tsize: Number(size),
        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1
      });
    } else {
      const value = child.value;
      if (value.cid == null) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size = value.size;
      links2.push({
        Name: label,
        Tsize: Number(size),
        Hash: value.cid
      });
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: BigInt(bucket.tableSize()),
    hashType: HAMT_HASH_CODE,
    mtime: shardRoot?.mtime,
    mode: shardRoot?.mode
  });
  const buffer2 = encode5(prepare({
    Data: dir.marshal(),
    Links: links2
  }));
  return buffer2.length;
}

// ../../node_modules/ipfs-unixfs-importer/dist/src/flat-to-shard.js
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof DirFlat && dir.estimateNodeSize() > threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent = newDir.parent;
  if (parent != null) {
    if (newDir !== dir) {
      if (child != null) {
        child.parent = newDir;
      }
      if (newDir.parentKey == null) {
        throw new Error("No parent key found");
      }
      await parent.put(newDir.parentKey, newDir);
    }
    return await flatToShard(newDir, parent, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new dir_sharded_default({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}

// ../../node_modules/ipfs-unixfs-importer/dist/src/utils/to-path-components.js
var toPathComponents = (path = "") => {
  return (path.trim().match(/([^\\/]|\\\/)+/g) ?? []).filter(Boolean);
};

// ../../node_modules/ipfs-unixfs-importer/dist/src/tree-builder.js
async function addToTree(elem, tree2, options) {
  const pathElems = toPathComponents(elem.path ?? "");
  const lastIndex = pathElems.length - 1;
  let parent = tree2;
  let currentPath = "";
  for (let i2 = 0; i2 < pathElems.length; i2++) {
    const pathElem = pathElems[i2];
    currentPath += `${currentPath !== "" ? "/" : ""}${pathElem}`;
    const last2 = i2 === lastIndex;
    parent.dirty = true;
    parent.cid = void 0;
    parent.size = void 0;
    if (last2) {
      await parent.put(pathElem, elem);
      tree2 = await flatToShard(null, parent, options.shardSplitThresholdBytes, options);
    } else {
      let dir = await parent.get(pathElem);
      if (dir == null || !(dir instanceof Dir)) {
        dir = new DirFlat({
          root: false,
          dir: true,
          parent,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir?.unixfs?.mtime,
          mode: dir?.unixfs?.mode
        }, options);
      }
      await parent.put(pathElem, dir);
      parent = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof Dir)) {
    if (tree2.unixfs?.isDirectory() === true) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
function defaultTreeBuilder(options) {
  return async function* treeBuilder(source, block) {
    let tree2 = new DirFlat({
      root: true,
      dir: true,
      path: "",
      dirty: true,
      flat: true
    }, options);
    let rootDir;
    let singleRoot = false;
    for await (const entry of source) {
      if (entry == null) {
        continue;
      }
      const dir = `${entry.originalPath ?? ""}`.split("/")[0];
      if (dir != null && dir !== "") {
        if (rootDir == null) {
          rootDir = dir;
          singleRoot = true;
        } else if (rootDir !== dir) {
          singleRoot = false;
        }
      }
      tree2 = await addToTree(entry, tree2, options);
      if (entry.unixfs == null || !entry.unixfs.isDirectory()) {
        yield entry;
      }
    }
    if (options.wrapWithDirectory || singleRoot && tree2.childCount() > 1) {
      yield* flushAndYield(tree2, block);
    } else {
      for await (const unwrapped of tree2.eachChildSeries()) {
        if (unwrapped == null) {
          continue;
        }
        yield* flushAndYield(unwrapped.child, block);
      }
    }
  };
}

// ../../node_modules/ipfs-unixfs-importer/dist/src/dag-builder/validate-chunks.js
var import_err_code3 = __toESM(require_err_code(), 1);
var defaultChunkValidator = () => {
  return async function* validateChunks(source) {
    for await (const content of source) {
      if (content.length === void 0) {
        throw (0, import_err_code3.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
      if (typeof content === "string" || content instanceof String) {
        yield fromString3(content.toString());
      } else if (Array.isArray(content)) {
        yield Uint8Array.from(content);
      } else if (content instanceof Uint8Array) {
        yield content;
      } else {
        throw (0, import_err_code3.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
    }
  };
};

// ../../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array2(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// ../../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js
function alloc2(size = 0) {
  if (globalThis.Buffer?.alloc != null) {
    return asUint8Array2(globalThis.Buffer.alloc(size));
  }
  return new Uint8Array(size);
}
function allocUnsafe2(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array2(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// ../../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js
function concat3(arrays, length5) {
  if (length5 == null) {
    length5 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe2(length5);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output);
}

// ../../node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js
function equals3(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2.byteLength !== b2.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/uint8arraylist/dist/src/index.js
var symbol = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf2 of bufs) {
    const bufEnd = offset + buf2.byteLength;
    if (index < bufEnd) {
      return {
        buf: buf2,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value?.[symbol]);
}
var Uint8ArrayList = class {
  constructor(...data) {
    Object.defineProperty(this, symbol, { value: true });
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length5 = 0;
    for (const buf2 of bufs) {
      if (buf2 instanceof Uint8Array) {
        length5 += buf2.byteLength;
        this.bufs.push(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length5 += buf2.byteLength;
        this.bufs.push(...buf2.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length5;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length5 = 0;
    for (const buf2 of bufs.reverse()) {
      if (buf2 instanceof Uint8Array) {
        length5 += buf2.byteLength;
        this.bufs.unshift(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length5 += buf2.byteLength;
        this.bufs.unshift(...buf2.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length5;
  }
  /**
   * Read the value at `index`
   */
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index, value) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf2, offset = 0) {
    if (buf2 instanceof Uint8Array) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2[i2]);
      }
    } else if (isUint8ArrayList(buf2)) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2.get(i2));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0) {
      return;
    }
    if (bytes === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes >= this.bufs[0].byteLength) {
        bytes -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes);
        this.length -= bytes;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length5 } = this._subList(beginInclusive, endExclusive);
    return concat3(bufs, length5);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length5 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat3(bufs, length5);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length5 } = this._subList(beginInclusive, endExclusive);
    const list = new Uint8ArrayList();
    list.length = length5;
    list.bufs = bufs;
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: [...this.bufs], length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      const buf2 = this.bufs[i2];
      const bufStart = offset;
      const bufEnd = bufStart + buf2.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        const start = beginInclusive - bufStart;
        bufs.push(buf2.subarray(start, start + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf2);
          continue;
        }
        bufs.push(buf2.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        bufs.push(buf2.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf2);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M2 = needle.byteLength;
    if (M2 === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c2 = 0; c2 < radix; c2++) {
      rightmostPositions[c2] = -1;
    }
    for (let j2 = 0; j2 < M2; j2++) {
      rightmostPositions[needle[j2]] = j2;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i2 = offset; i2 <= lastIndex; i2 += skip) {
      skip = 0;
      for (let j2 = lastPatIndex; j2 >= 0; j2--) {
        const char = this.get(i2 + j2);
        if (needle[j2] !== char) {
          skip = Math.max(1, j2 - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i2;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value) {
    const buf2 = allocUnsafe2(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt8(0, value);
    this.write(buf2, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value, littleEndian) {
    const buf2 = alloc2(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt16(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value, littleEndian) {
    const buf2 = alloc2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt32(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value, littleEndian) {
    const buf2 = alloc2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigInt64(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value) {
    const buf2 = allocUnsafe2(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint8(0, value);
    this.write(buf2, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value, littleEndian) {
    const buf2 = alloc2(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint16(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value, littleEndian) {
    const buf2 = alloc2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint32(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value, littleEndian) {
    const buf2 = alloc2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigUint64(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value, littleEndian) {
    const buf2 = alloc2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat32(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value, littleEndian) {
    const buf2 = alloc2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat64(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      if (!equals3(this.bufs[i2], other.bufs[i2])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length5) {
    const list = new Uint8ArrayList();
    list.bufs = bufs;
    if (length5 == null) {
      length5 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length5;
    return list;
  }
};

// ../../node_modules/ipfs-unixfs-importer/dist/src/chunker/fixed-size.js
var DEFAULT_CHUNK_SIZE = 262144;
var fixedSize = (options = {}) => {
  const chunkSize = options.chunkSize ?? DEFAULT_CHUNK_SIZE;
  return async function* fixedSizeChunker(source) {
    let list = new Uint8ArrayList();
    let currentLength = 0;
    let emitted = false;
    for await (const buffer2 of source) {
      list.append(buffer2);
      currentLength += buffer2.length;
      while (currentLength >= chunkSize) {
        yield list.slice(0, chunkSize);
        emitted = true;
        if (chunkSize === list.length) {
          list = new Uint8ArrayList();
          currentLength = 0;
        } else {
          const newBl = new Uint8ArrayList();
          newBl.append(list.sublist(chunkSize));
          list = newBl;
          currentLength -= chunkSize;
        }
      }
    }
    if (!emitted || currentLength > 0) {
      yield list.subarray(0, currentLength);
    }
  };
};

// ../../node_modules/ipfs-unixfs-importer/dist/src/layout/balanced.js
var DEFAULT_MAX_CHILDREN_PER_NODE = 174;
function balanced(options) {
  const maxChildrenPerNode = options?.maxChildrenPerNode ?? DEFAULT_MAX_CHILDREN_PER_NODE;
  return async function balancedLayout(source, reduce2) {
    const roots = [];
    for await (const chunked of batch(source, maxChildrenPerNode)) {
      roots.push(await reduce2(chunked));
    }
    if (roots.length > 1) {
      return await balancedLayout(roots, reduce2);
    }
    return roots[0];
  };
}

// ../../node_modules/it-all/dist/src/index.js
async function all(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// ../../node_modules/ipfs-unixfs-importer/dist/src/dag-builder/buffer-importer.js
function defaultBufferImporter(options) {
  return async function* bufferImporter(file, block) {
    for await (let buffer2 of file.content) {
      yield async () => {
        options.progress?.(buffer2.length, file.path);
        let unixfs;
        const opts = {
          codec: src_exports2,
          cidVersion: options.cidVersion
        };
        if (options.rawLeaves) {
          opts.codec = raw_exports;
          opts.cidVersion = 1;
        } else {
          unixfs = new UnixFS({
            type: options.leafType,
            data: buffer2
          });
          buffer2 = encode5({
            Data: unixfs.marshal(),
            Links: []
          });
        }
        return {
          cid: await persist(buffer2, block, opts),
          unixfs,
          size: BigInt(buffer2.length)
        };
      };
    }
  };
}

// ../../node_modules/ipfs-unixfs-importer/dist/src/index.js
var import_err_code4 = __toESM(require_err_code(), 1);
async function* importer(source, blockstore, options = {}) {
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  const wrapWithDirectory = options.wrapWithDirectory ?? false;
  const shardSplitThresholdBytes = options.shardSplitThresholdBytes ?? 262144;
  const cidVersion = options.cidVersion ?? 1;
  const rawLeaves = options.rawLeaves ?? true;
  const leafType = options.leafType ?? "file";
  const fileImportConcurrency = options.fileImportConcurrency ?? 50;
  const blockWriteConcurrency = options.blockWriteConcurrency ?? 10;
  const reduceSingleLeafToSelf = options.reduceSingleLeafToSelf ?? true;
  const chunker = options.chunker ?? fixedSize();
  const chunkValidator = options.chunkValidator ?? defaultChunkValidator();
  const buildDag = options.dagBuilder ?? defaultDagBuilder({
    chunker,
    chunkValidator,
    wrapWithDirectory,
    layout: options.layout ?? balanced(),
    bufferImporter: options.bufferImporter ?? defaultBufferImporter({
      cidVersion,
      rawLeaves,
      leafType,
      progress: options.progress
    }),
    blockWriteConcurrency,
    reduceSingleLeafToSelf,
    cidVersion
  });
  const buildTree = options.treeBuilder ?? defaultTreeBuilder({
    wrapWithDirectory,
    shardSplitThresholdBytes,
    cidVersion
  });
  for await (const entry of buildTree(parallelBatch(buildDag(candidates, blockstore), fileImportConcurrency), blockstore)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}

// ../../node_modules/blockstore-core/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  notFoundError: () => notFoundError
});
var import_err_code5 = __toESM(require_err_code(), 1);
function notFoundError(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code5.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code5.default)(err, "ERR_ABORTED");
}

// ../../node_modules/it-drain/dist/src/index.js
async function drain(source) {
  for await (const _2 of source) {
  }
}

// ../../node_modules/it-filter/dist/src/index.js
async function* filter(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}

// ../../node_modules/it-take/dist/src/index.js
async function* take(source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}

// ../../node_modules/blockstore-core/src/base.js
var sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await all(iterable);
    yield* values.sort(sorter);
  }();
};
var BaseBlockstore = class {
  /**
   * @returns {Promise<void>}
   */
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  /**
   * @returns {Promise<void>}
   */
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Uint8Array} val
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<Uint8Array>}
   */
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<boolean>}
   */
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  /**
   * @param {AwaitIterable<Pair>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  /**
   * @param {AwaitIterable<CID>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Uint8Array>}
   */
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  /**
   * @param {AwaitIterable<CID>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<CID>}
   */
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  /**
   * @returns {Batch}
   */
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await drain(this.putMany(puts, options));
        puts = [];
        await drain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   *
   * @param {Query} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  // eslint-disable-next-line require-yield
  async *_all(q2, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   *
   * @param {KeyQuery} q
   * @param {Options} [options]
   * @returns {AsyncIterable<CID>}
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q2, options) {
    throw new Error("._allKeys is not implemented");
  }
  /**
   * @param {Query} q
   * @param {Options} [options]
   */
  query(q2, options) {
    let it2 = this._all(q2, options);
    if (q2.prefix != null) {
      it2 = filter(
        it2,
        (e2) => e2.key.toString().startsWith(q2.prefix || "")
      );
    }
    if (Array.isArray(q2.filters)) {
      it2 = q2.filters.reduce((it3, f2) => filter(it3, f2), it2);
    }
    if (Array.isArray(q2.orders)) {
      it2 = q2.orders.reduce((it3, f2) => sortAll(it3, f2), it2);
    }
    if (q2.offset != null) {
      let i2 = 0;
      it2 = filter(it2, () => i2++ >= (q2.offset || 0));
    }
    if (q2.limit != null) {
      it2 = take(it2, q2.limit);
    }
    return it2;
  }
  /**
   * @param {KeyQuery} q
   * @param {Options} [options]
   */
  queryKeys(q2, options) {
    let it2 = this._allKeys(q2, options);
    if (q2.prefix != null) {
      it2 = filter(it2, (cid) => cid.toString().startsWith(q2.prefix || ""));
    }
    if (Array.isArray(q2.filters)) {
      it2 = q2.filters.reduce((it3, f2) => filter(it3, f2), it2);
    }
    if (Array.isArray(q2.orders)) {
      it2 = q2.orders.reduce((it3, f2) => sortAll(it3, f2), it2);
    }
    if (q2.offset != null) {
      let i2 = 0;
      it2 = filter(it2, () => i2++ >= /** @type {number} */
      q2.offset);
    }
    if (q2.limit != null) {
      it2 = take(it2, q2.limit);
    }
    return it2;
  }
};

// ../../node_modules/blockstore-core/src/memory.js
var MemoryBlockstore = class extends BaseBlockstore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  /**
   * @param {CID} key
   * @param {Uint8Array} val
   */
  async put(key, val) {
    this.data[base32.encode(key.multihash.bytes)] = val;
  }
  /**
   * @param {CID} key
   */
  async get(key) {
    const exists2 = await this.has(key);
    if (!exists2)
      throw notFoundError();
    return this.data[base32.encode(key.multihash.bytes)];
  }
  /**
   * @param {CID} key
   */
  async has(key) {
    return this.data[base32.encode(key.multihash.bytes)] !== void 0;
  }
  /**
   * @param {CID} key
   */
  async delete(key) {
    delete this.data[base32.encode(key.multihash.bytes)];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value]) => ({ key: CID.createV1(code3, decode4(base32.decode(key))), value }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => CID.createV1(code3, decode4(base32.decode(key))));
  }
};

// ../../node_modules/blockstore-core/src/index.js
var Errors = {
  ...errors_exports
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/cid.js
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve5, reject) {
        v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve5, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve5({ value: v3, done: d2 });
    }, reject);
  }
};
var hashers = {
  [sha256.code]: sha256
};
var codecs = {
  [code]: src_exports
};
function computeCid(payload, codecCode = code, multihashCode = sha256.code) {
  return __awaiter2(this, void 0, void 0, function* () {
    const codec = codecs[codecCode];
    if (!codec) {
      throw new Error(`codec [${codecCode}] not supported`);
    }
    const hasher = hashers[multihashCode];
    if (!hasher) {
      throw new Error(`multihash code [${multihashCode}] not supported`);
    }
    const payloadBytes = codec.encode(payload);
    const payloadHash = yield hasher.digest(payloadBytes);
    const cid = yield CID.createV1(codec.code, payloadHash);
    return cid.toString();
  });
}
function parseCid(str) {
  const cid = CID.parse(str).toV1();
  if (!codecs[cid.code]) {
    throw new Error(`codec [${cid.code}] not supported`);
  }
  if (!hashers[cid.multihash.code]) {
    throw new Error(`multihash code [${cid.multihash.code}] not supported`);
  }
  return cid;
}
var Cid = class {
  /**
   * @returns V1 CID of the DAG comprised by chunking data into unixfs DAG-PB encoded blocks
   */
  static computeDagPbCidFromBytes(content) {
    var e_1, _a2;
    return __awaiter2(this, void 0, void 0, function* () {
      const asyncDataBlocks = importer([{ content }], new MemoryBlockstore(), { cidVersion: 1 });
      let block;
      try {
        for (var asyncDataBlocks_1 = __asyncValues(asyncDataBlocks), asyncDataBlocks_1_1; asyncDataBlocks_1_1 = yield asyncDataBlocks_1.next(), !asyncDataBlocks_1_1.done; ) {
          block = asyncDataBlocks_1_1.value;
          ;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (asyncDataBlocks_1_1 && !asyncDataBlocks_1_1.done && (_a2 = asyncDataBlocks_1.return))
            yield _a2.call(asyncDataBlocks_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return block ? block.cid.toString() : "";
    });
  }
  /**
   * @returns V1 CID of the DAG comprised by chunking data into unixfs DAG-PB encoded blocks
   */
  static computeDagPbCidFromStream(dataStream) {
    var e_2, _a2;
    return __awaiter2(this, void 0, void 0, function* () {
      const asyncDataBlocks = importer([{ content: dataStream }], new MemoryBlockstore(), { cidVersion: 1 });
      let block;
      try {
        for (var asyncDataBlocks_2 = __asyncValues(asyncDataBlocks), asyncDataBlocks_2_1; asyncDataBlocks_2_1 = yield asyncDataBlocks_2.next(), !asyncDataBlocks_2_1.done; ) {
          block = asyncDataBlocks_2_1.value;
          ;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (asyncDataBlocks_2_1 && !asyncDataBlocks_2_1.done && (_a2 = asyncDataBlocks_2.return))
            yield _a2.call(asyncDataBlocks_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return block ? block.cid.toString() : "";
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/abort.js
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function promisifySignal(signal) {
  return new Promise((resolve5, reject) => {
    if (signal.aborted) {
      reject(signal.reason);
      return;
    }
    signal.addEventListener("abort", () => {
      reject(signal.reason);
    });
  });
}
function abortOr(signal, promise) {
  return __awaiter3(this, void 0, void 0, function* () {
    if (!signal) {
      return promise;
    }
    return Promise.race([
      promise,
      promisifySignal(signal)
    ]);
  });
}

// ../../node_modules/@js-temporal/polyfill/dist/index.esm.js
var import_jsbi = __toESM(require_jsbi_cjs(), 1);
var t = {};
function MakeIntrinsicClass(e2, t2) {
  Object.defineProperty(e2.prototype, Symbol.toStringTag, { value: t2, writable: false, enumerable: false, configurable: true });
  for (const t3 of Object.getOwnPropertyNames(e2)) {
    const r2 = Object.getOwnPropertyDescriptor(e2, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2, t3, r2));
  }
  for (const t3 of Object.getOwnPropertyNames(e2.prototype)) {
    const r2 = Object.getOwnPropertyDescriptor(e2.prototype, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2.prototype, t3, r2));
  }
  DefineIntrinsic(t2, e2), DefineIntrinsic(`${t2}.prototype`, e2.prototype);
}
function DefineIntrinsic(e2, r2) {
  const o2 = `%${e2}%`;
  if (void 0 !== t[o2])
    throw new Error(`intrinsic ${e2} already exists`);
  t[o2] = r2;
}
function GetIntrinsic(e2) {
  return t[e2];
}
var r = "slot-epochNanoSeconds";
var o = "slot-timezone-identifier";
var n = "slot-year";
var a = "slot-month";
var i = "slot-day";
var s = "slot-hour";
var l = "slot-minute";
var d = "slot-second";
var m = "slot-millisecond";
var c = "slot-microsecond";
var h = "slot-nanosecond";
var u = "slot-calendar";
var T = "slot-cached-instant";
var p = "slot-time-zone";
var f = "slot-years";
var y = "slot-months";
var S = "slot-weeks";
var w = "slot-days";
var g = "slot-hours";
var I = "slot-minutes";
var D = "slot-seconds";
var G = "slot-milliseconds";
var v = "slot-microseconds";
var O = "slot-nanoseconds";
var C = "slot-calendar-identifier";
var E = /* @__PURE__ */ new WeakMap();
function CreateSlots(e2) {
  E.set(e2, /* @__PURE__ */ Object.create(null));
}
function GetSlots(e2) {
  return E.get(e2);
}
function HasSlot(e2, ...t2) {
  if (!e2 || "object" != typeof e2)
    return false;
  const r2 = GetSlots(e2);
  return !!r2 && t2.reduce((e3, t3) => e3 && t3 in r2, true);
}
function GetSlot(e2, t2) {
  const r2 = GetSlots(e2)[t2];
  if (void 0 === r2)
    throw new TypeError(`Missing internal slot ${t2}`);
  return r2;
}
function SetSlot(e2, t2, r2) {
  GetSlots(e2)[t2] = r2;
}
var b = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
var M = new RegExp(`(?:(?:${b.source})(?:\\/(?:${b.source}))*|Etc/GMT[-+]\\d{1,2}|${/(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source})`);
var R = /[A-Za-z0-9]{3,8}/;
var Z = new RegExp(`(?:${R.source}(?:-${R.source})*)`);
var P = /(?:[+\u2212-]\d{6}|\d{4})/;
var F = /(?:0[1-9]|1[0-2])/;
var Y = /(?:0[1-9]|[12]\d|3[01])/;
var j = new RegExp(`(${P.source})(?:-(${F.source})-(${Y.source})|(${F.source})(${Y.source}))`);
var $ = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
var B = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
var N = new RegExp(`(?:([zZ])|(?:${B.source})?)(?:\\[(${M.source})\\])?`);
var k = new RegExp(`\\[u-ca=(${Z.source})\\]`);
var A = new RegExp(`^${j.source}(?:(?:T|\\s+)${$.source})?${N.source}(?:${k.source})?$`, "i");
var U = new RegExp(`^T?${$.source}(?:${N.source})?(?:${k.source})?$`, "i");
var L = new RegExp(`^(${P.source})-?(${F.source})$`);
var x = new RegExp(`^(?:--)?(${F.source})-?(${Y.source})$`);
var H = /(\d+)(?:[.,](\d{1,9}))?/;
var q = new RegExp(`(?:${H.source}H)?(?:${H.source}M)?(?:${H.source}S)?`);
var W = new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${q.source})?$`, "i");
var z = Array.prototype.includes;
var _ = Array.prototype.push;
var J = globalThis.Intl.DateTimeFormat;
var V = Math.min;
var X = Math.max;
var K = Math.abs;
var Q = Math.floor;
var ee = Math.sign;
var te = Math.trunc;
var re = Number.isNaN;
var oe = Number.isFinite;
var ne = Number;
var ae = String;
var ie = Number.MAX_SAFE_INTEGER;
var se = Object.assign;
var le = Object.create;
var de = Object.getOwnPropertyDescriptor;
var me = Object.is;
var ce = Reflect.apply;
var he = import_jsbi.default.BigInt(0);
var ue = import_jsbi.default.BigInt(1);
var Te = import_jsbi.default.BigInt(60);
var pe = import_jsbi.default.BigInt(1e3);
var fe = import_jsbi.default.BigInt(1e6);
var ye = import_jsbi.default.BigInt(1e9);
var Se = import_jsbi.default.BigInt(-1);
var we = import_jsbi.default.multiply(import_jsbi.default.BigInt(86400), ye);
var ge = import_jsbi.default.multiply(import_jsbi.default.BigInt(-86400), import_jsbi.default.BigInt(1e17));
var Ie = import_jsbi.default.multiply(import_jsbi.default.BigInt(86400), import_jsbi.default.BigInt(1e17));
var De = import_jsbi.default.multiply(import_jsbi.default.BigInt(-388152), import_jsbi.default.BigInt(1e13));
var Ge = import_jsbi.default.multiply(we, import_jsbi.default.BigInt(3660));
var ve = import_jsbi.default.multiply(we, import_jsbi.default.BigInt(366));
var Oe = import_jsbi.default.multiply(we, import_jsbi.default.BigInt(14));
var Ce = ["iso8601", "hebrew", "islamic", "islamic-umalqura", "islamic-tbla", "islamic-civil", "islamic-rgsa", "islamicc", "persian", "ethiopic", "ethioaa", "coptic", "chinese", "dangi", "roc", "indian", "buddhist", "japanese", "gregory"];
function IsInteger(e2) {
  if ("number" != typeof e2 || !oe(e2))
    return false;
  const t2 = K(e2);
  return Q(t2) === t2;
}
function IsObject(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
function ToNumber(e2) {
  if ("bigint" == typeof e2)
    throw new TypeError("Cannot convert BigInt to number");
  return ne(e2);
}
function ToInteger(e2) {
  const t2 = ToNumber(e2);
  if (re(t2))
    return 0;
  const r2 = te(t2);
  return 0 === t2 ? 0 : r2;
}
function ToString(e2) {
  if ("symbol" == typeof e2)
    throw new TypeError("Cannot convert a Symbol value to a String");
  return ae(e2);
}
function ToIntegerThrowOnInfinity(e2) {
  const t2 = ToInteger(e2);
  if (!oe(t2))
    throw new RangeError("infinity is out of range");
  return t2;
}
function ToPositiveInteger(e2, t2) {
  const r2 = ToInteger(e2);
  if (!oe(r2))
    throw new RangeError("infinity is out of range");
  if (r2 < 1) {
    if (void 0 !== t2)
      throw new RangeError(`property '${t2}' cannot be a a number less than one`);
    throw new RangeError("Cannot convert a number less than one to a positive integer");
  }
  return r2;
}
function ToIntegerWithoutRounding(e2) {
  const t2 = ToNumber(e2);
  if (re(t2))
    return 0;
  if (!oe(t2))
    throw new RangeError("infinity is out of range");
  if (!IsInteger(t2))
    throw new RangeError(`unsupported fractional value ${t2}`);
  return ToInteger(t2);
}
function divmod(t2, r2) {
  return { quotient: import_jsbi.default.divide(t2, r2), remainder: import_jsbi.default.remainder(t2, r2) };
}
function abs(t2) {
  return import_jsbi.default.lessThan(t2, he) ? import_jsbi.default.multiply(t2, Se) : t2;
}
function ArrayPush(e2, ...t2) {
  return _.apply(e2, t2), e2;
}
var Ee = /* @__PURE__ */ new Map([["year", ToIntegerThrowOnInfinity], ["month", ToPositiveInteger], ["monthCode", ToString], ["day", ToPositiveInteger], ["hour", ToIntegerThrowOnInfinity], ["minute", ToIntegerThrowOnInfinity], ["second", ToIntegerThrowOnInfinity], ["millisecond", ToIntegerThrowOnInfinity], ["microsecond", ToIntegerThrowOnInfinity], ["nanosecond", ToIntegerThrowOnInfinity], ["years", ToIntegerWithoutRounding], ["months", ToIntegerWithoutRounding], ["weeks", ToIntegerWithoutRounding], ["days", ToIntegerWithoutRounding], ["hours", ToIntegerWithoutRounding], ["minutes", ToIntegerWithoutRounding], ["seconds", ToIntegerWithoutRounding], ["milliseconds", ToIntegerWithoutRounding], ["microseconds", ToIntegerWithoutRounding], ["nanoseconds", ToIntegerWithoutRounding], ["era", ToString], ["eraYear", ToInteger], ["offset", ToString]]);
var be = /* @__PURE__ */ new Map([["hour", 0], ["minute", 0], ["second", 0], ["millisecond", 0], ["microsecond", 0], ["nanosecond", 0]]);
var Me = [["years", "year", "date"], ["months", "month", "date"], ["weeks", "week", "date"], ["days", "day", "date"], ["hours", "hour", "time"], ["minutes", "minute", "time"], ["seconds", "second", "time"], ["milliseconds", "millisecond", "time"], ["microseconds", "microsecond", "time"], ["nanoseconds", "nanosecond", "time"]];
var Re = new Map(Me.map((e2) => [e2[0], e2[1]]));
var Ze = new Map(Me.map(([e2, t2]) => [t2, e2]));
var Pe = Me.map(([, e2]) => e2);
var Fe = Array.from(Re.keys()).sort();
var Ye = /* @__PURE__ */ new Map();
function getIntlDateTimeFormatEnUsForTimeZone(e2) {
  let t2 = Ye.get(e2);
  return void 0 === t2 && (t2 = new J("en-us", { timeZone: ae(e2), hour12: false, era: "short", year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), Ye.set(e2, t2)), t2;
}
function IsTemporalInstant(e2) {
  return HasSlot(e2, r) && !HasSlot(e2, p, u);
}
function IsTemporalTimeZone(e2) {
  return HasSlot(e2, o);
}
function IsTemporalCalendar(e2) {
  return HasSlot(e2, C);
}
function IsTemporalDuration(e2) {
  return HasSlot(e2, f, y, w, g, I, D, G, v, O);
}
function IsTemporalDate(e2) {
  return HasSlot(e2, "slot-date-brand");
}
function IsTemporalTime(e2) {
  return HasSlot(e2, s, l, d, m, c, h) && !HasSlot(e2, n, a, i);
}
function IsTemporalDateTime(e2) {
  return HasSlot(e2, n, a, i, s, l, d, m, c, h);
}
function IsTemporalYearMonth(e2) {
  return HasSlot(e2, "slot-year-month-brand");
}
function IsTemporalMonthDay(e2) {
  return HasSlot(e2, "slot-month-day-brand");
}
function IsTemporalZonedDateTime(e2) {
  return HasSlot(e2, r, p, u);
}
function RejectObjectWithCalendarOrTimeZone(e2) {
  if (HasSlot(e2, u) || HasSlot(e2, p))
    throw new TypeError("with() does not support a calendar or timeZone property");
  if (void 0 !== e2.calendar)
    throw new TypeError("with() does not support a calendar property");
  if (void 0 !== e2.timeZone)
    throw new TypeError("with() does not support a timeZone property");
}
function ParseTemporalTimeZone(e2) {
  let { ianaName: t2, offset: r2, z: o2 } = function ParseTemporalTimeZoneString(e3) {
    try {
      let t3 = GetCanonicalTimeZoneIdentifier(e3);
      if (t3)
        return { ianaName: t3.toString() };
    } catch {
    }
    try {
      const t3 = ParseISODateTime(e3);
      if (t3.z || t3.offset || t3.ianaName)
        return t3;
    } catch {
    }
    throw new RangeError(`Invalid time zone: ${e3}`);
  }(e2);
  return t2 || (o2 ? "UTC" : r2);
}
function FormatCalendarAnnotation(e2, t2) {
  return "never" === t2 || "auto" === t2 && "iso8601" === e2 ? "" : `[u-ca=${e2}]`;
}
function ParseISODateTime(e2) {
  const t2 = A.exec(e2);
  if (!t2)
    throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  let r2 = t2[1];
  if ("\u2212" === r2[0] && (r2 = `-${r2.slice(1)}`), "-000000" === r2)
    throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  const o2 = ToInteger(r2), n2 = ToInteger(t2[2] || t2[4]), a2 = ToInteger(t2[3] || t2[5]), i2 = ToInteger(t2[6]), s2 = void 0 !== t2[6], l2 = ToInteger(t2[7] || t2[10]);
  let d2 = ToInteger(t2[8] || t2[11]);
  60 === d2 && (d2 = 59);
  const m2 = (t2[9] || t2[12]) + "000000000", c2 = ToInteger(m2.slice(0, 3)), h2 = ToInteger(m2.slice(3, 6)), u2 = ToInteger(m2.slice(6, 9));
  let T2, p2 = false;
  if (t2[13])
    T2 = void 0, p2 = true;
  else if (t2[14] && t2[15]) {
    const e3 = "-" === t2[14] || "\u2212" === t2[14] ? "-" : "+", r3 = t2[15] || "00", o3 = t2[16] || "00", n3 = t2[17] || "00";
    let a3 = t2[18] || "0";
    if (T2 = `${e3}${r3}:${o3}`, +a3) {
      for (; a3.endsWith("0"); )
        a3 = a3.slice(0, -1);
      T2 += `:${n3}.${a3}`;
    } else
      +n3 && (T2 += `:${n3}`);
    "-00:00" === T2 && (T2 = "+00:00");
  }
  let f2 = t2[19];
  if (f2)
    try {
      f2 = GetCanonicalTimeZoneIdentifier(f2).toString();
    } catch {
    }
  const y2 = t2[20];
  return RejectDateTime(o2, n2, a2, i2, l2, d2, c2, h2, u2), { year: o2, month: n2, day: a2, hasTime: s2, hour: i2, minute: l2, second: d2, millisecond: c2, microsecond: h2, nanosecond: u2, ianaName: f2, offset: T2, z: p2, calendar: y2 };
}
function ParseTemporalYearMonthString(e2) {
  const t2 = L.exec(e2);
  let r2, o2, n2, a2;
  if (t2) {
    let a3 = t2[1];
    if ("\u2212" === a3[0] && (a3 = `-${a3.slice(1)}`), "-000000" === a3)
      throw new RangeError(`invalid ISO 8601 string: ${e2}`);
    r2 = ToInteger(a3), o2 = ToInteger(t2[2]), n2 = t2[3];
  } else {
    let t3;
    if ({ year: r2, month: o2, calendar: n2, day: a2, z: t3 } = ParseISODateTime(e2), t3)
      throw new RangeError("Z designator not supported for PlainYearMonth");
  }
  return { year: r2, month: o2, calendar: n2, referenceISODay: a2 };
}
function ParseTemporalMonthDayString(e2) {
  const t2 = x.exec(e2);
  let r2, o2, n2, a2;
  if (t2)
    r2 = ToInteger(t2[1]), o2 = ToInteger(t2[2]);
  else {
    let t3;
    if ({ month: r2, day: o2, calendar: n2, year: a2, z: t3 } = ParseISODateTime(e2), t3)
      throw new RangeError("Z designator not supported for PlainMonthDay");
  }
  return { month: r2, day: o2, calendar: n2, referenceISOYear: a2 };
}
function ParseTemporalDurationString(e2) {
  const t2 = W.exec(e2);
  if (!t2)
    throw new RangeError(`invalid duration: ${e2}`);
  if (t2.slice(2).every((e3) => void 0 === e3))
    throw new RangeError(`invalid duration: ${e2}`);
  const r2 = "-" === t2[1] || "\u2212" === t2[1] ? -1 : 1, o2 = ToInteger(t2[2]) * r2, n2 = ToInteger(t2[3]) * r2, a2 = ToInteger(t2[4]) * r2, i2 = ToInteger(t2[5]) * r2, s2 = ToInteger(t2[6]) * r2;
  let l2 = t2[7], d2 = ToInteger(t2[8]) * r2, m2 = t2[9], c2 = ToInteger(t2[10]) * r2;
  const h2 = t2[11] + "000000000";
  let u2 = ToInteger(h2.slice(0, 3)) * r2, T2 = ToInteger(h2.slice(3, 6)) * r2, p2 = ToInteger(h2.slice(6, 9)) * r2;
  return l2 = l2 ? r2 * ToInteger(l2) / 10 ** l2.length : 0, m2 = m2 ? r2 * ToInteger(m2) / 10 ** m2.length : 0, { minutes: d2, seconds: c2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = function DurationHandleFractions(e3, t3, r3, o3, n3, a3, i3) {
    let s3 = e3, l3 = t3, d3 = r3, m3 = o3, c3 = n3, h3 = a3, u3 = i3;
    if (0 !== s3) {
      [l3, d3, m3, c3, h3, u3].forEach((e5) => {
        if (0 !== e5)
          throw new RangeError("only the smallest unit can be fractional");
      });
      const e4 = 60 * s3;
      l3 = te(e4), d3 = e4 % 1;
    }
    if (0 !== d3) {
      [m3, c3, h3, u3].forEach((e5) => {
        if (0 !== e5)
          throw new RangeError("only the smallest unit can be fractional");
      });
      const e4 = 60 * d3;
      m3 = te(e4);
      const t4 = e4 % 1;
      if (0 !== t4) {
        const e5 = 1e3 * t4;
        c3 = te(e5);
        const r4 = e5 % 1;
        if (0 !== r4) {
          const e6 = 1e3 * r4;
          h3 = te(e6);
          const t5 = e6 % 1;
          if (0 !== t5) {
            u3 = te(1e3 * t5);
          }
        }
      }
    }
    return { minutes: l3, seconds: m3, milliseconds: c3, microseconds: h3, nanoseconds: u3 };
  }(l2, d2, m2, c2, u2, T2, p2), RejectDuration(o2, n2, a2, i2, s2, d2, c2, u2, T2, p2), { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: d2, seconds: c2, milliseconds: u2, microseconds: T2, nanoseconds: p2 };
}
function ParseTemporalInstant(e2) {
  let { year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2, offset: m2, z: c2 } = function ParseTemporalInstantString(e3) {
    const t3 = ParseISODateTime(e3);
    if (!t3.z && !t3.offset)
      throw new RangeError("Temporal.Instant requires a time zone offset");
    return t3;
  }(e2);
  if (!c2 && !m2)
    throw new RangeError("Temporal.Instant requires a time zone offset");
  const h2 = c2 ? 0 : ParseTimeZoneOffsetString(m2);
  ({ year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2 } = BalanceISODateTime(t2, r2, o2, n2, a2, i2, s2, l2, d2 - h2));
  const u2 = GetEpochFromISOParts(t2, r2, o2, n2, a2, i2, s2, l2, d2);
  if (null === u2)
    throw new RangeError("DateTime outside of supported range");
  return u2;
}
function RegulateISODate(e2, t2, r2, o2) {
  let n2 = e2, a2 = t2, i2 = r2;
  switch (o2) {
    case "reject":
      RejectISODate(n2, a2, i2);
      break;
    case "constrain":
      ({ year: n2, month: a2, day: i2 } = ConstrainISODate(n2, a2, i2));
  }
  return { year: n2, month: a2, day: i2 };
}
function RegulateTime(e2, t2, r2, o2, n2, a2, i2) {
  let s2 = e2, l2 = t2, d2 = r2, m2 = o2, c2 = n2, h2 = a2;
  switch (i2) {
    case "reject":
      RejectTime(s2, l2, d2, m2, c2, h2);
      break;
    case "constrain":
      ({ hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 } = function ConstrainTime(e3, t3, r3, o3, n3, a3) {
        const i3 = ConstrainToRange(e3, 0, 23), s3 = ConstrainToRange(t3, 0, 59), l3 = ConstrainToRange(r3, 0, 59), d3 = ConstrainToRange(o3, 0, 999), m3 = ConstrainToRange(n3, 0, 999), c3 = ConstrainToRange(a3, 0, 999);
        return { hour: i3, minute: s3, second: l3, millisecond: d3, microsecond: m3, nanosecond: c3 };
      }(s2, l2, d2, m2, c2, h2));
  }
  return { hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 };
}
function ToTemporalDurationRecord(e2) {
  if (!IsObject(e2))
    return ParseTemporalDurationString(ToString(e2));
  if (IsTemporalDuration(e2))
    return { years: GetSlot(e2, f), months: GetSlot(e2, y), weeks: GetSlot(e2, S), days: GetSlot(e2, w), hours: GetSlot(e2, g), minutes: GetSlot(e2, I), seconds: GetSlot(e2, D), milliseconds: GetSlot(e2, G), microseconds: GetSlot(e2, v), nanoseconds: GetSlot(e2, O) };
  const t2 = { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  let r2 = function ToTemporalPartialDurationRecord(e3) {
    if (!IsObject(e3))
      throw new TypeError("invalid duration-like");
    const t3 = { years: void 0, months: void 0, weeks: void 0, days: void 0, hours: void 0, minutes: void 0, seconds: void 0, milliseconds: void 0, microseconds: void 0, nanoseconds: void 0 };
    let r3 = false;
    for (const o3 of Fe) {
      const n3 = e3[o3];
      void 0 !== n3 && (r3 = true, t3[o3] = ToIntegerWithoutRounding(n3));
    }
    if (!r3)
      throw new TypeError("invalid duration-like");
    return t3;
  }(e2);
  for (const e3 of Fe) {
    const o3 = r2[e3];
    void 0 !== o3 && (t2[e3] = o3);
  }
  let { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 } = t2;
  return RejectDuration(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 };
}
function ToTemporalOverflow(e2) {
  return void 0 === e2 ? "constrain" : GetOption(e2, "overflow", ["constrain", "reject"], "constrain");
}
function ToTemporalDisambiguation(e2) {
  return void 0 === e2 ? "compatible" : GetOption(e2, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
}
function ToTemporalRoundingMode(e2, t2) {
  return GetOption(e2, "roundingMode", ["ceil", "floor", "trunc", "halfExpand"], t2);
}
function NegateTemporalRoundingMode(e2) {
  switch (e2) {
    case "ceil":
      return "floor";
    case "floor":
      return "ceil";
    default:
      return e2;
  }
}
function ToTemporalOffset(e2, t2) {
  return void 0 === e2 ? t2 : GetOption(e2, "offset", ["prefer", "use", "ignore", "reject"], t2);
}
function ToShowCalendarOption(e2) {
  return GetOption(e2, "calendarName", ["auto", "always", "never"], "auto");
}
function ToTemporalRoundingIncrement(e2, t2, r2) {
  let o2 = 1 / 0;
  void 0 !== t2 && (o2 = t2), r2 || void 0 === t2 || (o2 = t2 > 1 ? t2 - 1 : 1);
  const n2 = function GetNumberOption(e3, t3, r3, o3, n3) {
    let a2 = e3[t3];
    if (void 0 === a2)
      return n3;
    const i2 = ToNumber(a2);
    if (re(i2) || i2 < r3 || i2 > o3)
      throw new RangeError(`${String(t3)} must be between ${r3} and ${o3}, not ${i2}`);
    return Q(i2);
  }(e2, "roundingIncrement", 1, o2, 1);
  if (void 0 !== t2 && t2 % n2 != 0)
    throw new RangeError(`Rounding increment must divide evenly into ${t2}`);
  return n2;
}
function ToTemporalDateTimeRoundingIncrement(e2, t2) {
  return ToTemporalRoundingIncrement(e2, { year: void 0, month: void 0, week: void 0, day: void 0, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[t2], false);
}
function ToSecondsStringPrecision(e2) {
  const t2 = GetTemporalUnit(e2, "smallestUnit", "time", void 0);
  if ("hour" === t2) {
    const e3 = Me.reduce((e4, [t3, r3, o3]) => ("time" === o3 && "hour" !== r3 && e4.push(r3, t3), e4), []);
    throw new RangeError(`smallestUnit must be one of ${e3.join(", ")}, not ${t2}`);
  }
  switch (t2) {
    case "minute":
      return { precision: "minute", unit: "minute", increment: 1 };
    case "second":
      return { precision: 0, unit: "second", increment: 1 };
    case "millisecond":
      return { precision: 3, unit: "millisecond", increment: 1 };
    case "microsecond":
      return { precision: 6, unit: "microsecond", increment: 1 };
    case "nanosecond":
      return { precision: 9, unit: "nanosecond", increment: 1 };
  }
  let r2 = e2.fractionalSecondDigits;
  if (void 0 === r2 && (r2 = "auto"), "number" != typeof r2) {
    const e3 = ToString(r2);
    if ("auto" === e3)
      return { precision: "auto", unit: "nanosecond", increment: 1 };
    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${e3}`);
  }
  if (re(r2) || r2 < 0 || r2 > 9)
    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${r2}`);
  const o2 = Q(r2);
  switch (o2) {
    case 0:
      return { precision: o2, unit: "second", increment: 1 };
    case 1:
    case 2:
    case 3:
      return { precision: o2, unit: "millisecond", increment: 10 ** (3 - o2) };
    case 4:
    case 5:
    case 6:
      return { precision: o2, unit: "microsecond", increment: 10 ** (6 - o2) };
    case 7:
    case 8:
    case 9:
      return { precision: o2, unit: "nanosecond", increment: 10 ** (9 - o2) };
    default:
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${r2}`);
  }
}
var je = Symbol("~required~");
function GetTemporalUnit(e2, t2, r2, o2, n2 = []) {
  const a2 = [];
  for (const [, e3, t3] of Me)
    "datetime" !== r2 && r2 !== t3 || a2.push(e3);
  a2.push(...n2);
  let i2 = o2;
  i2 === je ? i2 = void 0 : void 0 !== i2 && a2.push(i2);
  const s2 = [...a2];
  for (const e3 of a2) {
    const t3 = Ze.get(e3);
    void 0 !== t3 && s2.push(t3);
  }
  let l2 = GetOption(e2, t2, s2, i2);
  if (void 0 === l2 && o2 === je)
    throw new RangeError(`${t2} is required`);
  return Re.has(l2) ? Re.get(l2) : l2;
}
function ToRelativeTemporalObject(e2) {
  const t2 = e2.relativeTo;
  if (void 0 === t2)
    return t2;
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = "option", p2 = false;
  if (IsObject(t2)) {
    if (IsTemporalZonedDateTime(t2) || IsTemporalDate(t2))
      return t2;
    if (IsTemporalDateTime(t2))
      return TemporalDateTimeToDate(t2);
    c2 = GetTemporalCalendarWithISODefault(t2);
    const e3 = PrepareTemporalFields(t2, CalendarFields(c2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []), p3 = le(null);
    p3.overflow = "constrain", { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(c2, e3, p3), u2 = t2.offset, void 0 === u2 && (T2 = "wall"), h2 = t2.timeZone;
  } else {
    let e3, f2;
    ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, calendar: c2, ianaName: e3, offset: u2, z: f2 } = ParseISODateTime(ToString(t2))), e3 && (h2 = e3), f2 ? T2 = "exact" : u2 || (T2 = "wall"), c2 || (c2 = GetISO8601Calendar()), c2 = ToTemporalCalendar(c2), p2 = true;
  }
  if (void 0 !== h2) {
    h2 = ToTemporalTimeZone(h2);
    let e3 = 0;
    "option" === T2 && (e3 = ParseTimeZoneOffsetString(ToString(u2)));
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, T2, e3, h2, "compatible", "reject", p2), h2, c2);
  }
  return CreateTemporalDate(r2, o2, n2, c2);
}
function DefaultTemporalLargestUnit(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const [m2, c2] of [["years", e2], ["months", t2], ["weeks", r2], ["days", o2], ["hours", n2], ["minutes", a2], ["seconds", i2], ["milliseconds", s2], ["microseconds", l2], ["nanoseconds", d2]])
    if (0 !== c2)
      return Re.get(m2);
  return "nanosecond";
}
function LargerOfTwoTemporalUnits(e2, t2) {
  return Pe.indexOf(e2) > Pe.indexOf(t2) ? t2 : e2;
}
function MergeLargestUnitOption(e2, t2) {
  let r2 = e2;
  return void 0 === r2 && (r2 = le(null)), se(le(null), r2, { largestUnit: t2 });
}
function PrepareTemporalFields(e2, t2, r2, { emptySourceErrorMessage: o2 } = { emptySourceErrorMessage: "no supported properties found" }) {
  const n2 = le(null);
  let a2 = false;
  for (const o3 of t2) {
    let t3 = e2[o3];
    if (void 0 !== t3)
      a2 = true, Ee.has(o3) && (t3 = Ee.get(o3)(t3)), n2[o3] = t3;
    else if ("partial" !== r2) {
      if (z.call(r2, o3))
        throw new TypeError(`required property '${o3}' missing or undefined`);
      t3 = be.get(o3), n2[o3] = t3;
    }
  }
  if ("partial" === r2 && !a2)
    throw new TypeError(o2);
  if (void 0 === n2.era != (void 0 === n2.eraYear))
    throw new RangeError("properties 'era' and 'eraYear' must be provided together");
  return n2;
}
function ToTemporalTimeRecord(e2, t2 = "complete") {
  const r2 = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"], o2 = PrepareTemporalFields(e2, r2, "partial", { emptySourceErrorMessage: "invalid time-like" }), n2 = {};
  for (const e3 of r2) {
    const r3 = de(o2, e3);
    void 0 !== r3 ? n2[e3] = r3.value : "complete" === t2 && (n2[e3] = 0);
  }
  return n2;
}
function ToTemporalDate(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalDate(r2))
      return r2;
    if (IsTemporalZonedDateTime(r2) && (ToTemporalOverflow(t2), r2 = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(r2, p), GetSlot(r2, T), GetSlot(r2, u))), IsTemporalDateTime(r2))
      return ToTemporalOverflow(t2), CreateTemporalDate(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(r2, u));
    const e3 = GetTemporalCalendarWithISODefault(r2);
    return CalendarDateFromFields(e3, PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  const { year: o2, month: s2, day: l2, calendar: d2, z: m2 } = function ParseTemporalDateString(e3) {
    return ParseISODateTime(e3);
  }(ToString(r2));
  if (m2)
    throw new RangeError("Z designator not supported for PlainDate");
  return new (GetIntrinsic("%Temporal.PlainDate%"))(o2, s2, l2, d2);
}
function InterpretTemporalDateTimeFields(e2, t2, r2) {
  let { hour: o2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = ToTemporalTimeRecord(t2);
  const h2 = ToTemporalOverflow(r2), u2 = CalendarDateFromFields(e2, t2, r2), T2 = GetSlot(u2, n), p2 = GetSlot(u2, a), f2 = GetSlot(u2, i);
  return { hour: o2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = RegulateTime(o2, s2, l2, d2, m2, c2, h2), { year: T2, month: p2, day: f2, hour: o2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 };
}
function ToTemporalDateTime(e2, t2) {
  let r2, o2, s2, l2, d2, m2, c2, h2, f2, y2;
  if (IsObject(e2)) {
    if (IsTemporalDateTime(e2))
      return e2;
    if (IsTemporalZonedDateTime(e2))
      return ToTemporalOverflow(t2), BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(e2, p), GetSlot(e2, T), GetSlot(e2, u));
    if (IsTemporalDate(e2))
      return ToTemporalOverflow(t2), CreateTemporalDateTime(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), 0, 0, 0, 0, 0, 0, GetSlot(e2, u));
    y2 = GetTemporalCalendarWithISODefault(e2);
    const S2 = PrepareTemporalFields(e2, CalendarFields(y2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []);
    ({ year: r2, month: o2, day: s2, hour: l2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: f2 } = InterpretTemporalDateTimeFields(y2, S2, t2));
  } else {
    let n2;
    if (ToTemporalOverflow(t2), { year: r2, month: o2, day: s2, hour: l2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: f2, calendar: y2, z: n2 } = function ParseTemporalDateTimeString(e3) {
      return ParseISODateTime(e3);
    }(ToString(e2)), n2)
      throw new RangeError("Z designator not supported for PlainDateTime");
    RejectDateTime(r2, o2, s2, l2, d2, m2, c2, h2, f2), void 0 === y2 && (y2 = GetISO8601Calendar()), y2 = ToTemporalCalendar(y2);
  }
  return CreateTemporalDateTime(r2, o2, s2, l2, d2, m2, c2, h2, f2, y2);
}
function ToTemporalDuration(e2) {
  if (IsTemporalDuration(e2))
    return e2;
  let { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = ToTemporalDurationRecord(e2);
  return new (GetIntrinsic("%Temporal.Duration%"))(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
}
function ToTemporalInstant(e2) {
  if (IsTemporalInstant(e2))
    return e2;
  if (IsTemporalZonedDateTime(e2)) {
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, r));
  }
  const t2 = ParseTemporalInstant(ToString(e2));
  return new (GetIntrinsic("%Temporal.Instant%"))(t2);
}
function ToTemporalMonthDay(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalMonthDay(r2))
      return r2;
    let e3, o3;
    if (HasSlot(r2, u))
      e3 = GetSlot(r2, u), o3 = false;
    else {
      let t3 = r2.calendar;
      o3 = void 0 === t3, void 0 === t3 && (t3 = GetISO8601Calendar()), e3 = ToTemporalCalendar(t3);
    }
    r2 = r2;
    const n3 = PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []);
    return o3 && void 0 !== n3.month && void 0 === n3.monthCode && void 0 === n3.year && (n3.year = 1972), CalendarMonthDayFromFields(e3, n3, t2);
  }
  ToTemporalOverflow(t2);
  let { month: o2, day: n2, referenceISOYear: a2, calendar: i2 } = ParseTemporalMonthDayString(ToString(r2)), s2 = i2;
  if (void 0 === s2 && (s2 = GetISO8601Calendar()), s2 = ToTemporalCalendar(s2), void 0 === a2)
    return RejectISODate(1972, o2, n2), CreateTemporalMonthDay(o2, n2, s2);
  return CalendarMonthDayFromFields(s2, CreateTemporalMonthDay(o2, n2, s2, a2));
}
function ToTemporalTime(e2, t2 = "constrain") {
  let r2, o2, n2, a2, i2, f2, y2, S2 = e2;
  if (IsObject(S2)) {
    if (IsTemporalTime(S2))
      return S2;
    if (IsTemporalZonedDateTime(S2) && (S2 = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(S2, p), GetSlot(S2, T), GetSlot(S2, u))), IsTemporalDateTime(S2)) {
      return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(S2, s), GetSlot(S2, l), GetSlot(S2, d), GetSlot(S2, m), GetSlot(S2, c), GetSlot(S2, h));
    }
    if (y2 = GetTemporalCalendarWithISODefault(S2), "iso8601" !== ToString(y2))
      throw new RangeError("PlainTime can only have iso8601 calendar");
    ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: f2 } = ToTemporalTimeRecord(S2)), { hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: f2 } = RegulateTime(r2, o2, n2, a2, i2, f2, t2);
  } else if ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: f2, calendar: y2 } = function ParseTemporalTimeString(e3) {
    const t3 = U.exec(e3);
    let r3, o3, n3, a3, i3, s2, l2;
    if (t3) {
      r3 = ToInteger(t3[1]), o3 = ToInteger(t3[2] || t3[5]), n3 = ToInteger(t3[3] || t3[6]), 60 === n3 && (n3 = 59);
      const e4 = (t3[4] || t3[7]) + "000000000";
      a3 = ToInteger(e4.slice(0, 3)), i3 = ToInteger(e4.slice(3, 6)), s2 = ToInteger(e4.slice(6, 9)), l2 = t3[15];
    } else {
      let t4, d2;
      if ({ hasTime: d2, hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s2, calendar: l2, z: t4 } = ParseISODateTime(e3), !d2)
        throw new RangeError(`time is missing in string: ${e3}`);
      if (t4)
        throw new RangeError("Z designator not supported for PlainTime");
    }
    if (/[tT ][0-9][0-9]/.test(e3))
      return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s2, calendar: l2 };
    try {
      const { month: t4, day: r4 } = ParseTemporalMonthDayString(e3);
      RejectISODate(1972, t4, r4);
    } catch {
      try {
        const { year: t4, month: r4 } = ParseTemporalYearMonthString(e3);
        RejectISODate(t4, r4, 1);
      } catch {
        return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s2, calendar: l2 };
      }
    }
    throw new RangeError(`invalid ISO 8601 time-only string ${e3}; may need a T prefix`);
  }(ToString(S2)), RejectTime(r2, o2, n2, a2, i2, f2), void 0 !== y2 && "iso8601" !== y2)
    throw new RangeError("PlainTime can only have iso8601 calendar");
  return new (GetIntrinsic("%Temporal.PlainTime%"))(r2, o2, n2, a2, i2, f2);
}
function ToTemporalYearMonth(e2, t2) {
  if (IsObject(e2)) {
    if (IsTemporalYearMonth(e2))
      return e2;
    const r3 = GetTemporalCalendarWithISODefault(e2);
    return CalendarYearMonthFromFields(r3, PrepareTemporalFields(e2, CalendarFields(r3, ["month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: r2, month: o2, referenceISODay: n2, calendar: a2 } = ParseTemporalYearMonthString(ToString(e2)), i2 = a2;
  if (void 0 === i2 && (i2 = GetISO8601Calendar()), i2 = ToTemporalCalendar(i2), void 0 === n2)
    return RejectISODate(r2, o2, 1), CreateTemporalYearMonth(r2, o2, i2);
  return CalendarYearMonthFromFields(i2, CreateTemporalYearMonth(r2, o2, i2, n2));
}
function InterpretISODateTimeOffset(t2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2) {
  const S2 = new (GetIntrinsic("%Temporal.PlainDateTime%"))(t2, n2, a2, i2, s2, l2, d2, m2, c2);
  if ("wall" === h2 || "ignore" === f2) {
    return GetSlot(BuiltinTimeZoneGetInstantFor(T2, S2, p2), r);
  }
  if ("exact" === h2 || "use" === f2) {
    const r2 = GetEpochFromISOParts(t2, n2, a2, i2, s2, l2, d2, m2, c2);
    if (null === r2)
      throw new RangeError("ZonedDateTime outside of supported range");
    return import_jsbi.default.subtract(r2, import_jsbi.default.BigInt(u2));
  }
  const w2 = GetPossibleInstantsFor(T2, S2);
  for (const t3 of w2) {
    const o2 = GetOffsetNanosecondsFor(T2, t3), n3 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(o2), 6e10, "halfExpand"));
    if (o2 === u2 || y2 && n3 === u2)
      return GetSlot(t3, r);
  }
  if ("reject" === f2) {
    const e2 = FormatTimeZoneOffsetString(u2), t3 = IsTemporalTimeZone(T2) ? GetSlot(T2, o) : "time zone";
    throw new RangeError(`Offset ${e2} is invalid for ${S2.toString()} in ${t3}`);
  }
  return GetSlot(DisambiguatePossibleInstants(w2, T2, S2, p2), r);
}
function ToTemporalZonedDateTime(e2, t2) {
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = false, p2 = "option";
  if (IsObject(e2)) {
    if (IsTemporalZonedDateTime(e2))
      return e2;
    u2 = GetTemporalCalendarWithISODefault(e2);
    const T3 = PrepareTemporalFields(e2, ArrayPush(CalendarFields(u2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), "timeZone", "offset"), ["timeZone"]);
    ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(u2, T3, t2)), c2 = ToTemporalTimeZone(T3.timeZone), h2 = T3.offset, void 0 === h2 ? p2 = "wall" : h2 = ToString(h2);
  } else {
    let f3, y2;
    if (ToTemporalOverflow(t2), { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, ianaName: f3, offset: h2, z: y2, calendar: u2 } = function ParseTemporalZonedDateTimeString(e3) {
      const t3 = ParseISODateTime(e3);
      if (!t3.ianaName)
        throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
      return t3;
    }(ToString(e2)), !f3)
      throw new RangeError("time zone ID required in brackets");
    y2 ? p2 = "exact" : h2 || (p2 = "wall");
    c2 = new (GetIntrinsic("%Temporal.TimeZone%"))(f3), u2 || (u2 = GetISO8601Calendar()), u2 = ToTemporalCalendar(u2), T2 = true;
  }
  let f2 = 0;
  "option" === p2 && (f2 = ParseTimeZoneOffsetString(h2));
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, p2, f2, c2, ToTemporalDisambiguation(t2), ToTemporalOffset(t2, "reject"), T2), c2, u2);
}
function CreateTemporalDateSlots(e2, t2, r2, o2, s2) {
  RejectISODate(t2, r2, o2), RejectDateRange(t2, r2, o2), CreateSlots(e2), SetSlot(e2, n, t2), SetSlot(e2, a, r2), SetSlot(e2, i, o2), SetSlot(e2, u, s2), SetSlot(e2, "slot-date-brand", true);
}
function CreateTemporalDate(e2, t2, r2, o2 = GetISO8601Calendar()) {
  const n2 = GetIntrinsic("%Temporal.PlainDate%"), a2 = le(n2.prototype);
  return CreateTemporalDateSlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalDateTimeSlots(e2, t2, r2, o2, T2, p2, f2, y2, S2, w2, g2) {
  RejectDateTime(t2, r2, o2, T2, p2, f2, y2, S2, w2), RejectDateTimeRange(t2, r2, o2, T2, p2, f2, y2, S2, w2), CreateSlots(e2), SetSlot(e2, n, t2), SetSlot(e2, a, r2), SetSlot(e2, i, o2), SetSlot(e2, s, T2), SetSlot(e2, l, p2), SetSlot(e2, d, f2), SetSlot(e2, m, y2), SetSlot(e2, c, S2), SetSlot(e2, h, w2), SetSlot(e2, u, g2);
}
function CreateTemporalDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2 = GetISO8601Calendar()) {
  const m2 = GetIntrinsic("%Temporal.PlainDateTime%"), c2 = le(m2.prototype);
  return CreateTemporalDateTimeSlots(c2, e2, t2, r2, o2, n2, a2, i2, s2, l2, d2), c2;
}
function CreateTemporalMonthDaySlots(e2, t2, r2, o2, s2) {
  RejectISODate(s2, t2, r2), RejectDateRange(s2, t2, r2), CreateSlots(e2), SetSlot(e2, a, t2), SetSlot(e2, i, r2), SetSlot(e2, n, s2), SetSlot(e2, u, o2), SetSlot(e2, "slot-month-day-brand", true);
}
function CreateTemporalMonthDay(e2, t2, r2 = GetISO8601Calendar(), o2 = 1972) {
  const n2 = GetIntrinsic("%Temporal.PlainMonthDay%"), a2 = le(n2.prototype);
  return CreateTemporalMonthDaySlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalYearMonthSlots(e2, t2, r2, o2, s2) {
  RejectISODate(t2, r2, s2), function RejectYearMonthRange(e3, t3) {
    RejectToRange(e3, -271821, 275760), -271821 === e3 ? RejectToRange(t3, 4, 12) : 275760 === e3 && RejectToRange(t3, 1, 9);
  }(t2, r2), CreateSlots(e2), SetSlot(e2, n, t2), SetSlot(e2, a, r2), SetSlot(e2, i, s2), SetSlot(e2, u, o2), SetSlot(e2, "slot-year-month-brand", true);
}
function CreateTemporalYearMonth(e2, t2, r2 = GetISO8601Calendar(), o2 = 1) {
  const n2 = GetIntrinsic("%Temporal.PlainYearMonth%"), a2 = le(n2.prototype);
  return CreateTemporalYearMonthSlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalZonedDateTimeSlots(e2, t2, o2, n2) {
  ValidateEpochNanoseconds(t2), CreateSlots(e2), SetSlot(e2, r, t2), SetSlot(e2, p, o2), SetSlot(e2, u, n2);
  const a2 = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, r));
  SetSlot(e2, T, a2);
}
function CreateTemporalZonedDateTime(e2, t2, r2 = GetISO8601Calendar()) {
  const o2 = GetIntrinsic("%Temporal.ZonedDateTime%"), n2 = le(o2.prototype);
  return CreateTemporalZonedDateTimeSlots(n2, e2, t2, r2), n2;
}
function GetISO8601Calendar() {
  return new (GetIntrinsic("%Temporal.Calendar%"))("iso8601");
}
function CalendarFields(e2, t2) {
  let r2 = t2;
  e2.fields && (r2 = e2.fields(r2));
  const o2 = [];
  for (const e3 of r2) {
    if ("string" != typeof e3)
      throw new TypeError("bad return from calendar.fields()");
    _.call(o2, e3);
  }
  return o2;
}
function CalendarMergeFields(e2, t2, r2) {
  const o2 = e2.mergeFields;
  if (!o2)
    return { ...t2, ...r2 };
  const n2 = Reflect.apply(o2, e2, [t2, r2]);
  if (!IsObject(n2))
    throw new TypeError("bad return from calendar.mergeFields()");
  return n2;
}
function CalendarDateAdd(e2, t2, r2, o2, n2) {
  let a2 = n2;
  void 0 === a2 && (a2 = e2.dateAdd);
  const i2 = ce(a2, e2, [t2, r2, o2]);
  if (!IsTemporalDate(i2))
    throw new TypeError("invalid result");
  return i2;
}
function CalendarDateUntil(e2, t2, r2, o2, n2) {
  let a2 = n2;
  void 0 === a2 && (a2 = e2.dateUntil);
  const i2 = ce(a2, e2, [t2, r2, o2]);
  if (!IsTemporalDuration(i2))
    throw new TypeError("invalid result");
  return i2;
}
function CalendarYear(e2, t2) {
  const r2 = e2.year(t2);
  if (void 0 === r2)
    throw new RangeError("calendar year result must be an integer");
  return ToIntegerThrowOnInfinity(r2);
}
function CalendarMonth(e2, t2) {
  const r2 = e2.month(t2);
  if (void 0 === r2)
    throw new RangeError("calendar month result must be a positive integer");
  return ToPositiveInteger(r2);
}
function CalendarMonthCode(e2, t2) {
  const r2 = e2.monthCode(t2);
  if (void 0 === r2)
    throw new RangeError("calendar monthCode result must be a string");
  return ToString(r2);
}
function CalendarDay(e2, t2) {
  const r2 = e2.day(t2);
  if (void 0 === r2)
    throw new RangeError("calendar day result must be a positive integer");
  return ToPositiveInteger(r2);
}
function CalendarEra(e2, t2) {
  let r2 = e2.era(t2);
  return void 0 !== r2 && (r2 = ToString(r2)), r2;
}
function CalendarEraYear(e2, t2) {
  let r2 = e2.eraYear(t2);
  return void 0 !== r2 && (r2 = ToIntegerThrowOnInfinity(r2)), r2;
}
function CalendarDayOfWeek(e2, t2) {
  return e2.dayOfWeek(t2);
}
function CalendarDayOfYear(e2, t2) {
  return e2.dayOfYear(t2);
}
function CalendarWeekOfYear(e2, t2) {
  return e2.weekOfYear(t2);
}
function CalendarDaysInWeek(e2, t2) {
  return e2.daysInWeek(t2);
}
function CalendarDaysInMonth(e2, t2) {
  return e2.daysInMonth(t2);
}
function CalendarDaysInYear(e2, t2) {
  return e2.daysInYear(t2);
}
function CalendarMonthsInYear(e2, t2) {
  return e2.monthsInYear(t2);
}
function CalendarInLeapYear(e2, t2) {
  return e2.inLeapYear(t2);
}
function ToTemporalCalendar(e2) {
  let t2 = e2;
  if (IsObject(t2)) {
    if (HasSlot(t2, u))
      return GetSlot(t2, u);
    if (!("calendar" in t2))
      return t2;
    if (t2 = t2.calendar, IsObject(t2) && !("calendar" in t2))
      return t2;
  }
  const r2 = ToString(t2), o2 = GetIntrinsic("%Temporal.Calendar%");
  if (IsBuiltinCalendar(r2))
    return new o2(r2);
  let n2;
  try {
    ({ calendar: n2 } = ParseISODateTime(r2));
  } catch {
    throw new RangeError(`Invalid calendar: ${r2}`);
  }
  return n2 || (n2 = "iso8601"), new o2(n2);
}
function GetTemporalCalendarWithISODefault(e2) {
  if (HasSlot(e2, u))
    return GetSlot(e2, u);
  const { calendar: t2 } = e2;
  return void 0 === t2 ? GetISO8601Calendar() : ToTemporalCalendar(t2);
}
function CalendarEquals(e2, t2) {
  if (e2 === t2)
    return true;
  return ToString(e2) === ToString(t2);
}
function ConsolidateCalendars(e2, t2) {
  if (e2 === t2)
    return t2;
  const r2 = ToString(e2), o2 = ToString(t2);
  if (r2 === o2 || "iso8601" === r2)
    return t2;
  if ("iso8601" === o2)
    return e2;
  throw new RangeError("irreconcilable calendars");
}
function CalendarDateFromFields(e2, t2, r2) {
  const o2 = e2.dateFromFields(t2, r2);
  if (!IsTemporalDate(o2))
    throw new TypeError("invalid result");
  return o2;
}
function CalendarYearMonthFromFields(e2, t2, r2) {
  const o2 = e2.yearMonthFromFields(t2, r2);
  if (!IsTemporalYearMonth(o2))
    throw new TypeError("invalid result");
  return o2;
}
function CalendarMonthDayFromFields(e2, t2, r2) {
  const o2 = e2.monthDayFromFields(t2, r2);
  if (!IsTemporalMonthDay(o2))
    throw new TypeError("invalid result");
  return o2;
}
function ToTemporalTimeZone(e2) {
  let t2 = e2;
  if (IsObject(t2)) {
    if (IsTemporalZonedDateTime(t2))
      return GetSlot(t2, p);
    if (!("timeZone" in t2))
      return t2;
    if (t2 = t2.timeZone, IsObject(t2) && !("timeZone" in t2))
      return t2;
  }
  const r2 = ParseTemporalTimeZone(ToString(t2));
  return new (GetIntrinsic("%Temporal.TimeZone%"))(r2);
}
function TimeZoneEquals(e2, t2) {
  if (e2 === t2)
    return true;
  return ToString(e2) === ToString(t2);
}
function TemporalDateTimeToDate(e2) {
  return CreateTemporalDate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, u));
}
function TemporalDateTimeToTime(e2) {
  return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h));
}
function GetOffsetNanosecondsFor(e2, t2) {
  let r2 = e2.getOffsetNanosecondsFor;
  if ("function" != typeof r2)
    throw new TypeError("getOffsetNanosecondsFor not callable");
  const o2 = Reflect.apply(r2, e2, [t2]);
  if ("number" != typeof o2)
    throw new TypeError("bad return from getOffsetNanosecondsFor");
  if (!IsInteger(o2) || K(o2) > 864e11)
    throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
  return o2;
}
function BuiltinTimeZoneGetOffsetStringFor(e2, t2) {
  return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e2, t2));
}
function BuiltinTimeZoneGetPlainDateTimeFor(e2, t2, o2) {
  const n2 = GetSlot(t2, r), a2 = GetOffsetNanosecondsFor(e2, t2);
  let { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = GetISOPartsFromEpoch(n2);
  return { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = BalanceISODateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2 + a2), CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, o2);
}
function BuiltinTimeZoneGetInstantFor(e2, t2, r2) {
  return DisambiguatePossibleInstants(GetPossibleInstantsFor(e2, t2), e2, t2, r2);
}
function DisambiguatePossibleInstants(t2, r2, o2, T2) {
  const p2 = GetIntrinsic("%Temporal.Instant%"), f2 = t2.length;
  if (1 === f2)
    return t2[0];
  if (f2)
    switch (T2) {
      case "compatible":
      case "earlier":
        return t2[0];
      case "later":
        return t2[f2 - 1];
      case "reject":
        throw new RangeError("multiple instants found");
    }
  const y2 = GetSlot(o2, n), S2 = GetSlot(o2, a), w2 = GetSlot(o2, i), g2 = GetSlot(o2, s), I2 = GetSlot(o2, l), D2 = GetSlot(o2, d), G2 = GetSlot(o2, m), v2 = GetSlot(o2, c), O2 = GetSlot(o2, h), C2 = GetEpochFromISOParts(y2, S2, w2, g2, I2, D2, G2, v2, O2);
  if (null === C2)
    throw new RangeError("DateTime outside of supported range");
  const E2 = new p2(import_jsbi.default.subtract(C2, we)), b2 = new p2(import_jsbi.default.add(C2, we)), M2 = GetOffsetNanosecondsFor(r2, E2), R2 = GetOffsetNanosecondsFor(r2, b2) - M2;
  switch (T2) {
    case "earlier": {
      const e2 = GetSlot(o2, u), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n2 = AddDateTime(y2, S2, w2, g2, I2, D2, G2, v2, O2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -R2, void 0);
      return GetPossibleInstantsFor(r2, new t3(n2.year, n2.month, n2.day, n2.hour, n2.minute, n2.second, n2.millisecond, n2.microsecond, n2.nanosecond, e2))[0];
    }
    case "compatible":
    case "later": {
      const e2 = GetSlot(o2, u), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n2 = AddDateTime(y2, S2, w2, g2, I2, D2, G2, v2, O2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, R2, void 0), a2 = GetPossibleInstantsFor(r2, new t3(n2.year, n2.month, n2.day, n2.hour, n2.minute, n2.second, n2.millisecond, n2.microsecond, n2.nanosecond, e2));
      return a2[a2.length - 1];
    }
    case "reject":
      throw new RangeError("no such instant found");
  }
}
function GetPossibleInstantsFor(e2, t2) {
  const r2 = e2.getPossibleInstantsFor(t2), o2 = [];
  for (const e3 of r2) {
    if (!IsTemporalInstant(e3))
      throw new TypeError("bad return from getPossibleInstantsFor");
    _.call(o2, e3);
  }
  return o2;
}
function ISOYearString(e2) {
  let t2;
  if (e2 < 0 || e2 > 9999) {
    t2 = (e2 < 0 ? "-" : "+") + `000000${K(e2)}`.slice(-6);
  } else
    t2 = `0000${e2}`.slice(-4);
  return t2;
}
function ISODateTimePartString(e2) {
  return `00${e2}`.slice(-2);
}
function FormatSecondsStringPart(e2, t2, r2, o2, n2) {
  if ("minute" === n2)
    return "";
  const a2 = `:${ISODateTimePartString(e2)}`;
  let i2, s2 = 1e6 * t2 + 1e3 * r2 + o2;
  if ("auto" === n2) {
    if (0 === s2)
      return a2;
    for (i2 = `${s2}`.padStart(9, "0"); "0" === i2[i2.length - 1]; )
      i2 = i2.slice(0, -1);
  } else {
    if (0 === n2)
      return a2;
    i2 = `${s2}`.padStart(9, "0").slice(0, n2);
  }
  return `${a2}.${i2}`;
}
function TemporalInstantToString(e2, t2, r2) {
  let o2 = t2;
  if (void 0 === o2) {
    o2 = new (GetIntrinsic("%Temporal.TimeZone%"))("UTC");
  }
  const u2 = BuiltinTimeZoneGetPlainDateTimeFor(o2, e2, GetISO8601Calendar()), T2 = ISOYearString(GetSlot(u2, n)), p2 = ISODateTimePartString(GetSlot(u2, a)), f2 = ISODateTimePartString(GetSlot(u2, i)), y2 = ISODateTimePartString(GetSlot(u2, s)), S2 = ISODateTimePartString(GetSlot(u2, l)), w2 = FormatSecondsStringPart(GetSlot(u2, d), GetSlot(u2, m), GetSlot(u2, c), GetSlot(u2, h), r2);
  let g2 = "Z";
  if (void 0 !== t2) {
    g2 = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o2, e2));
  }
  return `${T2}-${p2}-${f2}T${y2}:${S2}${w2}${g2}`;
}
function TemporalDurationToString(t2, r2 = "auto", o2) {
  function formatNumber(t3) {
    return t3 <= ie ? t3.toString(10) : import_jsbi.default.BigInt(t3).toString(10);
  }
  const n2 = GetSlot(t2, f), a2 = GetSlot(t2, y), i2 = GetSlot(t2, S), s2 = GetSlot(t2, w), l2 = GetSlot(t2, g), d2 = GetSlot(t2, I);
  let m2 = GetSlot(t2, D), c2 = GetSlot(t2, G), h2 = GetSlot(t2, v), u2 = GetSlot(t2, O);
  const T2 = DurationSign(n2, a2, i2, s2, l2, d2, m2, c2, h2, u2);
  if (o2) {
    const { unit: e2, increment: t3, roundingMode: r3 } = o2;
    ({ seconds: m2, milliseconds: c2, microseconds: h2, nanoseconds: u2 } = RoundDuration(0, 0, 0, 0, 0, 0, m2, c2, h2, u2, t3, e2, r3));
  }
  const p2 = [];
  n2 && p2.push(`${formatNumber(K(n2))}Y`), a2 && p2.push(`${formatNumber(K(a2))}M`), i2 && p2.push(`${formatNumber(K(i2))}W`), s2 && p2.push(`${formatNumber(K(s2))}D`);
  const C2 = [];
  l2 && C2.push(`${formatNumber(K(l2))}H`), d2 && C2.push(`${formatNumber(K(d2))}M`);
  const E2 = [];
  let b2, M2, R2, Z2, P2 = TotalDurationNanoseconds(0, 0, 0, m2, c2, h2, u2, 0);
  ({ quotient: P2, remainder: b2 } = divmod(P2, pe)), { quotient: P2, remainder: M2 } = divmod(P2, pe), { quotient: Z2, remainder: R2 } = divmod(P2, pe);
  const F2 = 1e6 * K(import_jsbi.default.toNumber(R2)) + 1e3 * K(import_jsbi.default.toNumber(M2)) + K(import_jsbi.default.toNumber(b2));
  let Y2;
  if ("auto" === r2) {
    if (0 !== F2)
      for (Y2 = `${F2}`.padStart(9, "0"); "0" === Y2[Y2.length - 1]; )
        Y2 = Y2.slice(0, -1);
  } else
    0 !== r2 && (Y2 = `${F2}`.padStart(9, "0").slice(0, r2));
  return Y2 && E2.unshift(".", Y2), import_jsbi.default.equal(Z2, he) && !E2.length && "auto" === r2 || E2.unshift(abs(Z2).toString()), E2.length && C2.push(`${E2.join("")}S`), C2.length && C2.unshift("T"), p2.length || C2.length ? `${T2 < 0 ? "-" : ""}P${p2.join("")}${C2.join("")}` : "PT0S";
}
function TemporalDateToString(e2, t2 = "auto") {
  return `${ISOYearString(GetSlot(e2, n))}-${ISODateTimePartString(GetSlot(e2, a))}-${ISODateTimePartString(GetSlot(e2, i))}${FormatCalendarAnnotation(ToString(GetSlot(e2, u)), t2)}`;
}
function TemporalDateTimeToString(e2, t2, r2 = "auto", o2) {
  let T2 = GetSlot(e2, n), p2 = GetSlot(e2, a), f2 = GetSlot(e2, i), y2 = GetSlot(e2, s), S2 = GetSlot(e2, l), w2 = GetSlot(e2, d), g2 = GetSlot(e2, m), I2 = GetSlot(e2, c), D2 = GetSlot(e2, h);
  if (o2) {
    const { unit: e3, increment: t3, roundingMode: r3 } = o2;
    ({ year: T2, month: p2, day: f2, hour: y2, minute: S2, second: w2, millisecond: g2, microsecond: I2, nanosecond: D2 } = RoundISODateTime(T2, p2, f2, y2, S2, w2, g2, I2, D2, t3, e3, r3));
  }
  return `${ISOYearString(T2)}-${ISODateTimePartString(p2)}-${ISODateTimePartString(f2)}T${ISODateTimePartString(y2)}:${ISODateTimePartString(S2)}${FormatSecondsStringPart(w2, g2, I2, D2, t2)}${FormatCalendarAnnotation(ToString(GetSlot(e2, u)), r2)}`;
}
function TemporalMonthDayToString(e2, t2 = "auto") {
  let r2 = `${ISODateTimePartString(GetSlot(e2, a))}-${ISODateTimePartString(GetSlot(e2, i))}`;
  const o2 = ToString(GetSlot(e2, u));
  if ("always" === t2 || "iso8601" !== o2) {
    r2 = `${ISOYearString(GetSlot(e2, n))}-${r2}`;
  }
  const s2 = FormatCalendarAnnotation(o2, t2);
  return s2 && (r2 += s2), r2;
}
function TemporalYearMonthToString(e2, t2 = "auto") {
  let r2 = `${ISOYearString(GetSlot(e2, n))}-${ISODateTimePartString(GetSlot(e2, a))}`;
  const o2 = ToString(GetSlot(e2, u));
  if ("always" === t2 || "iso8601" !== o2) {
    r2 += `-${ISODateTimePartString(GetSlot(e2, i))}`;
  }
  const s2 = FormatCalendarAnnotation(o2, t2);
  return s2 && (r2 += s2), r2;
}
function TemporalZonedDateTimeToString(e2, t2, o2 = "auto", f2 = "auto", y2 = "auto", S2) {
  let w2 = GetSlot(e2, T);
  if (S2) {
    const { unit: t3, increment: o3, roundingMode: n2 } = S2, a2 = RoundInstant(GetSlot(e2, r), o3, t3, n2);
    w2 = new (GetIntrinsic("%Temporal.Instant%"))(a2);
  }
  const g2 = GetSlot(e2, p), I2 = BuiltinTimeZoneGetPlainDateTimeFor(g2, w2, GetISO8601Calendar());
  let D2 = `${ISOYearString(GetSlot(I2, n))}-${ISODateTimePartString(GetSlot(I2, a))}-${ISODateTimePartString(GetSlot(I2, i))}T${ISODateTimePartString(GetSlot(I2, s))}:${ISODateTimePartString(GetSlot(I2, l))}${FormatSecondsStringPart(GetSlot(I2, d), GetSlot(I2, m), GetSlot(I2, c), GetSlot(I2, h), t2)}`;
  if ("never" !== y2) {
    D2 += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(g2, w2));
  }
  "never" !== f2 && (D2 += `[${g2}]`);
  return D2 += FormatCalendarAnnotation(ToString(GetSlot(e2, u)), o2), D2;
}
function TestTimeZoneOffsetString(e2) {
  return Be.test(ae(e2));
}
function ParseTimeZoneOffsetString(e2) {
  const t2 = Be.exec(ae(e2));
  if (!t2)
    throw new RangeError(`invalid time zone offset: ${e2}`);
  return ("-" === t2[1] || "\u2212" === t2[1] ? -1 : 1) * (1e9 * (60 * (60 * +t2[2] + +(t2[3] || 0)) + +(t2[4] || 0)) + +((t2[5] || 0) + "000000000").slice(0, 9));
}
function GetCanonicalTimeZoneIdentifier(e2) {
  if (TestTimeZoneOffsetString(e2)) {
    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e2));
  }
  return getIntlDateTimeFormatEnUsForTimeZone(ae(e2)).resolvedOptions().timeZone;
}
function GetIANATimeZoneOffsetNanoseconds(t2, r2) {
  const { year: o2, month: n2, day: a2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = GetIANATimeZoneDateTimeParts(t2, r2), h2 = GetEpochFromISOParts(o2, n2, a2, i2, s2, l2, d2, m2, c2);
  if (null === h2)
    throw new RangeError("Date outside of supported range");
  return import_jsbi.default.toNumber(import_jsbi.default.subtract(h2, t2));
}
function FormatTimeZoneOffsetString(e2) {
  const t2 = e2 < 0 ? "-" : "+", r2 = K(e2), o2 = r2 % 1e9, n2 = Q(r2 / 1e9) % 60, a2 = Q(r2 / 6e10) % 60, i2 = ISODateTimePartString(Q(r2 / 36e11)), s2 = ISODateTimePartString(a2), l2 = ISODateTimePartString(n2);
  let d2 = "";
  if (o2) {
    let e3 = `${o2}`.padStart(9, "0");
    for (; "0" === e3[e3.length - 1]; )
      e3 = e3.slice(0, -1);
    d2 = `:${l2}.${e3}`;
  } else
    n2 && (d2 = `:${l2}`);
  return `${t2}${i2}:${s2}${d2}`;
}
function FormatISOTimeZoneOffsetString(t2) {
  let r2 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(t2), 6e10, "halfExpand"));
  const o2 = r2 < 0 ? "-" : "+";
  r2 = K(r2);
  const n2 = r2 / 6e10 % 60;
  return `${o2}${ISODateTimePartString(Q(r2 / 36e11))}:${ISODateTimePartString(n2)}`;
}
function GetEpochFromISOParts(t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = new Date();
  m2.setUTCHours(n2, a2, i2, s2), m2.setUTCFullYear(t2, r2 - 1, o2);
  const c2 = m2.getTime();
  if (re(c2))
    return null;
  let h2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(c2), fe);
  return h2 = import_jsbi.default.add(h2, import_jsbi.default.multiply(import_jsbi.default.BigInt(l2), pe)), h2 = import_jsbi.default.add(h2, import_jsbi.default.BigInt(d2)), import_jsbi.default.lessThan(h2, ge) || import_jsbi.default.greaterThan(h2, Ie) ? null : h2;
}
function GetISOPartsFromEpoch(t2) {
  const { quotient: r2, remainder: o2 } = divmod(t2, fe);
  let n2 = import_jsbi.default.toNumber(r2), a2 = import_jsbi.default.toNumber(o2);
  a2 < 0 && (a2 += 1e6, n2 -= 1);
  const i2 = Q(a2 / 1e3) % 1e3, s2 = a2 % 1e3, l2 = new Date(n2);
  return { epochMilliseconds: n2, year: l2.getUTCFullYear(), month: l2.getUTCMonth() + 1, day: l2.getUTCDate(), hour: l2.getUTCHours(), minute: l2.getUTCMinutes(), second: l2.getUTCSeconds(), millisecond: l2.getUTCMilliseconds(), microsecond: i2, nanosecond: s2 };
}
function GetIANATimeZoneDateTimeParts(e2, t2) {
  const { epochMilliseconds: r2, millisecond: o2, microsecond: n2, nanosecond: a2 } = GetISOPartsFromEpoch(e2), { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2 } = function GetFormatterParts(e3, t3) {
    const r3 = getIntlDateTimeFormatEnUsForTimeZone(e3);
    return function parseFromEnUsFormat(e4) {
      const t4 = e4.split(/[^\w]+/);
      if (7 !== t4.length)
        throw new RangeError(`expected 7 parts in "${e4}`);
      const r4 = +t4[0], o3 = +t4[1];
      let n3 = +t4[2];
      const a3 = t4[3].toUpperCase();
      if ("B" === a3 || "BC" === a3)
        n3 = 1 - n3;
      else if ("A" !== a3 && "AD" !== a3)
        throw new RangeError(`Unknown era ${a3} in "${e4}`);
      let i3 = +t4[4];
      24 === i3 && (i3 = 0);
      const s3 = +t4[5], l3 = +t4[6];
      if (!(oe(n3) && oe(r4) && oe(o3) && oe(i3) && oe(s3) && oe(l3)))
        throw new RangeError(`Invalid number in "${e4}`);
      return { year: n3, month: r4, day: o3, hour: i3, minute: s3, second: l3 };
    }(r3.format(new Date(t3)));
  }(t2, r2);
  return BalanceISODateTime(i2, s2, l2, d2, m2, c2, o2, n2, a2);
}
function maxJSBI(t2, r2) {
  return import_jsbi.default.lessThan(t2, r2) ? r2 : t2;
}
function afterLatestPossibleTzdbRuleChange() {
  return import_jsbi.default.add($e(), Ge);
}
function GetIANATimeZonePreviousTransition(t2, r2) {
  const o2 = afterLatestPossibleTzdbRuleChange(), n2 = import_jsbi.default.greaterThan(t2, o2), a2 = n2 ? import_jsbi.default.subtract(t2, ve) : De;
  let i2 = import_jsbi.default.subtract(t2, ue);
  const s2 = GetIANATimeZoneOffsetNanoseconds(i2, r2);
  let l2 = i2, d2 = s2;
  for (; s2 === d2 && import_jsbi.default.greaterThan(i2, a2); )
    l2 = import_jsbi.default.subtract(i2, Oe), d2 = GetIANATimeZoneOffsetNanoseconds(l2, r2), s2 === d2 && (i2 = l2);
  if (s2 === d2) {
    if (n2) {
      return GetIANATimeZonePreviousTransition(import_jsbi.default.subtract(o2, we), r2);
    }
    return null;
  }
  return bisect((e2) => GetIANATimeZoneOffsetNanoseconds(e2, r2), l2, i2, d2, s2);
}
function LeapYear(e2) {
  if (void 0 === e2)
    return false;
  return e2 % 4 == 0 && (!(e2 % 100 == 0) || e2 % 400 == 0);
}
function ISODaysInMonth(e2, t2) {
  return { standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] }[LeapYear(e2) ? "leapyear" : "standard"][t2 - 1];
}
function DayOfWeek(e2, t2, r2) {
  const o2 = t2 + (t2 < 3 ? 10 : -2), n2 = e2 - (t2 < 3 ? 1 : 0), a2 = Q(n2 / 100), i2 = n2 - 100 * a2, s2 = (r2 + Q(2.6 * o2 - 0.2) + (i2 + Q(i2 / 4)) + (Q(a2 / 4) - 2 * a2)) % 7;
  return s2 + (s2 <= 0 ? 7 : 0);
}
function DayOfYear(e2, t2, r2) {
  let o2 = r2;
  for (let r3 = t2 - 1; r3 > 0; r3--)
    o2 += ISODaysInMonth(e2, r3);
  return o2;
}
function DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const m2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2])
    if (0 !== m2)
      return m2 < 0 ? -1 : 1;
  return 0;
}
function BalanceISOYearMonth(e2, t2) {
  let r2 = e2, o2 = t2;
  if (!oe(r2) || !oe(o2))
    throw new RangeError("infinity is out of range");
  return o2 -= 1, r2 += Q(o2 / 12), o2 %= 12, o2 < 0 && (o2 += 12), o2 += 1, { year: r2, month: o2 };
}
function BalanceISODate(e2, t2, r2) {
  let o2 = e2, n2 = t2, a2 = r2;
  if (!oe(a2))
    throw new RangeError("infinity is out of range");
  ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2));
  let i2 = 0, s2 = n2 > 2 ? o2 : o2 - 1;
  for (; i2 = LeapYear(s2) ? 366 : 365, a2 < -i2; )
    o2 -= 1, s2 -= 1, a2 += i2;
  for (s2 += 1; i2 = LeapYear(s2) ? 366 : 365, a2 > i2; )
    o2 += 1, s2 += 1, a2 -= i2;
  for (; a2 < 1; )
    ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 - 1)), a2 += ISODaysInMonth(o2, n2);
  for (; a2 > ISODaysInMonth(o2, n2); )
    a2 -= ISODaysInMonth(o2, n2), { year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 + 1);
  return { year: o2, month: n2, day: a2 };
}
function BalanceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  const { deltaDays: d2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 } = BalanceTime(o2, n2, a2, i2, s2, l2), { year: f2, month: y2, day: S2 } = BalanceISODate(e2, t2, r2 + d2);
  return { year: f2, month: y2, day: S2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 };
}
function BalanceTime(e2, t2, r2, o2, n2, a2) {
  let i2 = e2, s2 = t2, l2 = r2, d2 = o2, m2 = n2, c2 = a2;
  if (!(oe(i2) && oe(s2) && oe(l2) && oe(d2) && oe(m2) && oe(c2)))
    throw new RangeError("infinity is out of range");
  m2 += Q(c2 / 1e3), c2 = NonNegativeModulo(c2, 1e3), d2 += Q(m2 / 1e3), m2 = NonNegativeModulo(m2, 1e3), l2 += Q(d2 / 1e3), d2 = NonNegativeModulo(d2, 1e3), s2 += Q(l2 / 60), l2 = NonNegativeModulo(l2, 60), i2 += Q(s2 / 60), s2 = NonNegativeModulo(s2, 60);
  const h2 = Q(i2 / 24);
  return i2 = NonNegativeModulo(i2, 24), { deltaDays: h2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 };
}
function TotalDurationNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2) {
  const d2 = import_jsbi.default.BigInt(t2);
  let m2 = import_jsbi.default.BigInt(s2);
  0 !== t2 && (m2 = import_jsbi.default.subtract(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(l2)));
  const c2 = import_jsbi.default.add(import_jsbi.default.BigInt(r2), import_jsbi.default.multiply(d2, import_jsbi.default.BigInt(24))), h2 = import_jsbi.default.add(import_jsbi.default.BigInt(o2), import_jsbi.default.multiply(c2, Te)), u2 = import_jsbi.default.add(import_jsbi.default.BigInt(n2), import_jsbi.default.multiply(h2, Te)), T2 = import_jsbi.default.add(import_jsbi.default.BigInt(a2), import_jsbi.default.multiply(u2, pe)), p2 = import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.multiply(T2, pe));
  return import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.multiply(p2, pe));
}
function NanosecondsToDays(t2, o2) {
  const f2 = GetIntrinsic("%Temporal.Instant%"), y2 = ee(import_jsbi.default.toNumber(t2));
  let S2 = import_jsbi.default.BigInt(t2), w2 = 864e11;
  if (0 === y2)
    return { days: 0, nanoseconds: he, dayLengthNs: w2 };
  if (!IsTemporalZonedDateTime(o2)) {
    let t3;
    return { quotient: t3, remainder: S2 } = divmod(S2, import_jsbi.default.BigInt(w2)), { days: import_jsbi.default.toNumber(t3), nanoseconds: S2, dayLengthNs: w2 };
  }
  const g2 = GetSlot(o2, r), I2 = GetSlot(o2, T), D2 = import_jsbi.default.add(g2, S2), G2 = new f2(D2), v2 = GetSlot(o2, p), O2 = GetSlot(o2, u), C2 = BuiltinTimeZoneGetPlainDateTimeFor(v2, I2, O2), E2 = BuiltinTimeZoneGetPlainDateTimeFor(v2, G2, O2);
  let { days: b2 } = DifferenceISODateTime(GetSlot(C2, n), GetSlot(C2, a), GetSlot(C2, i), GetSlot(C2, s), GetSlot(C2, l), GetSlot(C2, d), GetSlot(C2, m), GetSlot(C2, c), GetSlot(C2, h), GetSlot(E2, n), GetSlot(E2, a), GetSlot(E2, i), GetSlot(E2, s), GetSlot(E2, l), GetSlot(E2, d), GetSlot(E2, m), GetSlot(E2, c), GetSlot(E2, h), O2, "day", le(null)), M2 = AddZonedDateTime(I2, v2, O2, 0, 0, 0, b2, 0, 0, 0, 0, 0, 0);
  if (1 === y2)
    for (; b2 > 0 && import_jsbi.default.greaterThan(M2, D2); )
      --b2, M2 = AddZonedDateTime(I2, v2, O2, 0, 0, 0, b2, 0, 0, 0, 0, 0, 0);
  S2 = import_jsbi.default.subtract(D2, M2);
  let R2 = false, Z2 = new f2(M2);
  do {
    const t3 = AddZonedDateTime(Z2, v2, O2, 0, 0, 0, y2, 0, 0, 0, 0, 0, 0), o3 = GetSlot(Z2, r);
    w2 = import_jsbi.default.toNumber(import_jsbi.default.subtract(t3, o3)), R2 = import_jsbi.default.greaterThan(import_jsbi.default.multiply(import_jsbi.default.subtract(S2, import_jsbi.default.BigInt(w2)), import_jsbi.default.BigInt(y2)), he), R2 && (S2 = import_jsbi.default.subtract(S2, import_jsbi.default.BigInt(w2)), Z2 = new f2(t3), b2 += y2);
  } while (R2);
  return { days: b2, nanoseconds: S2, dayLengthNs: K(w2) };
}
function BalanceDuration(t2, o2, n2, a2, i2, s2, l2, d2, m2) {
  let c2, h2, f2, y2, S2, w2, g2 = t2;
  if (IsTemporalZonedDateTime(m2)) {
    const t3 = AddZonedDateTime(GetSlot(m2, T), GetSlot(m2, p), GetSlot(m2, u), 0, 0, 0, g2, o2, n2, a2, i2, s2, l2), d3 = GetSlot(m2, r);
    c2 = import_jsbi.default.subtract(t3, d3);
  } else
    c2 = TotalDurationNanoseconds(g2, o2, n2, a2, i2, s2, l2, 0);
  "year" === d2 || "month" === d2 || "week" === d2 || "day" === d2 ? { days: g2, nanoseconds: c2 } = NanosecondsToDays(c2, m2) : g2 = 0;
  const I2 = import_jsbi.default.lessThan(c2, he) ? -1 : 1;
  switch (c2 = abs(c2), h2 = f2 = y2 = S2 = w2 = he, d2) {
    case "year":
    case "month":
    case "week":
    case "day":
    case "hour":
      ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe), { quotient: y2, remainder: f2 } = divmod(f2, pe), { quotient: S2, remainder: y2 } = divmod(y2, Te), { quotient: w2, remainder: S2 } = divmod(S2, Te);
      break;
    case "minute":
      ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe), { quotient: y2, remainder: f2 } = divmod(f2, pe), { quotient: S2, remainder: y2 } = divmod(y2, Te);
      break;
    case "second":
      ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe), { quotient: y2, remainder: f2 } = divmod(f2, pe);
      break;
    case "millisecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, pe)), { quotient: f2, remainder: h2 } = divmod(h2, pe);
      break;
    case "microsecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, pe));
      break;
    case "nanosecond":
      break;
    default:
      throw new Error("assert not reached");
  }
  return { days: g2, hours: import_jsbi.default.toNumber(w2) * I2, minutes: import_jsbi.default.toNumber(S2) * I2, seconds: import_jsbi.default.toNumber(y2) * I2, milliseconds: import_jsbi.default.toNumber(f2) * I2, microseconds: import_jsbi.default.toNumber(h2) * I2, nanoseconds: import_jsbi.default.toNumber(c2) * I2 };
}
function UnbalanceDurationRelative(e2, t2, r2, o2, n2, a2) {
  let i2 = e2, s2 = t2, l2 = r2, d2 = o2;
  const m2 = GetIntrinsic("%Temporal.Duration%"), c2 = DurationSign(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
  let h2, T2;
  a2 && (T2 = ToTemporalDate(a2), h2 = GetSlot(T2, u));
  const p2 = new m2(c2), f2 = new m2(0, c2), S2 = new m2(0, 0, c2);
  switch (n2) {
    case "year":
      break;
    case "month":
      {
        if (!h2)
          throw new RangeError("a starting point is required for months balancing");
        const e3 = h2.dateAdd, t3 = h2.dateUntil;
        let r3 = T2;
        for (; K(i2) > 0; ) {
          const o3 = CalendarDateAdd(h2, r3, p2, void 0, e3), n3 = le(null);
          n3.largestUnit = "month";
          const a3 = GetSlot(CalendarDateUntil(h2, r3, o3, n3, t3), y);
          r3 = o3, s2 += a3, i2 -= c2;
        }
      }
      break;
    case "week":
      if (!h2)
        throw new RangeError("a starting point is required for weeks balancing");
      for (; K(i2) > 0; ) {
        let e3;
        ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, p2)), d2 += e3, i2 -= c2;
      }
      for (; K(s2) > 0; ) {
        let e3;
        ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, f2)), d2 += e3, s2 -= c2;
      }
      break;
    default:
      for (; K(i2) > 0; ) {
        if (!h2)
          throw new RangeError("a starting point is required for balancing calendar units");
        let e3;
        ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, p2)), d2 += e3, i2 -= c2;
      }
      for (; K(s2) > 0; ) {
        if (!h2)
          throw new RangeError("a starting point is required for balancing calendar units");
        let e3;
        ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, f2)), d2 += e3, s2 -= c2;
      }
      for (; K(l2) > 0; ) {
        if (!h2)
          throw new RangeError("a starting point is required for balancing calendar units");
        let e3;
        ({ relativeTo: T2, days: e3 } = MoveRelativeDate(h2, T2, S2)), d2 += e3, l2 -= c2;
      }
  }
  return { years: i2, months: s2, weeks: l2, days: d2 };
}
function CalculateOffsetShift(e2, t2, r2, o2, n2) {
  if (IsTemporalZonedDateTime(e2)) {
    const a2 = GetSlot(e2, T), i2 = GetSlot(e2, p), s2 = GetSlot(e2, u), l2 = GetOffsetNanosecondsFor(i2, a2), d2 = AddZonedDateTime(a2, i2, s2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
    return GetOffsetNanosecondsFor(i2, new (GetIntrinsic("%Temporal.Instant%"))(d2)) - l2;
  }
  return 0;
}
function CreateNegatedTemporalDuration(e2) {
  return new (GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e2, f), -GetSlot(e2, y), -GetSlot(e2, S), -GetSlot(e2, w), -GetSlot(e2, g), -GetSlot(e2, I), -GetSlot(e2, D), -GetSlot(e2, G), -GetSlot(e2, v), -GetSlot(e2, O));
}
function ConstrainToRange(e2, t2, r2) {
  return V(r2, X(t2, e2));
}
function ConstrainISODate(e2, t2, r2) {
  const o2 = ConstrainToRange(t2, 1, 12);
  return { year: e2, month: o2, day: ConstrainToRange(r2, 1, ISODaysInMonth(e2, o2)) };
}
function RejectToRange(e2, t2, r2) {
  if (e2 < t2 || e2 > r2)
    throw new RangeError(`value out of range: ${t2} <= ${e2} <= ${r2}`);
}
function RejectISODate(e2, t2, r2) {
  RejectToRange(t2, 1, 12), RejectToRange(r2, 1, ISODaysInMonth(e2, t2));
}
function RejectDateRange(e2, t2, r2) {
  RejectDateTimeRange(e2, t2, r2, 12, 0, 0, 0, 0, 0);
}
function RejectTime(e2, t2, r2, o2, n2, a2) {
  RejectToRange(e2, 0, 23), RejectToRange(t2, 0, 59), RejectToRange(r2, 0, 59), RejectToRange(o2, 0, 999), RejectToRange(n2, 0, 999), RejectToRange(a2, 0, 999);
}
function RejectDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  RejectISODate(e2, t2, r2), RejectTime(o2, n2, a2, i2, s2, l2);
}
function RejectDateTimeRange(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  if (RejectToRange(e2, -271821, 275760), -271821 === e2 && null == GetEpochFromISOParts(e2, t2, r2 + 1, o2, n2, a2, i2, s2, l2 - 1) || 275760 === e2 && null == GetEpochFromISOParts(e2, t2, r2 - 1, o2, n2, a2, i2, s2, l2 + 1))
    throw new RangeError("DateTime outside of supported range");
}
function ValidateEpochNanoseconds(t2) {
  if (import_jsbi.default.lessThan(t2, ge) || import_jsbi.default.greaterThan(t2, Ie))
    throw new RangeError("Instant outside of supported range");
}
function RejectDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2);
  for (const c2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2]) {
    if (!oe(c2))
      throw new RangeError("infinite values not allowed as duration fields");
    const e3 = ee(c2);
    if (0 !== e3 && e3 !== m2)
      throw new RangeError("mixed-sign values not allowed as duration fields");
  }
}
function DifferenceISODate(e2, t2, r2, o2, n2, a2, i2) {
  switch (i2) {
    case "year":
    case "month": {
      const s2 = -CompareISODate(e2, t2, r2, o2, n2, a2);
      if (0 === s2)
        return { years: 0, months: 0, weeks: 0, days: 0 };
      const l2 = { year: e2, month: t2, day: r2 }, d2 = { year: o2, month: n2, day: a2 };
      let m2 = d2.year - l2.year, c2 = AddISODate(e2, t2, r2, m2, 0, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2);
      if (0 === h2)
        return "year" === i2 ? { years: m2, months: 0, weeks: 0, days: 0 } : { years: 0, months: 12 * m2, weeks: 0, days: 0 };
      let u2 = d2.month - l2.month;
      if (h2 !== s2 && (m2 -= s2, u2 += 12 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2), 0 === h2)
        return "year" === i2 ? { years: m2, months: u2, weeks: 0, days: 0 } : { years: 0, months: u2 + 12 * m2, weeks: 0, days: 0 };
      h2 !== s2 && (u2 -= s2, u2 === -s2 && (m2 -= s2, u2 = 11 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"));
      let T2 = 0;
      return T2 = c2.month === d2.month ? d2.day - c2.day : s2 < 0 ? -c2.day - (ISODaysInMonth(d2.year, d2.month) - d2.day) : d2.day + (ISODaysInMonth(c2.year, c2.month) - c2.day), "month" === i2 && (u2 += 12 * m2, m2 = 0), { years: m2, months: u2, weeks: 0, days: T2 };
    }
    case "week":
    case "day": {
      let s2, l2, d2;
      CompareISODate(e2, t2, r2, o2, n2, a2) < 0 ? (l2 = { year: e2, month: t2, day: r2 }, s2 = { year: o2, month: n2, day: a2 }, d2 = 1) : (l2 = { year: o2, month: n2, day: a2 }, s2 = { year: e2, month: t2, day: r2 }, d2 = -1);
      let m2 = DayOfYear(s2.year, s2.month, s2.day) - DayOfYear(l2.year, l2.month, l2.day);
      for (let e3 = l2.year; e3 < s2.year; ++e3)
        m2 += LeapYear(e3) ? 366 : 365;
      let c2 = 0;
      return "week" === i2 && (c2 = Q(m2 / 7), m2 %= 7), c2 *= d2, m2 *= d2, { years: 0, months: 0, weeks: c2, days: m2 };
    }
    default:
      throw new Error("assert not reached");
  }
}
function DifferenceTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = i2 - e2, u2 = s2 - t2, T2 = l2 - r2, p2 = d2 - o2, f2 = m2 - n2, y2 = c2 - a2;
  const S2 = DurationSign(0, 0, 0, 0, h2, u2, T2, p2, f2, y2);
  h2 *= S2, u2 *= S2, T2 *= S2, p2 *= S2, f2 *= S2, y2 *= S2;
  let w2 = 0;
  if ({ deltaDays: w2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), 0 != w2)
    throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
  return h2 *= S2, u2 *= S2, T2 *= S2, p2 *= S2, f2 *= S2, y2 *= S2, { hours: h2, minutes: u2, seconds: T2, milliseconds: p2, microseconds: f2, nanoseconds: y2 };
}
function DifferenceInstant(t2, r2, o2, n2, a2) {
  const i2 = import_jsbi.default.subtract(r2, t2), s2 = import_jsbi.default.remainder(i2, import_jsbi.default.BigInt(864e11)), l2 = import_jsbi.default.subtract(i2, s2), d2 = RoundNumberToIncrement(s2, Ne[n2] * o2, a2), m2 = import_jsbi.default.add(l2, d2), c2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(m2, pe)), h2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(m2, pe), pe)), u2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(m2, fe), pe));
  return { seconds: import_jsbi.default.toNumber(import_jsbi.default.divide(m2, ye)), milliseconds: u2, microseconds: h2, nanoseconds: c2 };
}
function DifferenceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, S2, w2, g2) {
  let I2 = e2, D2 = t2, G2 = r2, { hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 } = DifferenceTime(o2, n2, a2, i2, s2, l2, h2, u2, T2, p2, f2, y2);
  const R2 = DurationSign(0, 0, 0, 0, v2, O2, C2, E2, b2, M2);
  CompareISODate(d2, m2, c2, I2, D2, G2) === -R2 && ({ year: I2, month: D2, day: G2 } = BalanceISODate(I2, D2, G2 - R2), { hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 } = BalanceDuration(-R2, v2, O2, C2, E2, b2, M2, w2));
  const Z2 = CreateTemporalDate(I2, D2, G2, S2), P2 = CreateTemporalDate(d2, m2, c2, S2), F2 = MergeLargestUnitOption(g2, LargerOfTwoTemporalUnits("day", w2));
  let { years: Y2, months: j2, weeks: $2, days: B2 } = CalendarDateUntil(S2, Z2, P2, F2);
  return { days: B2, hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 } = BalanceDuration(B2, v2, O2, C2, E2, b2, M2, w2), { years: Y2, months: j2, weeks: $2, days: B2, hours: v2, minutes: O2, seconds: C2, milliseconds: E2, microseconds: b2, nanoseconds: M2 };
}
function DifferenceZonedDateTime(t2, r2, o2, u2, T2, p2) {
  const f2 = import_jsbi.default.subtract(r2, t2);
  if (import_jsbi.default.equal(f2, he))
    return { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  const y2 = GetIntrinsic("%Temporal.Instant%"), S2 = new y2(t2), w2 = new y2(r2), g2 = BuiltinTimeZoneGetPlainDateTimeFor(o2, S2, u2), I2 = BuiltinTimeZoneGetPlainDateTimeFor(o2, w2, u2);
  let { years: D2, months: G2, weeks: v2, days: O2 } = DifferenceISODateTime(GetSlot(g2, n), GetSlot(g2, a), GetSlot(g2, i), GetSlot(g2, s), GetSlot(g2, l), GetSlot(g2, d), GetSlot(g2, m), GetSlot(g2, c), GetSlot(g2, h), GetSlot(I2, n), GetSlot(I2, a), GetSlot(I2, i), GetSlot(I2, s), GetSlot(I2, l), GetSlot(I2, d), GetSlot(I2, m), GetSlot(I2, c), GetSlot(I2, h), u2, T2, p2);
  const C2 = AddZonedDateTime(S2, o2, u2, D2, G2, v2, 0, 0, 0, 0, 0, 0, 0);
  let E2 = import_jsbi.default.subtract(r2, C2);
  const b2 = CreateTemporalZonedDateTime(C2, o2, u2);
  ({ nanoseconds: E2, days: O2 } = NanosecondsToDays(E2, b2));
  const { hours: M2, minutes: R2, seconds: Z2, milliseconds: P2, microseconds: F2, nanoseconds: Y2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(E2), "hour");
  return { years: D2, months: G2, weeks: v2, days: O2, hours: M2, minutes: R2, seconds: Z2, milliseconds: P2, microseconds: F2, nanoseconds: Y2 };
}
function DifferenceTemporalInstant(e2, t2, o2, n2) {
  const a2 = ToTemporalInstant(o2);
  let i2, s2;
  [i2, s2] = "until" === e2 ? [t2, a2] : [a2, t2];
  const l2 = GetOptionsObject(n2), d2 = GetTemporalUnit(l2, "smallestUnit", "time", "nanosecond"), m2 = LargerOfTwoTemporalUnits("second", d2);
  let c2 = GetTemporalUnit(l2, "largestUnit", "time", "auto");
  if ("auto" === c2 && (c2 = m2), LargerOfTwoTemporalUnits(c2, d2) !== c2)
    throw new RangeError(`largestUnit ${c2} cannot be smaller than smallestUnit ${d2}`);
  const h2 = ToTemporalRoundingMode(l2, "trunc"), u2 = ToTemporalRoundingIncrement(l2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[d2], false), T2 = GetSlot(i2, r), p2 = GetSlot(s2, r);
  let f2, y2, { seconds: S2, milliseconds: w2, microseconds: g2, nanoseconds: I2 } = DifferenceInstant(T2, p2, u2, d2, h2);
  ({ hours: f2, minutes: y2, seconds: S2, milliseconds: w2, microseconds: g2, nanoseconds: I2 } = BalanceDuration(0, 0, 0, S2, w2, g2, I2, c2));
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, f2, y2, S2, w2, g2, I2);
}
function DifferenceTemporalPlainDate(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDate(r2), i2 = GetSlot(t2, u), s2 = GetSlot(a2, u), l2 = ToString(i2), d2 = ToString(s2);
  if (l2 !== d2)
    throw new RangeError(`cannot compute difference between dates of ${l2} and ${d2} calendars`);
  const m2 = GetOptionsObject(o2), c2 = GetTemporalUnit(m2, "smallestUnit", "date", "day"), h2 = LargerOfTwoTemporalUnits("day", c2);
  let T2 = GetTemporalUnit(m2, "largestUnit", "date", "auto");
  if ("auto" === T2 && (T2 = h2), LargerOfTwoTemporalUnits(T2, c2) !== T2)
    throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${c2}`);
  let p2 = ToTemporalRoundingMode(m2, "trunc");
  "since" === e2 && (p2 = NegateTemporalRoundingMode(p2));
  const f2 = ToTemporalRoundingIncrement(m2, void 0, false), y2 = MergeLargestUnitOption(m2, T2);
  let { years: S2, months: w2, weeks: g2, days: I2 } = CalendarDateUntil(i2, t2, a2, y2);
  "day" === c2 && 1 === f2 || ({ years: S2, months: w2, weeks: g2, days: I2 } = RoundDuration(S2, w2, g2, I2, 0, 0, 0, 0, 0, 0, f2, c2, p2, t2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * S2, n2 * w2, n2 * g2, n2 * I2, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalPlainDateTime(e2, t2, r2, o2) {
  const T2 = "since" === e2 ? -1 : 1, p2 = ToTemporalDateTime(r2), f2 = GetSlot(t2, u), y2 = GetSlot(p2, u), S2 = ToString(f2), w2 = ToString(y2);
  if (S2 !== w2)
    throw new RangeError(`cannot compute difference between dates of ${S2} and ${w2} calendars`);
  const g2 = GetOptionsObject(o2), I2 = GetTemporalUnit(g2, "smallestUnit", "datetime", "nanosecond"), D2 = LargerOfTwoTemporalUnits("day", I2);
  let G2 = GetTemporalUnit(g2, "largestUnit", "datetime", "auto");
  if ("auto" === G2 && (G2 = D2), LargerOfTwoTemporalUnits(G2, I2) !== G2)
    throw new RangeError(`largestUnit ${G2} cannot be smaller than smallestUnit ${I2}`);
  let v2 = ToTemporalRoundingMode(g2, "trunc");
  "since" === e2 && (v2 = NegateTemporalRoundingMode(v2));
  const O2 = ToTemporalDateTimeRoundingIncrement(g2, I2);
  let { years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = DifferenceISODateTime(GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(p2, n), GetSlot(p2, a), GetSlot(p2, i), GetSlot(p2, s), GetSlot(p2, l), GetSlot(p2, d), GetSlot(p2, m), GetSlot(p2, c), GetSlot(p2, h), f2, G2, g2);
  const $2 = TemporalDateTimeToDate(t2);
  ({ years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = RoundDuration(C2, E2, b2, M2, R2, Z2, P2, F2, Y2, j2, O2, I2, v2, $2)), { days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(M2, R2, Z2, P2, F2, Y2, j2, G2);
  return new (GetIntrinsic("%Temporal.Duration%"))(T2 * C2, T2 * E2, T2 * b2, T2 * M2, T2 * R2, T2 * Z2, T2 * P2, T2 * F2, T2 * Y2, T2 * j2);
}
function DifferenceTemporalPlainTime(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalTime(r2), i2 = GetOptionsObject(o2);
  let u2 = GetTemporalUnit(i2, "largestUnit", "time", "auto");
  "auto" === u2 && (u2 = "hour");
  const T2 = GetTemporalUnit(i2, "smallestUnit", "time", "nanosecond");
  if (LargerOfTwoTemporalUnits(u2, T2) !== u2)
    throw new RangeError(`largestUnit ${u2} cannot be smaller than smallestUnit ${T2}`);
  let p2 = ToTemporalRoundingMode(i2, "trunc");
  "since" === e2 && (p2 = NegateTemporalRoundingMode(p2));
  const f2 = ToTemporalRoundingIncrement(i2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[T2], false);
  let { hours: y2, minutes: S2, seconds: w2, milliseconds: g2, microseconds: I2, nanoseconds: D2 } = DifferenceTime(GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(a2, s), GetSlot(a2, l), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h));
  ({ hours: y2, minutes: S2, seconds: w2, milliseconds: g2, microseconds: I2, nanoseconds: D2 } = RoundDuration(0, 0, 0, 0, y2, S2, w2, g2, I2, D2, f2, T2, p2)), { hours: y2, minutes: S2, seconds: w2, milliseconds: g2, microseconds: I2, nanoseconds: D2 } = BalanceDuration(0, y2, S2, w2, g2, I2, D2, u2);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, n2 * y2, n2 * S2, n2 * w2, n2 * g2, n2 * I2, n2 * D2);
}
function DifferenceTemporalPlainYearMonth(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalYearMonth(r2), i2 = GetSlot(t2, u), s2 = GetSlot(a2, u), l2 = ToString(i2), d2 = ToString(s2);
  if (l2 !== d2)
    throw new RangeError(`cannot compute difference between months of ${l2} and ${d2} calendars`);
  const m2 = GetOptionsObject(o2), c2 = Me.reduce((e3, [t3, r3, o3]) => ("date" === o3 && "week" !== r3 && "day" !== r3 && e3.push(r3, t3), e3), []), h2 = GetTemporalUnit(m2, "smallestUnit", "date", "month");
  if ("week" === h2 || "day" === h2)
    throw new RangeError(`smallestUnit must be one of ${c2.join(", ")}, not ${h2}`);
  let T2 = GetTemporalUnit(m2, "largestUnit", "date", "auto");
  if ("week" === T2 || "day" === T2)
    throw new RangeError(`largestUnit must be one of ${c2.join(", ")}, not ${T2}`);
  if ("auto" === T2 && (T2 = "year"), LargerOfTwoTemporalUnits(T2, h2) !== T2)
    throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${h2}`);
  let p2 = ToTemporalRoundingMode(m2, "trunc");
  "since" === e2 && (p2 = NegateTemporalRoundingMode(p2));
  const f2 = ToTemporalRoundingIncrement(m2, void 0, false), y2 = CalendarFields(i2, ["monthCode", "year"]), S2 = PrepareTemporalFields(a2, y2, []);
  S2.day = 1;
  const w2 = PrepareTemporalFields(t2, y2, []);
  w2.day = 1;
  const g2 = CalendarDateFromFields(i2, S2), I2 = CalendarDateFromFields(i2, w2), D2 = MergeLargestUnitOption(m2, T2);
  let { years: G2, months: v2 } = CalendarDateUntil(i2, I2, g2, D2);
  "month" === h2 && 1 === f2 || ({ years: G2, months: v2 } = RoundDuration(G2, v2, 0, 0, 0, 0, 0, 0, 0, 0, f2, h2, p2, I2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * G2, n2 * v2, 0, 0, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalZonedDateTime(e2, t2, o2, n2) {
  const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalZonedDateTime(o2), s2 = GetSlot(t2, u), l2 = GetSlot(i2, u), d2 = ToString(s2), m2 = ToString(l2);
  if (d2 !== m2)
    throw new RangeError(`cannot compute difference between dates of ${d2} and ${m2} calendars`);
  const c2 = GetOptionsObject(n2), h2 = GetTemporalUnit(c2, "smallestUnit", "datetime", "nanosecond"), T2 = LargerOfTwoTemporalUnits("hour", h2);
  let f2 = GetTemporalUnit(c2, "largestUnit", "datetime", "auto");
  if ("auto" === f2 && (f2 = T2), LargerOfTwoTemporalUnits(f2, h2) !== f2)
    throw new RangeError(`largestUnit ${f2} cannot be smaller than smallestUnit ${h2}`);
  let y2 = ToTemporalRoundingMode(c2, "trunc");
  "since" === e2 && (y2 = NegateTemporalRoundingMode(y2));
  const S2 = ToTemporalDateTimeRoundingIncrement(c2, h2), w2 = GetSlot(t2, r), g2 = GetSlot(i2, r);
  let I2, D2, G2, v2, O2, C2, E2, b2, M2, R2;
  if ("year" !== f2 && "month" !== f2 && "week" !== f2 && "day" !== f2)
    I2 = 0, D2 = 0, G2 = 0, v2 = 0, { seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = DifferenceInstant(w2, g2, S2, h2, y2), { hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = BalanceDuration(0, 0, 0, E2, b2, M2, R2, f2);
  else {
    const e3 = GetSlot(t2, p);
    if (!TimeZoneEquals(e3, GetSlot(i2, p)))
      throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
    const r2 = MergeLargestUnitOption(c2, f2);
    ({ years: I2, months: D2, weeks: G2, days: v2, hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = DifferenceZonedDateTime(w2, g2, e3, s2, f2, r2)), { years: I2, months: D2, weeks: G2, days: v2, hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = RoundDuration(I2, D2, G2, v2, O2, C2, E2, b2, M2, R2, S2, h2, y2, t2), { years: I2, months: D2, weeks: G2, days: v2, hours: O2, minutes: C2, seconds: E2, milliseconds: b2, microseconds: M2, nanoseconds: R2 } = AdjustRoundedDurationDays(I2, D2, G2, v2, O2, C2, E2, b2, M2, R2, S2, h2, y2, t2);
  }
  return new (GetIntrinsic("%Temporal.Duration%"))(a2 * I2, a2 * D2, a2 * G2, a2 * v2, a2 * O2, a2 * C2, a2 * E2, a2 * b2, a2 * M2, a2 * R2);
}
function AddISODate(e2, t2, r2, o2, n2, a2, i2, s2) {
  let l2 = e2, d2 = t2, m2 = r2, c2 = a2, h2 = i2;
  return l2 += o2, d2 += n2, { year: l2, month: d2 } = BalanceISOYearMonth(l2, d2), { year: l2, month: d2, day: m2 } = RegulateISODate(l2, d2, m2, s2), h2 += 7 * c2, m2 += h2, { year: l2, month: d2, day: m2 } = BalanceISODate(l2, d2, m2), { year: l2, month: d2, day: m2 };
}
function AddTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = e2, u2 = t2, T2 = r2, p2 = o2, f2 = n2, y2 = a2;
  h2 += i2, u2 += s2, T2 += l2, p2 += d2, f2 += m2, y2 += c2;
  let S2 = 0;
  return { deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), { deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 };
}
function AddDuration(e2, t2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, f2, y2, S2, w2, g2, I2, D2, G2, v2) {
  const O2 = LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(e2, t2, o2, n2, a2, i2, s2, l2, d2, m2), DefaultTemporalLargestUnit(c2, h2, f2, y2, S2, w2, g2, I2, D2, G2));
  let C2, E2, b2, M2, R2, Z2, P2, F2, Y2, j2;
  if (v2)
    if (IsTemporalDate(v2)) {
      const r2 = GetIntrinsic("%Temporal.Duration%"), T2 = GetSlot(v2, u), p2 = new r2(e2, t2, o2, n2, 0, 0, 0, 0, 0, 0), $2 = new r2(c2, h2, f2, y2, 0, 0, 0, 0, 0, 0), B2 = T2.dateAdd, N10 = CalendarDateAdd(T2, v2, p2, void 0, B2), k2 = CalendarDateAdd(T2, N10, $2, void 0, B2), A2 = LargerOfTwoTemporalUnits("day", O2), U2 = le(null);
      U2.largestUnit = A2, { years: C2, months: E2, weeks: b2, days: M2 } = CalendarDateUntil(T2, v2, k2, U2), { days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(M2, a2 + S2, i2 + w2, s2 + g2, l2 + I2, d2 + D2, m2 + G2, O2);
    } else {
      const $2 = GetIntrinsic("%Temporal.Instant%"), B2 = GetSlot(v2, p), N10 = GetSlot(v2, u), k2 = AddZonedDateTime(GetSlot(v2, T), B2, N10, e2, t2, o2, n2, a2, i2, s2, l2, d2, m2), A2 = AddZonedDateTime(new $2(k2), B2, N10, c2, h2, f2, y2, S2, w2, g2, I2, D2, G2);
      "year" !== O2 && "month" !== O2 && "week" !== O2 && "day" !== O2 ? (C2 = 0, E2 = 0, b2 = 0, M2 = 0, { seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = DifferenceInstant(GetSlot(v2, r), A2, 1, "nanosecond", "halfExpand"), { hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(0, 0, 0, P2, F2, Y2, j2, O2)) : { years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = DifferenceZonedDateTime(GetSlot(v2, r), A2, B2, N10, O2, le(null));
    }
  else {
    if ("year" === O2 || "month" === O2 || "week" === O2)
      throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
    C2 = E2 = b2 = 0, { days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 } = BalanceDuration(n2 + y2, a2 + S2, i2 + w2, s2 + g2, l2 + I2, d2 + D2, m2 + G2, O2);
  }
  return RejectDuration(C2, E2, b2, M2, R2, Z2, P2, F2, Y2, j2), { years: C2, months: E2, weeks: b2, days: M2, hours: R2, minutes: Z2, seconds: P2, milliseconds: F2, microseconds: Y2, nanoseconds: j2 };
}
function AddInstant(t2, r2, o2, n2, a2, i2, s2) {
  let l2 = he;
  l2 = import_jsbi.default.add(l2, import_jsbi.default.BigInt(s2)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(i2), pe)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(a2), fe)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(n2), ye)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(6e10))), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), import_jsbi.default.BigInt(36e11)));
  const d2 = import_jsbi.default.add(t2, l2);
  return ValidateEpochNanoseconds(d2), d2;
}
function AddDateTime(e2, t2, r2, o2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, S2, w2, g2, I2, D2, G2) {
  let v2 = f2, { deltaDays: O2, hour: C2, minute: E2, second: b2, millisecond: M2, microsecond: R2, nanosecond: Z2 } = AddTime(o2, s2, l2, d2, m2, c2, y2, S2, w2, g2, I2, D2);
  v2 += O2;
  const P2 = GetIntrinsic("%Temporal.Duration%"), F2 = CalendarDateAdd(h2, CreateTemporalDate(e2, t2, r2, h2), new P2(u2, T2, p2, v2, 0, 0, 0, 0, 0, 0), G2);
  return { year: GetSlot(F2, n), month: GetSlot(F2, a), day: GetSlot(F2, i), hour: C2, minute: E2, second: b2, millisecond: M2, microsecond: R2, nanosecond: Z2 };
}
function AddZonedDateTime(e2, t2, o2, u2, T2, p2, f2, y2, S2, w2, g2, I2, D2, G2) {
  const v2 = GetIntrinsic("%Temporal.Duration%");
  if (0 === DurationSign(u2, T2, p2, f2, 0, 0, 0, 0, 0, 0))
    return AddInstant(GetSlot(e2, r), y2, S2, w2, g2, I2, D2);
  const O2 = BuiltinTimeZoneGetPlainDateTimeFor(t2, e2, o2), C2 = CalendarDateAdd(o2, CreateTemporalDate(GetSlot(O2, n), GetSlot(O2, a), GetSlot(O2, i), o2), new v2(u2, T2, p2, f2, 0, 0, 0, 0, 0, 0), G2), E2 = CreateTemporalDateTime(GetSlot(C2, n), GetSlot(C2, a), GetSlot(C2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(O2, d), GetSlot(O2, m), GetSlot(O2, c), GetSlot(O2, h), o2);
  return AddInstant(GetSlot(BuiltinTimeZoneGetInstantFor(t2, E2, "compatible"), r), y2, S2, w2, g2, I2, D2);
}
function AddDurationToOrSubtractDurationFromDuration(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1;
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2);
  const p2 = ToRelativeTemporalObject(GetOptionsObject(o2));
  ({ years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = AddDuration(GetSlot(t2, f), GetSlot(t2, y), GetSlot(t2, S), GetSlot(t2, w), GetSlot(t2, g), GetSlot(t2, I), GetSlot(t2, D), GetSlot(t2, G), GetSlot(t2, v), GetSlot(t2, O), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, p2));
  return new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, d2, m2, c2, h2, u2, T2);
}
function AddDurationToOrSubtractDurationFromInstant(e2, t2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = function ToLimitedTemporalDuration(e3, t3) {
    let r2 = ToTemporalDurationRecord(e3);
    for (const e4 of t3)
      if (0 !== r2[e4])
        throw new RangeError(`Duration field ${e4} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
    return r2;
  }(o2, ["years", "months", "weeks", "days"]), c2 = AddInstant(GetSlot(t2, r), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2);
  return new (GetIntrinsic("%Temporal.Instant%"))(c2);
}
function AddDurationToOrSubtractDurationFromPlainDateTime(e2, t2, r2, o2) {
  const T2 = "subtract" === e2 ? -1 : 1, { years: p2, months: f2, weeks: y2, days: S2, hours: w2, minutes: g2, seconds: I2, milliseconds: D2, microseconds: G2, nanoseconds: v2 } = ToTemporalDurationRecord(r2), O2 = GetOptionsObject(o2), C2 = GetSlot(t2, u), { year: E2, month: b2, day: M2, hour: R2, minute: Z2, second: P2, millisecond: F2, microsecond: Y2, nanosecond: j2 } = AddDateTime(GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), C2, T2 * p2, T2 * f2, T2 * y2, T2 * S2, T2 * w2, T2 * g2, T2 * I2, T2 * D2, T2 * G2, T2 * v2, O2);
  return CreateTemporalDateTime(E2, b2, M2, R2, Z2, P2, F2, Y2, j2, C2);
}
function AddDurationToOrSubtractDurationFromPlainTime(e2, t2, r2) {
  const o2 = "subtract" === e2 ? -1 : 1, { hours: n2, minutes: a2, seconds: i2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = ToTemporalDurationRecord(r2);
  let { hour: f2, minute: y2, second: S2, millisecond: w2, microsecond: g2, nanosecond: I2 } = AddTime(GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), o2 * n2, o2 * a2, o2 * i2, o2 * u2, o2 * T2, o2 * p2);
  ({ hour: f2, minute: y2, second: S2, millisecond: w2, microsecond: g2, nanosecond: I2 } = RegulateTime(f2, y2, S2, w2, g2, I2, "reject"));
  return new (GetIntrinsic("%Temporal.PlainTime%"))(f2, y2, S2, w2, g2, I2);
}
function AddDurationToOrSubtractDurationFromPlainYearMonth(e2, t2, r2, o2) {
  let n2 = ToTemporalDurationRecord(r2);
  "subtract" === e2 && (n2 = { years: -n2.years, months: -n2.months, weeks: -n2.weeks, days: -n2.days, hours: -n2.hours, minutes: -n2.minutes, seconds: -n2.seconds, milliseconds: -n2.milliseconds, microseconds: -n2.microseconds, nanoseconds: -n2.nanoseconds });
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: T2, nanoseconds: p2 } = n2;
  ({ days: l2 } = BalanceDuration(l2, d2, m2, c2, h2, T2, p2, "day"));
  const f2 = GetOptionsObject(o2), y2 = GetSlot(t2, u), S2 = CalendarFields(y2, ["monthCode", "year"]), w2 = PrepareTemporalFields(t2, S2, []), g2 = DurationSign(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0);
  w2.day = g2 < 0 ? ToPositiveInteger(CalendarDaysInMonth(y2, t2)) : 1;
  const I2 = CalendarDateFromFields(y2, w2), D2 = new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), G2 = se(le(null), f2);
  return CalendarYearMonthFromFields(y2, PrepareTemporalFields(CalendarDateAdd(y2, I2, D2, f2), S2, []), G2);
}
function AddDurationToOrSubtractDurationFromZonedDateTime(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: f2, nanoseconds: y2 } = ToTemporalDurationRecord(r2), S2 = GetOptionsObject(o2), w2 = GetSlot(t2, p), g2 = GetSlot(t2, u);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(t2, T), w2, g2, n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * f2, n2 * y2, S2), w2, g2);
}
function RoundNumberToIncrement(t2, r2, o2) {
  if (1 === r2)
    return t2;
  let { quotient: n2, remainder: a2 } = divmod(t2, import_jsbi.default.BigInt(r2));
  if (import_jsbi.default.equal(a2, he))
    return t2;
  const i2 = import_jsbi.default.lessThan(a2, he) ? -1 : 1;
  switch (o2) {
    case "ceil":
      i2 > 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "floor":
      i2 < 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "trunc":
      break;
    case "halfExpand":
      import_jsbi.default.toNumber(abs(import_jsbi.default.multiply(a2, import_jsbi.default.BigInt(2)))) >= r2 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
  }
  return import_jsbi.default.multiply(n2, import_jsbi.default.BigInt(r2));
}
function RoundInstant(t2, r2, o2, n2) {
  let a2 = import_jsbi.default.remainder(t2, import_jsbi.default.BigInt(864e11));
  import_jsbi.default.lessThan(a2, he) && (a2 = import_jsbi.default.add(a2, import_jsbi.default.BigInt(864e11)));
  const i2 = import_jsbi.default.subtract(t2, a2), s2 = RoundNumberToIncrement(a2, Ne[o2] * r2, n2);
  return import_jsbi.default.add(i2, s2);
}
function RoundISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2 = 864e11) {
  const { deltaDays: u2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: S2, nanosecond: w2 } = RoundTime(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { year: g2, month: I2, day: D2 } = BalanceISODate(e2, t2, r2 + u2);
  return { year: g2, month: I2, day: D2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: S2, nanosecond: w2 };
}
function RoundTime(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2 = 864e11) {
  let c2 = he;
  switch (l2) {
    case "day":
    case "hour":
      c2 = import_jsbi.default.BigInt(t2);
    case "minute":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, Te), import_jsbi.default.BigInt(r2));
    case "second":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, Te), import_jsbi.default.BigInt(o2));
    case "millisecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, pe), import_jsbi.default.BigInt(n2));
    case "microsecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, pe), import_jsbi.default.BigInt(a2));
    case "nanosecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, pe), import_jsbi.default.BigInt(i2));
  }
  const h2 = "day" === l2 ? m2 : Ne[l2], u2 = RoundNumberToIncrement(c2, h2 * s2, d2), T2 = import_jsbi.default.toNumber(import_jsbi.default.divide(u2, import_jsbi.default.BigInt(h2)));
  switch (l2) {
    case "day":
      return { deltaDays: T2, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };
    case "hour":
      return BalanceTime(T2, 0, 0, 0, 0, 0);
    case "minute":
      return BalanceTime(t2, T2, 0, 0, 0, 0);
    case "second":
      return BalanceTime(t2, r2, T2, 0, 0, 0);
    case "millisecond":
      return BalanceTime(t2, r2, o2, T2, 0, 0);
    case "microsecond":
      return BalanceTime(t2, r2, o2, n2, T2, 0);
    case "nanosecond":
      return BalanceTime(t2, r2, o2, n2, a2, T2);
    default:
      throw new Error(`Invalid unit ${l2}`);
  }
}
function DaysUntil(e2, t2) {
  return DifferenceISODate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), "day").days;
}
function MoveRelativeDate(e2, t2, r2) {
  const o2 = CalendarDateAdd(e2, t2, r2, void 0);
  return { relativeTo: o2, days: DaysUntil(t2, o2) };
}
function MoveRelativeZonedDateTime(e2, t2, r2, o2, n2) {
  const a2 = GetSlot(e2, p), i2 = GetSlot(e2, u);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(e2, T), a2, i2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0), a2, i2);
}
function AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, f2, y2) {
  let S2 = t2, w2 = r2, g2 = o2, I2 = n2, D2 = a2, G2 = i2, v2 = s2, O2 = l2, C2 = d2, E2 = m2;
  if (!IsTemporalZonedDateTime(y2) || "year" === h2 || "month" === h2 || "week" === h2 || "day" === h2 || "nanosecond" === h2 && 1 === c2)
    return { years: S2, months: w2, weeks: g2, days: I2, hours: D2, minutes: G2, seconds: v2, milliseconds: O2, microseconds: C2, nanoseconds: E2 };
  let b2 = TotalDurationNanoseconds(0, D2, G2, v2, O2, C2, E2, 0);
  const M2 = ee(import_jsbi.default.toNumber(b2)), R2 = GetSlot(y2, p), Z2 = GetSlot(y2, u), P2 = AddZonedDateTime(GetSlot(y2, T), R2, Z2, S2, w2, g2, I2, 0, 0, 0, 0, 0, 0), F2 = AddZonedDateTime(new (GetIntrinsic("%Temporal.Instant%"))(P2), R2, Z2, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0), Y2 = import_jsbi.default.subtract(F2, P2);
  return import_jsbi.default.greaterThanOrEqual(import_jsbi.default.multiply(import_jsbi.default.subtract(b2, Y2), import_jsbi.default.BigInt(M2)), he) && ({ years: S2, months: w2, weeks: g2, days: I2 } = AddDuration(S2, w2, g2, I2, 0, 0, 0, 0, 0, 0, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0, y2), b2 = RoundInstant(import_jsbi.default.subtract(b2, Y2), c2, h2, f2), { hours: D2, minutes: G2, seconds: v2, milliseconds: O2, microseconds: C2, nanoseconds: E2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(b2), "hour")), { years: S2, months: w2, weeks: g2, days: I2, hours: D2, minutes: G2, seconds: v2, milliseconds: O2, microseconds: C2, nanoseconds: E2 };
}
function RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, T2, p2) {
  let f2 = t2, y2 = r2, S2 = o2, w2 = n2, g2 = a2, I2 = i2, D2 = s2, G2 = l2, v2 = d2, O2 = import_jsbi.default.BigInt(m2);
  const C2 = GetIntrinsic("%Temporal.Duration%");
  let E2, b2, M2, R2, Z2 = p2;
  if (Z2) {
    if (IsTemporalZonedDateTime(Z2))
      b2 = Z2, Z2 = ToTemporalDate(Z2);
    else if (!IsTemporalDate(Z2))
      throw new TypeError("starting point must be PlainDate or ZonedDateTime");
    E2 = GetSlot(Z2, u);
  }
  if ("year" === h2 || "month" === h2 || "week" === h2 || "day" === h2) {
    let t3, r3, o3;
    O2 = TotalDurationNanoseconds(0, g2, I2, D2, G2, v2, m2, 0), b2 && (t3 = MoveRelativeZonedDateTime(b2, f2, y2, S2, w2)), { days: r3, nanoseconds: O2, dayLengthNs: o3 } = NanosecondsToDays(O2, t3), M2 = import_jsbi.default.BigInt(o3), w2 += r3, g2 = I2 = D2 = G2 = v2 = 0;
  }
  switch (h2) {
    case "year": {
      if (!E2)
        throw new RangeError("A starting point is required for years rounding");
      const t3 = new C2(f2), r3 = E2.dateAdd, o3 = CalendarDateAdd(E2, Z2, t3, void 0, r3), n3 = CalendarDateAdd(E2, Z2, new C2(f2, y2, S2), void 0, r3);
      Z2 = o3, w2 += DaysUntil(o3, n3);
      const a3 = CalendarDateAdd(E2, Z2, { days: w2 }, void 0, r3), i3 = le(null);
      i3.largestUnit = "year";
      const s3 = CalendarDateUntil(E2, Z2, a3, i3).years;
      f2 += s3;
      const l3 = Z2;
      Z2 = CalendarDateAdd(E2, Z2, { years: s3 }, void 0, r3);
      w2 -= DaysUntil(l3, Z2);
      const d3 = new C2(w2 < 0 ? -1 : 1);
      let { days: m3 } = MoveRelativeDate(E2, Z2, d3);
      m3 = K(m3);
      const h3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(m3), M2);
      O2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(f2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), M2)), O2);
      const u2 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(c2))), T2);
      R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(h3), f2 = import_jsbi.default.toNumber(import_jsbi.default.divide(u2, h3)), O2 = he, y2 = S2 = w2 = 0;
      break;
    }
    case "month": {
      if (!E2)
        throw new RangeError("A starting point is required for months rounding");
      const t3 = new C2(f2, y2), r3 = E2.dateAdd, o3 = CalendarDateAdd(E2, Z2, t3, void 0, r3), n3 = CalendarDateAdd(E2, Z2, new C2(f2, y2, S2), void 0, r3);
      Z2 = o3, w2 += DaysUntil(o3, n3);
      const a3 = ee(w2), i3 = new C2(0, w2 < 0 ? -1 : 1);
      let s3;
      for ({ relativeTo: Z2, days: s3 } = MoveRelativeDate(E2, Z2, i3); K(w2) >= K(s3); )
        y2 += a3, w2 -= s3, { relativeTo: Z2, days: s3 } = MoveRelativeDate(E2, Z2, i3);
      s3 = K(s3);
      const l3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(s3), M2);
      O2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(y2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), M2)), O2);
      const d3 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(c2))), T2);
      R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(l3), y2 = import_jsbi.default.toNumber(import_jsbi.default.divide(d3, l3)), O2 = he, S2 = w2 = 0;
      break;
    }
    case "week": {
      if (!E2)
        throw new RangeError("A starting point is required for weeks rounding");
      const t3 = ee(w2), r3 = new C2(0, 0, w2 < 0 ? -1 : 1);
      let o3;
      for ({ relativeTo: Z2, days: o3 } = MoveRelativeDate(E2, Z2, r3); K(w2) >= K(o3); )
        S2 += t3, w2 -= o3, { relativeTo: Z2, days: o3 } = MoveRelativeDate(E2, Z2, r3);
      o3 = K(o3);
      const n3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(o3), M2);
      O2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(n3, import_jsbi.default.BigInt(S2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), M2)), O2);
      const a3 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(n3, import_jsbi.default.BigInt(c2))), T2);
      R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(n3), S2 = import_jsbi.default.toNumber(import_jsbi.default.divide(a3, n3)), O2 = he, w2 = 0;
      break;
    }
    case "day": {
      const t3 = M2;
      O2 = import_jsbi.default.add(import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(w2)), O2);
      const r3 = RoundNumberToIncrement(O2, import_jsbi.default.toNumber(import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(c2))), T2);
      R2 = import_jsbi.default.toNumber(O2) / import_jsbi.default.toNumber(t3), w2 = import_jsbi.default.toNumber(import_jsbi.default.divide(r3, t3)), O2 = he;
      break;
    }
    case "hour": {
      const t3 = 36e11;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(g2), import_jsbi.default.BigInt(36e11));
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(I2), import_jsbi.default.BigInt(6e10))), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ye)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
      const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
      g2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, I2 = D2 = G2 = v2 = 0;
      break;
    }
    case "minute": {
      const t3 = 6e10;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(I2), import_jsbi.default.BigInt(6e10));
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ye)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
      const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
      I2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, D2 = G2 = v2 = 0;
      break;
    }
    case "second": {
      const t3 = 1e9;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ye);
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
      const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
      D2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, G2 = v2 = 0;
      break;
    }
    case "millisecond": {
      const t3 = 1e6;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), fe);
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe)), r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
      const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
      G2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he, v2 = 0;
      break;
    }
    case "microsecond": {
      const t3 = 1e3;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), pe);
      r3 = import_jsbi.default.add(r3, O2), R2 = import_jsbi.default.toNumber(r3) / t3;
      const o3 = RoundNumberToIncrement(r3, t3 * c2, T2);
      v2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), O2 = he;
      break;
    }
    case "nanosecond":
      R2 = import_jsbi.default.toNumber(O2), O2 = RoundNumberToIncrement(O2, c2, T2);
  }
  return { years: f2, months: y2, weeks: S2, days: w2, hours: g2, minutes: I2, seconds: D2, milliseconds: G2, microseconds: v2, nanoseconds: import_jsbi.default.toNumber(O2), total: R2 };
}
function CompareISODate(e2, t2, r2, o2, n2, a2) {
  for (const [i2, s2] of [[e2, o2], [t2, n2], [r2, a2]])
    if (i2 !== s2)
      return ComparisonResult(i2 - s2);
  return 0;
}
function NonNegativeModulo(e2, t2) {
  let r2 = e2 % t2;
  return me(r2, -0) ? 0 : (r2 < 0 && (r2 += t2), r2);
}
function ToBigIntExternal(e2) {
  const t2 = ToBigInt(e2);
  return void 0 !== globalThis.BigInt ? globalThis.BigInt(t2.toString(10)) : t2;
}
function ToBigInt(t2) {
  if (t2 instanceof import_jsbi.default)
    return t2;
  let r2 = t2;
  if ("object" == typeof t2) {
    const e2 = t2[Symbol.toPrimitive];
    e2 && "function" == typeof e2 && (r2 = ce(e2, t2, ["number"]));
  }
  switch (typeof r2) {
    case "undefined":
    case "object":
    case "number":
    case "symbol":
    default:
      throw new TypeError(`cannot convert ${typeof t2} to bigint`);
    case "string":
      if (!r2.match(/^\s*(?:[+-]?\d+\s*)?$/))
        throw new SyntaxError("invalid BigInt syntax");
    case "bigint":
      try {
        return import_jsbi.default.BigInt(r2.toString());
      } catch (e2) {
        if (e2 instanceof Error && e2.message.startsWith("Invalid integer"))
          throw new SyntaxError(e2.message);
        throw e2;
      }
    case "boolean":
      return r2 ? ue : he;
  }
}
var $e = (() => {
  let t2 = import_jsbi.default.BigInt(Date.now() % 1e6);
  return () => {
    const r2 = import_jsbi.default.BigInt(Date.now()), o2 = import_jsbi.default.add(import_jsbi.default.multiply(r2, fe), t2);
    return t2 = import_jsbi.default.remainder(r2, fe), import_jsbi.default.greaterThan(o2, Ie) ? Ie : import_jsbi.default.lessThan(o2, ge) ? ge : o2;
  };
})();
function ComparisonResult(e2) {
  return e2 < 0 ? -1 : e2 > 0 ? 1 : e2;
}
function GetOptionsObject(e2) {
  if (void 0 === e2)
    return le(null);
  if (IsObject(e2) && null !== e2)
    return e2;
  throw new TypeError("Options parameter must be an object, not " + (null === e2 ? "null" : typeof e2));
}
function CreateOnePropObject(e2, t2) {
  const r2 = le(null);
  return r2[e2] = t2, r2;
}
function GetOption(e2, t2, r2, o2) {
  let n2 = e2[t2];
  if (void 0 !== n2) {
    if (n2 = ToString(n2), !r2.includes(n2))
      throw new RangeError(`${t2} must be one of ${r2.join(", ")}, not ${n2}`);
    return n2;
  }
  return o2;
}
function IsBuiltinCalendar(e2) {
  return z.call(Ce, e2);
}
var Be = new RegExp(`^${B.source}$`);
function bisect(t2, r2, o2, n2 = t2(r2), a2 = t2(o2)) {
  let i2 = import_jsbi.default.BigInt(r2), s2 = import_jsbi.default.BigInt(o2), l2 = n2, d2 = a2;
  for (; import_jsbi.default.greaterThan(import_jsbi.default.subtract(s2, i2), ue); ) {
    const r3 = import_jsbi.default.divide(import_jsbi.default.add(i2, s2), import_jsbi.default.BigInt(2)), o3 = t2(r3);
    if (o3 === l2)
      i2 = r3, l2 = o3;
    else {
      if (o3 !== d2)
        throw new Error(`invalid state in bisection ${l2} - ${o3} - ${d2}`);
      s2 = r3, d2 = o3;
    }
  }
  return s2;
}
var Ne = { hour: 36e11, minute: 6e10, second: 1e9, millisecond: 1e6, microsecond: 1e3, nanosecond: 1 };
var ke = Symbol("date");
var Ae = Symbol("ym");
var Ue = Symbol("md");
var Le = Symbol("time");
var xe = Symbol("datetime");
var He = Symbol("zoneddatetime");
var qe = Symbol("instant");
var We = Symbol("original");
var ze = Symbol("timezone");
var _e = Symbol("timezone-id-given");
var Je = Symbol("calendar-id");
var Ve = Symbol("locale");
var Xe = Symbol("options");
var descriptor = (e2) => ({ value: e2, enumerable: true, writable: false, configurable: true });
var Ke = globalThis.Intl.DateTimeFormat;
var Qe = Object.assign;
var et = Object.prototype.hasOwnProperty;
var tt = Reflect.apply;
function getPropLazy(e2, t2) {
  let r2 = e2[t2];
  return "function" == typeof r2 && (r2 = new Ke(e2[Ve], r2(e2[Xe])), e2[t2] = r2), r2;
}
function getResolvedTimeZoneLazy(e2) {
  let t2 = e2[ze];
  return "string" == typeof t2 && (t2 = ToTemporalTimeZone(t2), e2[ze] = t2), t2;
}
function DateTimeFormatImpl(e2, t2 = {}) {
  if (!(this instanceof DateTimeFormatImpl))
    return new DateTimeFormatImpl(e2, t2);
  const r2 = void 0 !== t2, o2 = r2 ? Qe({}, t2) : {}, n2 = new Ke(e2, o2), a2 = n2.resolvedOptions();
  if (r2) {
    const e3 = Qe({}, a2);
    for (const t3 in e3)
      tt(et, o2, [t3]) || delete e3[t3];
    this[Xe] = e3;
  } else
    this[Xe] = o2;
  this[_e] = o2.timeZone ? o2.timeZone : null, this[Ve] = a2.locale, this[We] = n2, this[ze] = a2.timeZone, this[Je] = a2.calendar, this[ke] = dateAmend, this[Ae] = yearMonthAmend, this[Ue] = monthDayAmend, this[Le] = timeAmend, this[xe] = datetimeAmend, this[He] = zonedDateTimeAmend, this[qe] = instantAmend;
}
Object.defineProperty(DateTimeFormatImpl, "name", { writable: true, value: "DateTimeFormat" }), DateTimeFormatImpl.supportedLocalesOf = function(e2, t2) {
  return Ke.supportedLocalesOf(e2, t2);
};
var rt = { resolvedOptions: descriptor(function resolvedOptions() {
  return this[We].resolvedOptions();
}), format: descriptor(function format2(e2, ...t2) {
  let { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this);
  if (r2 && o2)
    return o2 = adjustFormatterTimeZone(o2, n2), o2.format(r2.epochMilliseconds);
  return this[We].format(e2, ...t2);
}), formatRange: descriptor(function formatRange(e2, t2) {
  if (isTemporalObject(e2) || isTemporalObject(t2)) {
    if (!sameTemporalType(e2, t2))
      throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
    const { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this), { instant: a2, formatter: i2, timeZone: s2 } = extractOverrides(t2, this);
    if (n2 && s2 && n2 !== s2)
      throw new RangeError("cannot format range between different time zones");
    if (r2 && a2 && o2 && i2 && o2 === i2) {
      return adjustFormatterTimeZone(o2, n2).formatRange(r2.epochMilliseconds, a2.epochMilliseconds);
    }
  }
  return this[We].formatRange(e2, t2);
}) };
"formatToParts" in Ke.prototype && (rt.formatToParts = descriptor(function formatToParts(e2, ...t2) {
  let { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this);
  if (r2 && o2)
    return o2 = adjustFormatterTimeZone(o2, n2), o2.formatToParts(r2.epochMilliseconds);
  return this[We].formatToParts(e2, ...t2);
})), "formatRangeToParts" in Ke.prototype && (rt.formatRangeToParts = descriptor(function formatRangeToParts(e2, t2) {
  if (isTemporalObject(e2) || isTemporalObject(t2)) {
    if (!sameTemporalType(e2, t2))
      throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
    const { instant: r2, formatter: o2, timeZone: n2 } = extractOverrides(e2, this), { instant: a2, formatter: i2, timeZone: s2 } = extractOverrides(t2, this);
    if (n2 && s2 && n2 !== s2)
      throw new RangeError("cannot format range between different time zones");
    if (r2 && a2 && o2 && i2 && o2 === i2) {
      return adjustFormatterTimeZone(o2, n2).formatRangeToParts(r2.epochMilliseconds, a2.epochMilliseconds);
    }
  }
  return this[We].formatRangeToParts(e2, t2);
})), DateTimeFormatImpl.prototype = Object.create(Ke.prototype, rt), Object.defineProperty(DateTimeFormatImpl, "prototype", { writable: false, enumerable: false, configurable: false });
var ot = DateTimeFormatImpl;
function adjustFormatterTimeZone(e2, t2) {
  if (!t2)
    return e2;
  const r2 = e2.resolvedOptions();
  return r2.timeZone === t2 ? e2 : ((r2.dateStyle || r2.timeStyle) && (delete r2.weekday, delete r2.era, delete r2.year, delete r2.month, delete r2.day, delete r2.hour, delete r2.minute, delete r2.second, delete r2.timeZoneName, delete r2.hourCycle, delete r2.hour12, delete r2.dayPeriod), new Ke(r2.locale, { ...r2, timeZone: t2 }));
}
function amend(e2 = {}, t2 = {}) {
  const r2 = Qe({}, e2);
  for (const e3 of ["year", "month", "day", "hour", "minute", "second", "weekday", "dayPeriod", "timeZoneName", "dateStyle", "timeStyle"])
    r2[e3] = e3 in t2 ? t2[e3] : r2[e3], false !== r2[e3] && void 0 !== r2[e3] || delete r2[e3];
  return r2;
}
function timeAmend(e2) {
  let t2 = amend(e2, { year: false, month: false, day: false, weekday: false, timeZoneName: false, dateStyle: false });
  return hasTimeOptions(t2) || (t2 = Qe({}, t2, { hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function yearMonthAmend(e2) {
  let t2 = amend(e2, { day: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "year" in t2 || "month" in t2 || (t2 = Qe(t2, { year: "numeric", month: "numeric" })), t2;
}
function monthDayAmend(e2) {
  let t2 = amend(e2, { year: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "month" in t2 || "day" in t2 || (t2 = Qe({}, t2, { month: "numeric", day: "numeric" })), t2;
}
function dateAmend(e2) {
  let t2 = amend(e2, { hour: false, minute: false, second: false, dayPeriod: false, timeZoneName: false, timeStyle: false });
  return hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric" })), t2;
}
function datetimeAmend(e2) {
  let t2 = amend(e2, { timeZoneName: false });
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function zonedDateTimeAmend(e2) {
  let t2 = e2;
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), void 0 === t2.timeZoneName && (t2.timeZoneName = "short")), t2;
}
function instantAmend(e2) {
  let t2 = e2;
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = Qe({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function hasDateOptions(e2) {
  return "year" in e2 || "month" in e2 || "day" in e2 || "weekday" in e2 || "dateStyle" in e2;
}
function hasTimeOptions(e2) {
  return "hour" in e2 || "minute" in e2 || "second" in e2 || "timeStyle" in e2 || "dayPeriod" in e2;
}
function isTemporalObject(e2) {
  return IsTemporalDate(e2) || IsTemporalTime(e2) || IsTemporalDateTime(e2) || IsTemporalZonedDateTime(e2) || IsTemporalYearMonth(e2) || IsTemporalMonthDay(e2) || IsTemporalInstant(e2);
}
function sameTemporalType(e2, t2) {
  return !(!isTemporalObject(e2) || !isTemporalObject(t2)) && (!(IsTemporalTime(e2) && !IsTemporalTime(t2)) && (!(IsTemporalDate(e2) && !IsTemporalDate(t2)) && (!(IsTemporalDateTime(e2) && !IsTemporalDateTime(t2)) && (!(IsTemporalZonedDateTime(e2) && !IsTemporalZonedDateTime(t2)) && (!(IsTemporalYearMonth(e2) && !IsTemporalYearMonth(t2)) && (!(IsTemporalMonthDay(e2) && !IsTemporalMonthDay(t2)) && !(IsTemporalInstant(e2) && !IsTemporalInstant(t2))))))));
}
function extractOverrides(e2, t2) {
  const r2 = GetIntrinsic("%Temporal.PlainDateTime%");
  if (IsTemporalTime(e2)) {
    const o2 = new r2(1970, 1, 1, GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), t2[Je]);
    return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), o2, "compatible"), formatter: getPropLazy(t2, Le) };
  }
  if (IsTemporalYearMonth(e2)) {
    const o2 = GetSlot(e2, n), s2 = GetSlot(e2, a), l2 = GetSlot(e2, i), d2 = ToString(GetSlot(e2, u));
    if (d2 !== t2[Je])
      throw new RangeError(`cannot format PlainYearMonth with calendar ${d2} in locale with calendar ${t2[Je]}`);
    const m2 = new r2(o2, s2, l2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), m2, "compatible"), formatter: getPropLazy(t2, Ae) };
  }
  if (IsTemporalMonthDay(e2)) {
    const o2 = GetSlot(e2, n), s2 = GetSlot(e2, a), l2 = GetSlot(e2, i), d2 = ToString(GetSlot(e2, u));
    if (d2 !== t2[Je])
      throw new RangeError(`cannot format PlainMonthDay with calendar ${d2} in locale with calendar ${t2[Je]}`);
    const m2 = new r2(o2, s2, l2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), m2, "compatible"), formatter: getPropLazy(t2, Ue) };
  }
  if (IsTemporalDate(e2)) {
    const o2 = GetSlot(e2, n), s2 = GetSlot(e2, a), l2 = GetSlot(e2, i), d2 = ToString(GetSlot(e2, u));
    if ("iso8601" !== d2 && d2 !== t2[Je])
      throw new RangeError(`cannot format PlainDate with calendar ${d2} in locale with calendar ${t2[Je]}`);
    const m2 = new r2(o2, s2, l2, 12, 0, 0, 0, 0, 0, t2[Je]);
    return { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), m2, "compatible"), formatter: getPropLazy(t2, ke) };
  }
  if (IsTemporalDateTime(e2)) {
    const o2 = GetSlot(e2, n), T2 = GetSlot(e2, a), p2 = GetSlot(e2, i), f2 = GetSlot(e2, s), y2 = GetSlot(e2, l), S2 = GetSlot(e2, d), w2 = GetSlot(e2, m), g2 = GetSlot(e2, c), I2 = GetSlot(e2, h), D2 = ToString(GetSlot(e2, u));
    if ("iso8601" !== D2 && D2 !== t2[Je])
      throw new RangeError(`cannot format PlainDateTime with calendar ${D2} in locale with calendar ${t2[Je]}`);
    let G2 = e2;
    return "iso8601" === D2 && (G2 = new r2(o2, T2, p2, f2, y2, S2, w2, g2, I2, t2[Je])), { instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(t2), G2, "compatible"), formatter: getPropLazy(t2, xe) };
  }
  if (IsTemporalZonedDateTime(e2)) {
    const r3 = ToString(GetSlot(e2, u));
    if ("iso8601" !== r3 && r3 !== t2[Je])
      throw new RangeError(`cannot format ZonedDateTime with calendar ${r3} in locale with calendar ${t2[Je]}`);
    const o2 = ToString(GetSlot(e2, p));
    if (t2[_e] && t2[_e] !== o2)
      throw new RangeError(`timeZone option ${t2[_e]} doesn't match actual time zone ${o2}`);
    return { instant: GetSlot(e2, T), formatter: getPropLazy(t2, He), timeZone: o2 };
  }
  return IsTemporalInstant(e2) ? { instant: e2, formatter: getPropLazy(t2, qe) } : {};
}
var nt = Object.freeze({ __proto__: null, DateTimeFormat: ot });
var Instant = class {
  constructor(e2) {
    if (arguments.length < 1)
      throw new TypeError("missing argument: epochNanoseconds is required");
    const t2 = ToBigInt(e2);
    ValidateEpochNanoseconds(t2), CreateSlots(this), SetSlot(this, r, t2);
  }
  get epochSeconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, r);
    return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, ye));
  }
  get epochMilliseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = import_jsbi.default.BigInt(GetSlot(this, r));
    return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, fe));
  }
  get epochMicroseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = import_jsbi.default.BigInt(GetSlot(this, r));
    return ToBigIntExternal(import_jsbi.default.divide(t2, pe));
  }
  get epochNanoseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(import_jsbi.default.BigInt(GetSlot(this, r)));
  }
  add(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), o2 = GetTemporalUnit(t2, "smallestUnit", "time", je), n2 = ToTemporalRoundingMode(t2, "halfExpand"), a2 = ToTemporalRoundingIncrement(t2, { hour: 24, minute: 1440, second: 86400, millisecond: 864e5, microsecond: 864e8, nanosecond: 864e11 }[o2], true), i2 = RoundInstant(GetSlot(this, r), a2, o2, n2);
    return new Instant(i2);
  }
  equals(t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalInstant(t2), n2 = GetSlot(this, r), a2 = GetSlot(o2, r);
    return import_jsbi.default.equal(import_jsbi.default.BigInt(n2), import_jsbi.default.BigInt(a2));
  }
  toString(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2);
    let o2 = t2.timeZone;
    void 0 !== o2 && (o2 = ToTemporalTimeZone(o2));
    const { precision: n2, unit: a2, increment: i2 } = ToSecondsStringPrecision(t2), s2 = ToTemporalRoundingMode(t2, "trunc"), l2 = RoundInstant(GetSlot(this, r), i2, a2, s2);
    return TemporalInstantToString(new Instant(l2), o2, n2);
  }
  toJSON() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return TemporalInstantToString(this, void 0, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return new ot(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.Instant");
  }
  toZonedDateTime(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument in toZonedDateTime");
    const t2 = e2.calendar;
    if (void 0 === t2)
      throw new TypeError("missing calendar property in toZonedDateTime");
    const o2 = ToTemporalCalendar(t2), n2 = e2.timeZone;
    if (void 0 === n2)
      throw new TypeError("missing timeZone property in toZonedDateTime");
    const a2 = ToTemporalTimeZone(n2);
    return CreateTemporalZonedDateTime(GetSlot(this, r), a2, o2);
  }
  toZonedDateTimeISO(e2) {
    let t2 = e2;
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    if (IsObject(t2)) {
      const e3 = t2.timeZone;
      void 0 !== e3 && (t2 = e3);
    }
    const o2 = ToTemporalTimeZone(t2), n2 = GetISO8601Calendar();
    return CreateTemporalZonedDateTime(GetSlot(this, r), o2, n2);
  }
  static fromEpochSeconds(t2) {
    const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), ye);
    return ValidateEpochNanoseconds(o2), new Instant(o2);
  }
  static fromEpochMilliseconds(t2) {
    const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), fe);
    return ValidateEpochNanoseconds(o2), new Instant(o2);
  }
  static fromEpochMicroseconds(t2) {
    const r2 = ToBigInt(t2), o2 = import_jsbi.default.multiply(r2, pe);
    return ValidateEpochNanoseconds(o2), new Instant(o2);
  }
  static fromEpochNanoseconds(e2) {
    const t2 = ToBigInt(e2);
    return ValidateEpochNanoseconds(t2), new Instant(t2);
  }
  static from(e2) {
    return IsTemporalInstant(e2) ? new Instant(GetSlot(e2, r)) : ToTemporalInstant(e2);
  }
  static compare(t2, o2) {
    const n2 = ToTemporalInstant(t2), a2 = ToTemporalInstant(o2), i2 = GetSlot(n2, r), s2 = GetSlot(a2, r);
    return import_jsbi.default.lessThan(i2, s2) ? -1 : import_jsbi.default.greaterThan(i2, s2) ? 1 : 0;
  }
};
MakeIntrinsicClass(Instant, "Temporal.Instant");
var at = Array.prototype.includes;
var it = Array.prototype.push;
var st = globalThis.Intl.DateTimeFormat;
var lt = Array.prototype.sort;
var dt = Math.abs;
var mt = Math.floor;
var ct = Object.entries;
var ht = Object.keys;
var ut = {};
var Calendar = class {
  constructor(e2) {
    if (arguments.length < 1)
      throw new RangeError("missing argument: id is required");
    const t2 = ToString(e2);
    if (!IsBuiltinCalendar(t2))
      throw new RangeError(`invalid calendar identifier ${t2}`);
    CreateSlots(this), SetSlot(this, C, t2);
  }
  get id() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return ToString(this);
  }
  dateFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2);
    return ut[GetSlot(this, C)].dateFromFields(e2, r2, this);
  }
  yearMonthFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2);
    return ut[GetSlot(this, C)].yearMonthFromFields(e2, r2, this);
  }
  monthDayFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2);
    return ut[GetSlot(this, C)].monthDayFromFields(e2, r2, this);
  }
  fields(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = [], r2 = /* @__PURE__ */ new Set(["year", "month", "monthCode", "day", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"]);
    for (const o2 of e2) {
      if ("string" != typeof o2)
        throw new TypeError("invalid fields");
      if (!r2.has(o2))
        throw new RangeError(`invalid field name ${o2}`);
      r2.delete(o2), it.call(t2, o2);
    }
    return ut[GetSlot(this, C)].fields(t2);
  }
  mergeFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return ut[GetSlot(this, C)].mergeFields(e2, t2);
  }
  dateAdd(e2, t2, r2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDuration(t2), a2 = ToTemporalOverflow(GetOptionsObject(r2)), { days: i2 } = BalanceDuration(GetSlot(n2, w), GetSlot(n2, g), GetSlot(n2, I), GetSlot(n2, D), GetSlot(n2, G), GetSlot(n2, v), GetSlot(n2, O), "day");
    return ut[GetSlot(this, C)].dateAdd(o2, GetSlot(n2, f), GetSlot(n2, y), GetSlot(n2, S), i2, a2, this);
  }
  dateUntil(e2, t2, r2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDate(t2);
    let a2 = GetTemporalUnit(GetOptionsObject(r2), "largestUnit", "date", "auto");
    "auto" === a2 && (a2 = "day");
    const { years: i2, months: s2, weeks: l2, days: d2 } = ut[GetSlot(this, C)].dateUntil(o2, n2, a2);
    return new (GetIntrinsic("%Temporal.Duration%"))(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
  }
  year(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].year(t2);
  }
  month(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (IsTemporalMonthDay(t2))
      throw new TypeError("use monthCode on PlainMonthDay instead");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].month(t2);
  }
  monthCode(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].monthCode(t2);
  }
  day(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].day(t2);
  }
  era(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].era(t2);
  }
  eraYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].eraYear(t2);
  }
  dayOfWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return ut[GetSlot(this, C)].dayOfWeek(t2);
  }
  dayOfYear(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return ut[GetSlot(this, C)].dayOfYear(t2);
  }
  weekOfYear(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return ut[GetSlot(this, C)].weekOfYear(t2);
  }
  daysInWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return ut[GetSlot(this, C)].daysInWeek(t2);
  }
  daysInMonth(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].daysInMonth(t2);
  }
  daysInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].daysInYear(t2);
  }
  monthsInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].monthsInYear(t2);
  }
  inLeapYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), ut[GetSlot(this, C)].inLeapYear(t2);
  }
  toString() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, C);
  }
  toJSON() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return ToString(this);
  }
  static from(e2) {
    return ToTemporalCalendar(e2);
  }
};
function monthCodeNumberPart(e2) {
  if (!e2.startsWith("M"))
    throw new RangeError(`Invalid month code: ${e2}.  Month codes must start with M.`);
  const t2 = +e2.slice(1);
  if (isNaN(t2))
    throw new RangeError(`Invalid month code: ${e2}`);
  return t2;
}
function buildMonthCode(e2, t2 = false) {
  return `M${e2.toString().padStart(2, "0")}${t2 ? "L" : ""}`;
}
function resolveNonLunisolarMonth(e2, t2, r2 = 12) {
  let { month: o2, monthCode: n2 } = e2;
  if (void 0 === n2) {
    if (void 0 === o2)
      throw new TypeError("Either month or monthCode are required");
    "reject" === t2 && RejectToRange(o2, 1, r2), "constrain" === t2 && (o2 = ConstrainToRange(o2, 1, r2)), n2 = buildMonthCode(o2);
  } else {
    const e3 = monthCodeNumberPart(n2);
    if (void 0 !== o2 && o2 !== e3)
      throw new RangeError(`monthCode ${n2} and month ${o2} must match if both are present`);
    if (n2 !== buildMonthCode(e3))
      throw new RangeError(`Invalid month code: ${n2}`);
    if (o2 = e3, o2 < 1 || o2 > r2)
      throw new RangeError(`Invalid monthCode: ${n2}`);
  }
  return { ...e2, month: o2, monthCode: n2 };
}
MakeIntrinsicClass(Calendar, "Temporal.Calendar"), DefineIntrinsic("Temporal.Calendar.from", Calendar.from), ut.iso8601 = { dateFromFields(e2, t2, r2) {
  const o2 = ToTemporalOverflow(t2);
  let n2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["year", "day"]);
  n2 = resolveNonLunisolarMonth(n2);
  let { year: a2, month: i2, day: s2 } = n2;
  return { year: a2, month: i2, day: s2 } = RegulateISODate(a2, i2, s2, o2), CreateTemporalDate(a2, i2, s2, r2);
}, yearMonthFromFields(e2, t2, r2) {
  const o2 = ToTemporalOverflow(t2);
  let n2 = PrepareTemporalFields(e2, ["month", "monthCode", "year"], ["year"]);
  n2 = resolveNonLunisolarMonth(n2);
  let { year: a2, month: i2 } = n2;
  return { year: a2, month: i2 } = function RegulateISOYearMonth(e3, t3, r3) {
    let o3 = e3, n3 = t3;
    switch (r3) {
      case "reject":
        RejectISODate(o3, n3, 1);
        break;
      case "constrain":
        ({ year: o3, month: n3 } = ConstrainISODate(o3, n3));
    }
    return { year: o3, month: n3 };
  }(a2, i2, o2), CreateTemporalYearMonth(a2, i2, r2, 1);
}, monthDayFromFields(e2, t2, r2) {
  const o2 = ToTemporalOverflow(t2);
  let n2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["day"]);
  if (void 0 !== n2.month && void 0 === n2.year && void 0 === n2.monthCode)
    throw new TypeError("either year or monthCode required with month");
  const a2 = void 0 === n2.monthCode;
  n2 = resolveNonLunisolarMonth(n2);
  let { month: i2, day: s2, year: l2 } = n2;
  return { month: i2, day: s2 } = RegulateISODate(a2 ? l2 : 1972, i2, s2, o2), CreateTemporalMonthDay(i2, s2, r2, 1972);
}, fields: (e2) => e2, mergeFields(e2, t2) {
  const r2 = {};
  for (const t3 of ht(e2))
    "month" !== t3 && "monthCode" !== t3 && (r2[t3] = e2[t3]);
  const o2 = ht(t2);
  for (const e3 of o2)
    r2[e3] = t2[e3];
  if (!at.call(o2, "month") && !at.call(o2, "monthCode")) {
    const { month: t3, monthCode: o3 } = e2;
    void 0 !== t3 && (r2.month = t3), void 0 !== o3 && (r2.monthCode = o3);
  }
  return r2;
}, dateAdd(e2, t2, r2, o2, s2, l2, d2) {
  let m2 = GetSlot(e2, n), c2 = GetSlot(e2, a), h2 = GetSlot(e2, i);
  return { year: m2, month: c2, day: h2 } = AddISODate(m2, c2, h2, t2, r2, o2, s2, l2), CreateTemporalDate(m2, c2, h2, d2);
}, dateUntil: (e2, t2, r2) => DifferenceISODate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(t2, n), GetSlot(t2, a), GetSlot(t2, i), r2), year: (e2) => GetSlot(e2, n), era() {
}, eraYear() {
}, month: (e2) => GetSlot(e2, a), monthCode: (e2) => buildMonthCode(GetSlot(e2, a)), day: (e2) => GetSlot(e2, i), dayOfWeek: (e2) => DayOfWeek(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i)), dayOfYear: (e2) => DayOfYear(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i)), weekOfYear: (e2) => function WeekOfYear(e3, t2, r2) {
  const o2 = DayOfYear(e3, t2, r2), n2 = DayOfWeek(e3, t2, r2) || 7, a2 = DayOfWeek(e3, 1, 1), i2 = Q((o2 - n2 + 10) / 7);
  return i2 < 1 ? 5 === a2 || 6 === a2 && LeapYear(e3 - 1) ? 53 : 52 : 53 === i2 && (LeapYear(e3) ? 366 : 365) - o2 < 4 - n2 ? 1 : i2;
}(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i)), daysInWeek: () => 7, daysInMonth: (e2) => ISODaysInMonth(GetSlot(e2, n), GetSlot(e2, a)), daysInYear(e2) {
  let t2 = e2;
  return HasSlot(t2, n) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, n)) ? 366 : 365;
}, monthsInYear: () => 12, inLeapYear(e2) {
  let t2 = e2;
  return HasSlot(t2, n) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, n));
} };
var OneObjectCache = class {
  constructor(e2) {
    if (this.map = /* @__PURE__ */ new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e2) {
      let t2 = 0;
      for (const r2 of e2.map.entries()) {
        if (++t2 > OneObjectCache.MAX_CACHE_ENTRIES)
          break;
        this.map.set(...r2);
      }
    }
  }
  get(e2) {
    const t2 = this.map.get(e2);
    return t2 && (this.hits++, this.report()), this.calls++, t2;
  }
  set(e2, t2) {
    this.map.set(e2, t2), this.misses++, this.report();
  }
  report() {
  }
  setObject(e2) {
    if (OneObjectCache.objectMap.get(e2))
      throw new RangeError("object already cached");
    OneObjectCache.objectMap.set(e2, this), this.report();
  }
  static getCacheForObject(e2) {
    let t2 = OneObjectCache.objectMap.get(e2);
    return t2 || (t2 = new OneObjectCache(), OneObjectCache.objectMap.set(e2, t2)), t2;
  }
};
function toUtcIsoDateString({ isoYear: e2, isoMonth: t2, isoDay: r2 }) {
  return `${ISOYearString(e2)}-${ISODateTimePartString(t2)}-${ISODateTimePartString(r2)}T00:00Z`;
}
function simpleDateDiff(e2, t2) {
  return { years: e2.year - t2.year, months: e2.month - t2.month, days: e2.day - t2.day };
}
OneObjectCache.objectMap = /* @__PURE__ */ new WeakMap(), OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
var HelperBase = class {
  constructor() {
    this.eraLength = "short", this.hasEra = true;
  }
  getFormatter() {
    return void 0 === this.formatter && (this.formatter = new st(`en-US-u-ca-${this.id}`, { day: "numeric", month: "numeric", year: "numeric", era: this.eraLength, timeZone: "UTC" })), this.formatter;
  }
  isoToCalendarDate(e2, t2) {
    const { year: r2, month: o2, day: n2 } = e2, a2 = JSON.stringify({ func: "isoToCalendarDate", isoYear: r2, isoMonth: o2, isoDay: n2, id: this.id }), i2 = t2.get(a2);
    if (i2)
      return i2;
    const s2 = this.getFormatter();
    let l2, d2;
    try {
      d2 = toUtcIsoDateString({ isoYear: r2, isoMonth: o2, isoDay: n2 }), l2 = s2.formatToParts(new Date(d2));
    } catch (e3) {
      throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear: r2, isoMonth: o2, isoDay: n2 })}`);
    }
    const m2 = {};
    for (let { type: e3, value: t3 } of l2) {
      if ("year" === e3 && (m2.eraYear = +t3), "relatedYear" === e3 && (m2.eraYear = +t3), "month" === e3) {
        const e4 = /^([0-9]*)(.*?)$/.exec(t3);
        if (!e4 || 3 != e4.length || !e4[1] && !e4[2])
          throw new RangeError(`Unexpected month: ${t3}`);
        if (m2.month = e4[1] ? +e4[1] : 1, m2.month < 1)
          throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
        if (m2.month > 13)
          throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
        e4[2] && (m2.monthExtra = e4[2]);
      }
      "day" === e3 && (m2.day = +t3), this.hasEra && "era" === e3 && null != t3 && "" !== t3 && (t3 = t3.split(" (")[0], m2.era = t3.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase());
    }
    if (void 0 === m2.eraYear)
      throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
    if (this.reviseIntlEra) {
      const { era: t3, eraYear: r3 } = this.reviseIntlEra(m2, e2);
      m2.era = t3, m2.eraYear = r3;
    }
    this.checkIcuBugs && this.checkIcuBugs(e2);
    const c2 = this.adjustCalendarDate(m2, t2, "constrain", true);
    if (void 0 === c2.year)
      throw new RangeError(`Missing year converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.month)
      throw new RangeError(`Missing month converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.day)
      throw new RangeError(`Missing day converting ${JSON.stringify(e2)}`);
    return t2.set(a2, c2), ["constrain", "reject"].forEach((r3) => {
      const o3 = JSON.stringify({ func: "calendarToIsoDate", year: c2.year, month: c2.month, day: c2.day, overflow: r3, id: this.id });
      t2.set(o3, e2);
    }), c2;
  }
  validateCalendarDate(e2) {
    const { era: t2, month: r2, year: o2, day: n2, eraYear: a2, monthCode: i2, monthExtra: s2 } = e2;
    if (void 0 !== s2)
      throw new RangeError("Unexpected `monthExtra` value");
    if (void 0 === o2 && void 0 === a2)
      throw new TypeError("year or eraYear is required");
    if (void 0 === r2 && void 0 === i2)
      throw new TypeError("month or monthCode is required");
    if (void 0 === n2)
      throw new RangeError("Missing day");
    if (void 0 !== i2) {
      if ("string" != typeof i2)
        throw new RangeError("monthCode must be a string, not " + typeof i2);
      if (!/^M([01]?\d)(L?)$/.test(i2))
        throw new RangeError(`Invalid monthCode: ${i2}`);
    }
    if (this.constantEra) {
      if (void 0 !== t2 && t2 !== this.constantEra)
        throw new RangeError(`era must be ${this.constantEra}, not ${t2}`);
      if (void 0 !== a2 && void 0 !== o2 && a2 !== o2)
        throw new RangeError(`eraYear ${a2} does not match year ${o2}`);
    }
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    if ("lunisolar" === this.calendarType)
      throw new RangeError("Override required for lunisolar calendars");
    let n2 = e2;
    if (this.validateCalendarDate(n2), this.constantEra) {
      const { year: e3, eraYear: t3 } = n2;
      n2 = { ...n2, era: this.constantEra, year: void 0 !== e3 ? e3 : t3, eraYear: void 0 !== t3 ? t3 : e3 };
    }
    const a2 = this.monthsInYear(n2, t2);
    let { month: i2, monthCode: s2 } = n2;
    return { month: i2, monthCode: s2 } = resolveNonLunisolarMonth(n2, r2, a2), { ...n2, month: i2, monthCode: s2 };
  }
  regulateMonthDayNaive(e2, t2, r2) {
    const o2 = this.monthsInYear(e2, r2);
    let { month: n2, day: a2 } = e2;
    return "reject" === t2 ? (RejectToRange(n2, 1, o2), RejectToRange(a2, 1, this.maximumMonthLength(e2))) : (n2 = ConstrainToRange(n2, 1, o2), a2 = ConstrainToRange(a2, 1, this.maximumMonthLength({ ...e2, month: n2 }))), { ...e2, month: n2, day: a2 };
  }
  calendarToIsoDate(e2, t2 = "constrain", r2) {
    const o2 = e2;
    let n2 = this.adjustCalendarDate(e2, r2, t2, false);
    n2 = this.regulateMonthDayNaive(n2, t2, r2);
    const { year: a2, month: i2, day: s2 } = n2, l2 = JSON.stringify({ func: "calendarToIsoDate", year: a2, month: i2, day: s2, overflow: t2, id: this.id });
    let d2, m2 = r2.get(l2);
    if (m2)
      return m2;
    if (void 0 !== o2.year && void 0 !== o2.month && void 0 !== o2.day && (o2.year !== n2.year || o2.month !== n2.month || o2.day !== n2.day) && (d2 = JSON.stringify({ func: "calendarToIsoDate", year: o2.year, month: o2.month, day: o2.day, overflow: t2, id: this.id }), m2 = r2.get(d2), m2))
      return m2;
    let c2 = this.estimateIsoDate({ year: a2, month: i2, day: s2 });
    const calculateSameMonthResult = (e3) => {
      let o3 = this.addDaysIso(c2, e3);
      if (n2.day > this.minimumMonthLength(n2)) {
        let e4 = this.isoToCalendarDate(o3, r2);
        for (; e4.month !== i2 || e4.year !== a2; ) {
          if ("reject" === t2)
            throw new RangeError(`day ${s2} does not exist in month ${i2} of year ${a2}`);
          o3 = this.addDaysIso(o3, -1), e4 = this.isoToCalendarDate(o3, r2);
        }
      }
      return o3;
    };
    let h2 = 0, u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2);
    if (0 !== T2.years || 0 !== T2.months || 0 !== T2.days) {
      const e3 = 365 * T2.years + 30 * T2.months + T2.days;
      c2 = this.addDaysIso(c2, e3), u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months ? c2 = calculateSameMonthResult(T2.days) : h2 = this.compareCalendarDates(n2, u2);
    }
    let p2 = 8, f2 = false;
    for (; h2; ) {
      c2 = this.addDaysIso(c2, h2 * p2);
      const e3 = u2;
      u2 = this.isoToCalendarDate(c2, r2);
      const a3 = h2;
      if (h2 = this.compareCalendarDates(n2, u2), h2) {
        if (T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months)
          c2 = calculateSameMonthResult(T2.days), h2 = 0, f2 = n2.day > this.minimumMonthLength(n2);
        else if (a3 && h2 !== a3)
          if (p2 > 1)
            p2 /= 2;
          else {
            if ("reject" === t2)
              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...o2 })}`);
            this.compareCalendarDates(u2, e3) > 0 && (c2 = this.addDaysIso(c2, -1)), f2 = true, h2 = 0;
          }
      }
    }
    if (r2.set(l2, c2), d2 && r2.set(d2, c2), void 0 === n2.year || void 0 === n2.month || void 0 === n2.day || void 0 === n2.monthCode || this.hasEra && (void 0 === n2.era || void 0 === n2.eraYear))
      throw new RangeError("Unexpected missing property");
    if (!f2) {
      const e3 = JSON.stringify({ func: "isoToCalendarDate", isoYear: c2.year, isoMonth: c2.month, isoDay: c2.day, id: this.id });
      r2.set(e3, n2);
    }
    return c2;
  }
  temporalToCalendarDate(e2, t2) {
    const r2 = { year: GetSlot(e2, n), month: GetSlot(e2, a), day: GetSlot(e2, i) };
    return this.isoToCalendarDate(r2, t2);
  }
  compareCalendarDates(e2, t2) {
    const r2 = PrepareTemporalFields(e2, ["day", "month", "year"], ["day", "month", "year"]), o2 = PrepareTemporalFields(t2, ["day", "month", "year"], ["day", "month", "year"]);
    return r2.year !== o2.year ? ComparisonResult(r2.year - o2.year) : r2.month !== o2.month ? ComparisonResult(r2.month - o2.month) : r2.day !== o2.day ? ComparisonResult(r2.day - o2.day) : 0;
  }
  regulateDate(e2, t2 = "constrain", r2) {
    const o2 = this.calendarToIsoDate(e2, t2, r2);
    return this.isoToCalendarDate(o2, r2);
  }
  addDaysIso(e2, t2) {
    return AddISODate(e2.year, e2.month, e2.day, 0, 0, 0, t2, "constrain");
  }
  addDaysCalendar(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.addDaysIso(o2, t2);
    return this.isoToCalendarDate(n2, r2);
  }
  addMonthsCalendar(e2, t2, r2, o2) {
    let n2 = e2;
    const { day: a2 } = n2;
    for (let e3 = 0, r3 = dt(t2); e3 < r3; e3++) {
      const { month: e4 } = n2, r4 = n2, i2 = t2 < 0 ? -Math.max(a2, this.daysInPreviousMonth(n2, o2)) : this.daysInMonth(n2, o2), s2 = this.calendarToIsoDate(n2, "constrain", o2);
      let l2 = this.addDaysIso(s2, i2);
      if (n2 = this.isoToCalendarDate(l2, o2), t2 > 0) {
        const t3 = this.monthsInYear(r4, o2);
        for (; n2.month - 1 != e4 % t3; )
          l2 = this.addDaysIso(l2, -1), n2 = this.isoToCalendarDate(l2, o2);
      }
      n2.day !== a2 && (n2 = this.regulateDate({ ...n2, day: a2 }, "constrain", o2));
    }
    if ("reject" === r2 && n2.day !== a2)
      throw new RangeError(`Day ${a2} does not exist in resulting calendar month`);
    return n2;
  }
  addCalendar(e2, { years: t2 = 0, months: r2 = 0, weeks: o2 = 0, days: n2 = 0 }, a2, i2) {
    const { year: s2, day: l2, monthCode: d2 } = e2, m2 = this.adjustCalendarDate({ year: s2 + t2, monthCode: d2, day: l2 }, i2), c2 = this.addMonthsCalendar(m2, r2, a2, i2), h2 = n2 + 7 * o2;
    return this.addDaysCalendar(c2, h2, i2);
  }
  untilCalendar(e2, t2, r2, o2) {
    let n2 = 0, a2 = 0, i2 = 0, s2 = 0;
    switch (r2) {
      case "day":
        n2 = this.calendarDaysUntil(e2, t2, o2);
        break;
      case "week": {
        const r3 = this.calendarDaysUntil(e2, t2, o2);
        n2 = r3 % 7, a2 = (r3 - n2) / 7;
        break;
      }
      case "month":
      case "year": {
        const a3 = t2.year - e2.year, l2 = t2.month - e2.month, d2 = t2.day - e2.day, m2 = this.compareCalendarDates(t2, e2);
        if (!m2)
          return { years: 0, months: 0, weeks: 0, days: 0 };
        if ("year" === r2 && a3) {
          s2 = l2 * m2 < 0 || 0 === l2 && d2 * m2 < 0 ? a3 - m2 : a3;
        }
        let c2, h2 = s2 ? this.addCalendar(e2, { years: s2 }, "constrain", o2) : e2;
        do {
          i2 += m2, c2 = h2, h2 = this.addMonthsCalendar(c2, m2, "constrain", o2), h2.day !== e2.day && (h2 = this.regulateDate({ ...h2, day: e2.day }, "constrain", o2));
        } while (this.compareCalendarDates(t2, h2) * m2 >= 0);
        i2 -= m2;
        n2 = this.calendarDaysUntil(c2, t2, o2);
        break;
      }
    }
    return { years: s2, months: i2, weeks: a2, days: n2 };
  }
  daysInMonth(e2, t2) {
    const { day: r2 } = e2, o2 = this.maximumMonthLength(e2), n2 = this.minimumMonthLength(e2);
    if (n2 === o2)
      return n2;
    const a2 = r2 <= o2 - n2 ? o2 : n2, i2 = this.calendarToIsoDate(e2, "constrain", t2), s2 = this.addDaysIso(i2, a2), l2 = this.isoToCalendarDate(s2, t2), d2 = this.addDaysIso(s2, -l2.day);
    return this.isoToCalendarDate(d2, t2).day;
  }
  daysInPreviousMonth(e2, t2) {
    const { day: r2, month: o2, year: n2 } = e2;
    let a2 = { year: o2 > 1 ? n2 : n2 - 1, month: o2, day: 1 };
    const i2 = o2 > 1 ? o2 - 1 : this.monthsInYear(a2, t2);
    a2 = { ...a2, month: i2 };
    const s2 = this.minimumMonthLength(a2), l2 = this.maximumMonthLength(a2);
    if (s2 === l2)
      return l2;
    const d2 = this.calendarToIsoDate(e2, "constrain", t2), m2 = this.addDaysIso(d2, -r2);
    return this.isoToCalendarDate(m2, t2).day;
  }
  startOfCalendarYear(e2) {
    return { year: e2.year, month: 1, monthCode: "M01", day: 1 };
  }
  startOfCalendarMonth(e2) {
    return { year: e2.year, month: e2.month, day: 1 };
  }
  calendarDaysUntil(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.calendarToIsoDate(t2, "constrain", r2);
    return this.isoDaysUntil(o2, n2);
  }
  isoDaysUntil(e2, t2) {
    return DifferenceISODate(e2.year, e2.month, e2.day, t2.year, t2.month, t2.day, "day").days;
  }
  monthDayFromFields(e2, t2, r2) {
    let o2, n2, a2, i2, s2, { year: l2, month: d2, monthCode: m2, day: c2, era: h2, eraYear: u2 } = e2;
    if (void 0 === m2) {
      if (void 0 === l2 && (void 0 === h2 || void 0 === u2))
        throw new TypeError("`monthCode`, `year`, or `era` and `eraYear` is required");
      ({ monthCode: m2, year: l2 } = this.adjustCalendarDate({ year: l2, month: d2, monthCode: m2, day: c2, era: h2, eraYear: u2 }, r2, t2));
    }
    const { year: T2 } = this.isoToCalendarDate({ year: 1972, month: 1, day: 1 }, r2);
    for (let e3 = 0; e3 < 100; e3++) {
      const l3 = this.adjustCalendarDate({ day: c2, monthCode: m2, year: T2 - e3 }, r2), d3 = this.calendarToIsoDate(l3, "constrain", r2), h3 = this.isoToCalendarDate(d3, r2);
      if ({ year: o2, month: n2, day: a2 } = d3, h3.monthCode === m2 && h3.day === c2)
        return { month: n2, day: a2, year: o2 };
      "constrain" === t2 && (void 0 === i2 || h3.monthCode === i2.monthCode && h3.day > i2.day) && (i2 = h3, s2 = d3);
    }
    if ("constrain" === t2 && void 0 !== s2)
      return s2;
    throw new RangeError(`No recent ${this.id} year with monthCode ${m2} and day ${c2}`);
  }
};
var HebrewHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "hebrew", this.calendarType = "lunisolar", this.months = { Tishri: { leap: 1, regular: 1, monthCode: "M01", days: 30 }, Heshvan: { leap: 2, regular: 2, monthCode: "M02", days: { min: 29, max: 30 } }, Kislev: { leap: 3, regular: 3, monthCode: "M03", days: { min: 29, max: 30 } }, Tevet: { leap: 4, regular: 4, monthCode: "M04", days: 29 }, Shevat: { leap: 5, regular: 5, monthCode: "M05", days: 30 }, Adar: { leap: void 0, regular: 6, monthCode: "M06", days: 29 }, "Adar I": { leap: 6, regular: void 0, monthCode: "M05L", days: 30 }, "Adar II": { leap: 7, regular: void 0, monthCode: "M06", days: 29 }, Nisan: { leap: 8, regular: 7, monthCode: "M07", days: 30 }, Iyar: { leap: 9, regular: 8, monthCode: "M08", days: 29 }, Sivan: { leap: 10, regular: 9, monthCode: "M09", days: 30 }, Tamuz: { leap: 11, regular: 10, monthCode: "M10", days: 29 }, Av: { leap: 12, regular: 11, monthCode: "M11", days: 30 }, Elul: { leap: 13, regular: 12, monthCode: "M12", days: 29 } }, this.hasEra = false;
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (7 * t2 + 1) % 19 < 7;
  }
  monthsInYear(e2) {
    return this.inLeapYear(e2) ? 13 : 12;
  }
  minimumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "min");
  }
  maximumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "max");
  }
  minMaxMonthLength(e2, t2) {
    const { month: r2, year: o2 } = e2, n2 = this.getMonthCode(o2, r2), a2 = ct(this.months).find((e3) => e3[1].monthCode === n2);
    if (void 0 === a2)
      throw new RangeError(`unmatched Hebrew month: ${r2}`);
    const i2 = a2[1].days;
    return "number" == typeof i2 ? i2 : i2[t2];
  }
  estimateIsoDate(e2) {
    const { year: t2 } = e2;
    return { year: t2 - 3760, month: 1, day: 1 };
  }
  getMonthCode(e2, t2) {
    return this.inLeapYear({ year: e2 }) ? 6 === t2 ? buildMonthCode(5, true) : buildMonthCode(t2 < 6 ? t2 : t2 - 1) : buildMonthCode(t2);
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, eraYear: a2, month: i2, monthCode: s2, day: l2, monthExtra: d2 } = e2;
    if (void 0 === n2 && void 0 !== a2 && (n2 = a2), void 0 === a2 && void 0 !== n2 && (a2 = n2), o2) {
      if (d2) {
        const e3 = this.months[d2];
        if (!e3)
          throw new RangeError(`Unrecognized month from formatToParts: ${d2}`);
        i2 = this.inLeapYear({ year: n2 }) ? e3.leap : e3.regular;
      }
      s2 = this.getMonthCode(n2, i2);
      return { year: n2, month: i2, day: l2, era: void 0, eraYear: a2, monthCode: s2 };
    }
    if (this.validateCalendarDate(e2), void 0 === i2)
      if (s2.endsWith("L")) {
        if ("M05L" !== s2)
          throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${s2}`);
        if (i2 = 6, !this.inLeapYear({ year: n2 })) {
          if ("reject" === r2)
            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${n2} which is not a leap year`);
          i2 = 5, l2 = 30, s2 = "M05";
        }
      } else {
        i2 = monthCodeNumberPart(s2), this.inLeapYear({ year: n2 }) && i2 >= 6 && i2++;
        const e3 = this.monthsInYear({ year: n2 });
        if (i2 < 1 || i2 > e3)
          throw new RangeError(`Invalid monthCode: ${s2}`);
      }
    else if ("reject" === r2 ? (RejectToRange(i2, 1, this.monthsInYear({ year: n2 })), RejectToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))) : (i2 = ConstrainToRange(i2, 1, this.monthsInYear({ year: n2 })), l2 = ConstrainToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))), void 0 === s2)
      s2 = this.getMonthCode(n2, i2);
    else {
      if (this.getMonthCode(n2, i2) !== s2)
        throw new RangeError(`monthCode ${s2} doesn't correspond to month ${i2} in Hebrew year ${n2}`);
    }
    return { ...e2, day: l2, month: i2, monthCode: s2, year: n2, eraYear: a2 };
  }
};
var IslamicBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunar", this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, this.DAYS_PER_ISO_YEAR = 365.2425, this.constantEra = "ah";
  }
  inLeapYear(e2, t2) {
    return 30 === this.daysInMonth({ year: e2.year, month: 12, day: 1 }, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return { year: mt(t2 * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };
  }
};
var IslamicHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic";
  }
};
var IslamicUmalquraHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-umalqura";
  }
};
var IslamicTblaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-tbla";
  }
};
var IslamicCivilHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-civil";
  }
};
var IslamicRgsaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-rgsa";
  }
};
var IslamicCcHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamicc";
  }
};
var PersianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "persian", this.calendarType = "solar", this.constantEra = "ap";
  }
  inLeapYear(e2, t2) {
    return IslamicHelper.prototype.inLeapYear.call(this, e2, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 29 : t2 <= 6 ? 31 : 30;
  }
  maximumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 30 : t2 <= 6 ? 31 : 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return { year: t2 + 621, month: 1, day: 1 };
  }
};
var IndianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "indian", this.calendarType = "solar", this.constantEra = "saka", this.months = { 1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } }, 2: { length: 31, month: 4, day: 21 }, 3: { length: 31, month: 5, day: 22 }, 4: { length: 31, month: 6, day: 22 }, 5: { length: 31, month: 7, day: 23 }, 6: { length: 31, month: 8, day: 23 }, 7: { length: 30, month: 9, day: 23 }, 8: { length: 30, month: 10, day: 23 }, 9: { length: 30, month: 11, day: 22 }, 10: { length: 30, month: 12, day: 22 }, 11: { length: 30, month: 1, nextYear: true, day: 21 }, 12: { length: 30, month: 2, nextYear: true, day: 20 } }, this.vulnerableToBceBug = "10/11/-79 Saka" !== new Date("0000-01-01T00:00Z").toLocaleDateString("en-US-u-ca-indian", { timeZone: "UTC" });
  }
  inLeapYear(e2) {
    return isGregorianLeapYear(e2.year + 78);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  maximumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  getMonthInfo(e2) {
    const { month: t2 } = e2;
    let r2 = this.months[t2];
    if (void 0 === r2)
      throw new RangeError(`Invalid month: ${t2}`);
    return this.inLeapYear(e2) && r2.leap && (r2 = r2.leap), r2;
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), r2 = this.getMonthInfo(t2);
    return AddISODate(t2.year + 78 + (r2.nextYear ? 1 : 0), r2.month, r2.day, 0, 0, 0, t2.day - 1, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.vulnerableToBceBug && e2.year < 1)
      throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
  }
};
function isGregorianLeapYear(e2) {
  return e2 % 4 == 0 && (e2 % 100 != 0 || e2 % 400 == 0);
}
var GregorianBaseHelper = class extends HelperBase {
  constructor(e2, t2) {
    super(), this.calendarType = "solar", this.v8IsVulnerableToJulianBug = new Date("+001001-01-01T00:00Z").toLocaleDateString("en-US-u-ca-japanese", { timeZone: "UTC" }).startsWith("12"), this.calendarIsVulnerableToJulianBug = false, this.id = e2;
    const { eras: r2, anchorEra: o2 } = function adjustEras(e3) {
      let t3, r3 = e3;
      if (0 === r3.length)
        throw new RangeError("Invalid era data: eras are required");
      if (1 === r3.length && r3[0].reverseOf)
        throw new RangeError("Invalid era data: anchor era cannot count years backwards");
      if (1 === r3.length && !r3[0].name)
        throw new RangeError("Invalid era data: at least one named era is required");
      if (r3.filter((e4) => null != e4.reverseOf).length > 1)
        throw new RangeError("Invalid era data: only one era can count years backwards");
      r3.forEach((e4) => {
        if (e4.isAnchor || !e4.anchorEpoch && !e4.reverseOf) {
          if (t3)
            throw new RangeError("Invalid era data: cannot have multiple anchor eras");
          t3 = e4, e4.anchorEpoch = { year: e4.hasYearZero ? 0 : 1 };
        } else if (!e4.name)
          throw new RangeError("If era name is blank, it must be the anchor era");
      }), r3 = r3.filter((e4) => e4.name), r3.forEach((e4) => {
        const { reverseOf: t4 } = e4;
        if (t4) {
          const o4 = r3.find((e5) => e5.name === t4);
          if (void 0 === o4)
            throw new RangeError(`Invalid era data: unmatched reverseOf era: ${t4}`);
          e4.reverseOf = o4, e4.anchorEpoch = o4.anchorEpoch, e4.isoEpoch = o4.isoEpoch;
        }
        void 0 === e4.anchorEpoch.month && (e4.anchorEpoch.month = 1), void 0 === e4.anchorEpoch.day && (e4.anchorEpoch.day = 1);
      }), lt.call(r3, (e4, t4) => {
        if (e4.reverseOf)
          return 1;
        if (t4.reverseOf)
          return -1;
        if (!e4.isoEpoch || !t4.isoEpoch)
          throw new RangeError("Invalid era data: missing ISO epoch");
        return t4.isoEpoch.year - e4.isoEpoch.year;
      });
      const o3 = r3[r3.length - 1].reverseOf;
      if (o3 && o3 !== r3[r3.length - 2])
        throw new RangeError("Invalid era data: invalid reverse-sign era");
      return r3.forEach((e4, t4) => {
        e4.genericName = "era" + (r3.length - 1 - t4);
      }), { eras: r3, anchorEra: t3 || r3[0] };
    }(t2);
    this.anchorEra = o2, this.eras = r2;
  }
  inLeapYear(e2) {
    const { year: t2 } = this.estimateIsoDate({ month: 1, day: 1, year: e2.year });
    return isGregorianLeapYear(t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 2 === t2 ? this.inLeapYear(e2) ? 29 : 28 : [4, 6, 9, 11].indexOf(t2) >= 0 ? 30 : 31;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
  completeEraYear(e2) {
    const checkField = (t3, r3) => {
      const o3 = e2[t3];
      if (null != o3 && o3 != r3)
        throw new RangeError(`Input ${t3} ${o3} doesn't match calculated value ${r3}`);
    }, eraFromYear = (t3) => {
      let r3;
      const o3 = { ...e2, year: t3 }, n2 = this.eras.find((e3, n3) => {
        if (n3 === this.eras.length - 1) {
          if (e3.reverseOf) {
            if (t3 > 0)
              throw new RangeError(`Signed year ${t3} is invalid for era ${e3.name}`);
            return r3 = e3.anchorEpoch.year - t3, true;
          }
          return r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true;
        }
        return this.compareCalendarDates(o3, e3.anchorEpoch) >= 0 && (r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true);
      });
      if (!n2)
        throw new RangeError(`Year ${t3} was not matched by any era`);
      return { eraYear: r3, era: n2.name };
    };
    let { year: t2, eraYear: r2, era: o2 } = e2;
    if (null != t2)
      ({ eraYear: r2, era: o2 } = eraFromYear(t2)), checkField("era", o2), checkField("eraYear", r2);
    else {
      if (null == r2)
        throw new RangeError("Either `year` or `eraYear` and `era` are required");
      {
        const e3 = void 0 === o2 ? void 0 : this.eras.find((e4) => e4.name === o2 || e4.genericName === o2);
        if (!e3)
          throw new RangeError(`Era ${o2} (ISO year ${r2}) was not matched by any era`);
        if (r2 < 1 && e3.reverseOf)
          throw new RangeError(`Years in ${o2} era must be positive, not ${t2}`);
        t2 = e3.reverseOf ? e3.anchorEpoch.year - r2 : r2 + e3.anchorEpoch.year - (e3.hasYearZero ? 0 : 1), checkField("year", t2), { eraYear: r2, era: o2 } = eraFromYear(t2);
      }
    }
    return { ...e2, year: t2, eraYear: r2, era: o2 };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain") {
    let o2 = e2;
    const { month: n2, monthCode: a2 } = o2;
    return void 0 === n2 && (o2 = { ...o2, month: monthCodeNumberPart(a2) }), this.validateCalendarDate(o2), o2 = this.completeEraYear(o2), super.adjustCalendarDate(o2, t2, r2);
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), { year: r2, month: o2, day: n2 } = t2, { anchorEra: a2 } = this;
    return RegulateISODate(r2 + a2.isoEpoch.year - (a2.hasYearZero ? 0 : 1), o2, n2, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
      if (CompareISODate(e2.year, e2.month, e2.day, 1582, 10, 15) < 0)
        throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
    }
  }
};
var OrthodoxBaseHelper = class extends GregorianBaseHelper {
  constructor(e2, t2) {
    super(e2, t2);
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (t2 + 1) % 4 == 0;
  }
  monthsInYear() {
    return 13;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 13 === t2 ? this.inLeapYear(e2) ? 6 : 5 : 30;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
};
var EthioaaHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethioaa", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }]);
  }
};
var CopticHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("coptic", [{ name: "era1", isoEpoch: { year: 284, month: 8, day: 29 } }, { name: "era0", reverseOf: "era1" }]);
  }
};
var EthiopicHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethiopic", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }, { name: "era1", isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }]);
  }
};
var RocHelper = class extends GregorianBaseHelper {
  constructor() {
    super("roc", [{ name: "minguo", isoEpoch: { year: 1912, month: 1, day: 1 } }, { name: "before-roc", reverseOf: "minguo" }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var BuddhistHelper = class extends GregorianBaseHelper {
  constructor() {
    super("buddhist", [{ name: "be", hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var GregoryHelper = class extends GregorianBaseHelper {
  constructor() {
    super("gregory", [{ name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]);
  }
  reviseIntlEra(e2) {
    let { era: t2, eraYear: r2 } = e2;
    return "bc" !== t2 && "b" !== t2 || (t2 = "bce"), "ad" !== t2 && "a" !== t2 || (t2 = "ce"), { era: t2, eraYear: r2 };
  }
};
var JapaneseHelper = class extends GregorianBaseHelper {
  constructor() {
    super("japanese", [{ name: "reiwa", isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } }, { name: "heisei", isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } }, { name: "showa", isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } }, { name: "taisho", isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } }, { name: "meiji", isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } }, { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]), this.calendarIsVulnerableToJulianBug = true, this.eraLength = "long";
  }
  reviseIntlEra(e2, t2) {
    const { era: r2, eraYear: o2 } = e2, { year: n2 } = t2;
    return this.eras.find((e3) => e3.name === r2) ? { era: r2, eraYear: o2 } : n2 < 1 ? { era: "bce", eraYear: 1 - n2 } : { era: "ce", eraYear: n2 };
  }
};
var ChineseBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunisolar", this.hasEra = false;
  }
  inLeapYear(e2, t2) {
    const r2 = this.getMonthList(e2.year, t2);
    return 13 === ct(r2).length;
  }
  monthsInYear(e2, t2) {
    return this.inLeapYear(e2, t2) ? 13 : 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  getMonthList(e2, t2) {
    if (void 0 === e2)
      throw new TypeError("Missing year");
    const r2 = JSON.stringify({ func: "getMonthList", calendarYear: e2, id: this.id }), o2 = t2.get(r2);
    if (o2)
      return o2;
    const n2 = this.getFormatter(), getCalendarDate = (e3, t3) => {
      const r3 = toUtcIsoDateString({ isoYear: e3, isoMonth: 2, isoDay: 1 }), o3 = new Date(r3);
      o3.setUTCDate(t3 + 1);
      const a3 = n2.formatToParts(o3), i3 = a3.find((e4) => "month" === e4.type).value, s3 = +a3.find((e4) => "day" === e4.type).value;
      let l3 = a3.find((e4) => "relatedYear" === e4.type);
      if (void 0 === l3)
        throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
      return l3 = +l3.value, { calendarMonthString: i3, calendarDay: s3, calendarYearToVerify: l3 };
    };
    let a2 = 17, { calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2);
    "1" !== i2 && (a2 += 29, { calendarMonthString: i2, calendarDay: s2 } = getCalendarDate(e2, a2)), a2 -= s2 - 5;
    const d2 = {};
    let m2, c2, h2 = 1, u2 = false;
    do {
      ({ calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2)), m2 && (d2[c2].daysInMonth = m2 + 30 - s2), l2 !== e2 ? u2 = true : (d2[i2] = { monthIndex: h2++ }, a2 += 30), m2 = s2, c2 = i2;
    } while (!u2);
    return d2[c2].daysInMonth = m2 + 30 - s2, t2.set(r2, d2), d2;
  }
  estimateIsoDate(e2) {
    const { year: t2, month: r2 } = e2;
    return { year: t2, month: r2 >= 12 ? 12 : r2 + 1, day: 1 };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, month: a2, monthExtra: i2, day: s2, monthCode: l2, eraYear: d2 } = e2;
    if (o2) {
      if (n2 = d2, i2 && "bis" !== i2)
        throw new RangeError(`Unexpected leap month suffix: ${i2}`);
      const e3 = buildMonthCode(a2, void 0 !== i2), r3 = `${a2}${i2 || ""}`, o3 = this.getMonthList(n2, t2)[r3];
      if (void 0 === o3)
        throw new RangeError(`Unmatched month ${r3} in Chinese year ${n2}`);
      return a2 = o3.monthIndex, { year: n2, month: a2, day: s2, era: void 0, eraYear: d2, monthCode: e3 };
    }
    if (this.validateCalendarDate(e2), void 0 === n2 && (n2 = d2), void 0 === d2 && (d2 = n2), void 0 === a2) {
      const e3 = this.getMonthList(n2, t2);
      let o3 = l2.replace("L", "bis").slice(1);
      "0" === o3[0] && (o3 = o3.slice(1));
      let i3 = e3[o3];
      if (a2 = i3 && i3.monthIndex, void 0 === a2 && l2.endsWith("L") && !at.call(["M01L", "M12L", "M13L"], l2) && "constrain" === r2) {
        let t3 = l2.slice(1, -1);
        "0" === t3[0] && (t3 = t3.slice(1)), i3 = e3[t3], i3 && ({ daysInMonth: s2, monthIndex: a2 } = i3, l2 = buildMonthCode(t3));
      }
      if (void 0 === a2)
        throw new RangeError(`Unmatched month ${l2} in Chinese year ${n2}`);
    } else if (void 0 === l2) {
      const e3 = this.getMonthList(n2, t2), o3 = ct(e3), i3 = o3.length;
      "reject" === r2 ? (RejectToRange(a2, 1, i3), RejectToRange(s2, 1, this.maximumMonthLength())) : (a2 = ConstrainToRange(a2, 1, i3), s2 = ConstrainToRange(s2, 1, this.maximumMonthLength()));
      const d3 = o3.find(([, e4]) => e4.monthIndex === a2);
      if (void 0 === d3)
        throw new RangeError(`Invalid month ${a2} in Chinese year ${n2}`);
      l2 = buildMonthCode(d3[0].replace("bis", ""), -1 !== d3[0].indexOf("bis"));
    } else {
      const e3 = this.getMonthList(n2, t2);
      let r3 = l2.replace("L", "bis").slice(1);
      "0" === r3[0] && (r3 = r3.slice(1));
      const o3 = e3[r3];
      if (!o3)
        throw new RangeError(`Unmatched monthCode ${l2} in Chinese year ${n2}`);
      if (a2 !== o3.monthIndex)
        throw new RangeError(`monthCode ${l2} doesn't correspond to month ${a2} in Chinese year ${n2}`);
    }
    return { ...e2, year: n2, eraYear: d2, month: a2, monthCode: l2, day: s2 };
  }
};
var ChineseHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "chinese";
  }
};
var DangiHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "dangi";
  }
};
var Tt = { helper: void 0, dateFromFields(e2, t2, r2) {
  const o2 = ToTemporalOverflow(t2), n2 = new OneObjectCache(), a2 = PrepareTemporalFields(e2, ["day", "era", "eraYear", "month", "monthCode", "year"], ["day"]), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate(a2, o2, n2), d2 = CreateTemporalDate(i2, s2, l2, r2);
  return n2.setObject(d2), d2;
}, yearMonthFromFields(e2, t2, r2) {
  const o2 = ToTemporalOverflow(t2), n2 = new OneObjectCache(), a2 = PrepareTemporalFields(e2, ["era", "eraYear", "month", "monthCode", "year"], []), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate({ ...a2, day: 1 }, o2, n2), d2 = CreateTemporalYearMonth(i2, s2, r2, l2);
  return n2.setObject(d2), d2;
}, monthDayFromFields(e2, t2, r2) {
  const o2 = ToTemporalOverflow(t2), n2 = new OneObjectCache(), a2 = PrepareTemporalFields(e2, ["day", "era", "eraYear", "month", "monthCode", "year"], ["day"]), { year: i2, month: s2, day: l2 } = this.helper.monthDayFromFields(a2, o2, n2), d2 = CreateTemporalMonthDay(s2, l2, r2, i2);
  return n2.setObject(d2), d2;
}, fields(e2) {
  let t2 = e2;
  return at.call(t2, "year") && (t2 = [...t2, "era", "eraYear"]), t2;
}, mergeFields(e2, t2) {
  const r2 = { ...e2 }, o2 = { ...t2 }, { month: n2, monthCode: a2, year: i2, era: s2, eraYear: l2, ...d2 } = r2, { month: m2, monthCode: c2, year: h2, era: u2, eraYear: T2 } = o2;
  return void 0 === m2 && void 0 === c2 && (d2.month = n2, d2.monthCode = a2), void 0 === h2 && void 0 === u2 && void 0 === T2 && (d2.year = i2), { ...d2, ...o2 };
}, dateAdd(e2, t2, r2, o2, n2, a2, i2) {
  const s2 = OneObjectCache.getCacheForObject(e2), l2 = this.helper.temporalToCalendarDate(e2, s2), d2 = this.helper.addCalendar(l2, { years: t2, months: r2, weeks: o2, days: n2 }, a2, s2), m2 = this.helper.calendarToIsoDate(d2, "constrain", s2), { year: c2, month: h2, day: u2 } = m2, T2 = CreateTemporalDate(c2, h2, u2, i2);
  return new OneObjectCache(s2).setObject(T2), T2;
}, dateUntil(e2, t2, r2) {
  const o2 = OneObjectCache.getCacheForObject(e2), n2 = OneObjectCache.getCacheForObject(t2), a2 = this.helper.temporalToCalendarDate(e2, o2), i2 = this.helper.temporalToCalendarDate(t2, n2);
  return this.helper.untilCalendar(a2, i2, r2, o2);
}, year(e2) {
  const t2 = OneObjectCache.getCacheForObject(e2);
  return this.helper.temporalToCalendarDate(e2, t2).year;
}, month(e2) {
  const t2 = OneObjectCache.getCacheForObject(e2);
  return this.helper.temporalToCalendarDate(e2, t2).month;
}, day(e2) {
  const t2 = OneObjectCache.getCacheForObject(e2);
  return this.helper.temporalToCalendarDate(e2, t2).day;
}, era(e2) {
  if (!this.helper.hasEra)
    return;
  const t2 = OneObjectCache.getCacheForObject(e2);
  return this.helper.temporalToCalendarDate(e2, t2).era;
}, eraYear(e2) {
  if (!this.helper.hasEra)
    return;
  const t2 = OneObjectCache.getCacheForObject(e2);
  return this.helper.temporalToCalendarDate(e2, t2).eraYear;
}, monthCode(e2) {
  const t2 = OneObjectCache.getCacheForObject(e2);
  return this.helper.temporalToCalendarDate(e2, t2).monthCode;
}, dayOfWeek: (e2) => ut.iso8601.dayOfWeek(e2), dayOfYear(e2) {
  const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.isoToCalendarDate(e2, t2), o2 = this.helper.startOfCalendarYear(r2);
  return this.helper.calendarDaysUntil(o2, r2, t2) + 1;
}, weekOfYear: (e2) => ut.iso8601.weekOfYear(e2), daysInWeek: (e2) => ut.iso8601.daysInWeek(e2), daysInMonth(e2) {
  const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2), o2 = this.helper.maximumMonthLength(r2);
  if (o2 === this.helper.minimumMonthLength(r2))
    return o2;
  const n2 = this.helper.startOfCalendarMonth(r2), a2 = this.helper.addMonthsCalendar(n2, 1, "constrain", t2);
  return this.helper.calendarDaysUntil(n2, a2, t2);
}, daysInYear(e2) {
  let t2 = e2;
  HasSlot(t2, n) || (t2 = ToTemporalDate(t2));
  const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2), a2 = this.helper.startOfCalendarYear(o2), i2 = this.helper.addCalendar(a2, { years: 1 }, "constrain", r2);
  return this.helper.calendarDaysUntil(a2, i2, r2);
}, monthsInYear(e2) {
  const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2);
  return this.helper.monthsInYear(r2, t2);
}, inLeapYear(e2) {
  let t2 = e2;
  HasSlot(t2, n) || (t2 = ToTemporalDate(t2));
  const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2);
  return this.helper.inLeapYear(o2, r2);
} };
for (const e2 of [HebrewHelper, PersianHelper, EthiopicHelper, EthioaaHelper, CopticHelper, ChineseHelper, DangiHelper, RocHelper, IndianHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper]) {
  const t2 = new e2();
  ut[t2.id] = { ...Tt, helper: t2 };
}
var PlainDate = class {
  constructor(e2, t2, r2, o2 = GetISO8601Calendar()) {
    const n2 = ToIntegerThrowOnInfinity(e2), a2 = ToIntegerThrowOnInfinity(t2), i2 = ToIntegerThrowOnInfinity(r2), s2 = ToTemporalCalendar(o2);
    if (arguments.length < 3)
      throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");
    CreateTemporalDateSlots(this, n2, a2, i2, s2);
  }
  get calendar() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get era() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, u), this);
  }
  get eraYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, u), this);
  }
  get year() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, u), this);
  }
  get month() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, u), this);
  }
  get monthCode() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, u), this);
  }
  get day() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, u), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, u), this);
  }
  get dayOfYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, u), this);
  }
  get weekOfYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, u), this);
  }
  get daysInWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, u), this);
  }
  get daysInMonth() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, u), this);
  }
  get daysInYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, u), this);
  }
  get monthsInYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, u), this);
  }
  get inLeapYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, u), this);
  }
  with(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectObjectWithCalendarOrTimeZone(e2);
    const r2 = GetSlot(this, u), o2 = CalendarFields(r2, ["day", "month", "monthCode", "year"]), n2 = PrepareTemporalFields(e2, o2, "partial");
    if (!n2)
      throw new TypeError("invalid date-like");
    let a2 = PrepareTemporalFields(this, o2, []);
    a2 = CalendarMergeFields(r2, a2, n2), a2 = PrepareTemporalFields(a2, o2, []);
    return CalendarDateFromFields(r2, a2, GetOptionsObject(t2));
  }
  withCalendar(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendar(e2);
    return new PlainDate(GetSlot(this, n), GetSlot(this, a), GetSlot(this, i), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalDuration(e2), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, u), this, r2, o2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const r2 = CreateNegatedTemporalDuration(ToTemporalDuration(e2)), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, u), this, r2, o2);
  }
  until(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    for (const e3 of [n, a, i]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
  }
  toString(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return TemporalDateToString(this, ToShowCalendarOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return TemporalDateToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return new ot(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n), r2 = GetSlot(this, a), o2 = GetSlot(this, i), T2 = GetSlot(this, u);
    if (void 0 === e2)
      return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, T2);
    const p2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(p2, s), GetSlot(p2, l), GetSlot(p2, d), GetSlot(p2, m), GetSlot(p2, c), GetSlot(p2, h), T2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    let t2, o2;
    if (IsObject(e2)) {
      const r2 = e2.timeZone;
      void 0 === r2 ? t2 = ToTemporalTimeZone(e2) : (t2 = ToTemporalTimeZone(r2), o2 = e2.plainTime);
    } else
      t2 = ToTemporalTimeZone(e2);
    const T2 = GetSlot(this, n), p2 = GetSlot(this, a), f2 = GetSlot(this, i), y2 = GetSlot(this, u);
    let S2 = 0, w2 = 0, g2 = 0, I2 = 0, D2 = 0, G2 = 0;
    void 0 !== o2 && (o2 = ToTemporalTime(o2), S2 = GetSlot(o2, s), w2 = GetSlot(o2, l), g2 = GetSlot(o2, d), I2 = GetSlot(o2, m), D2 = GetSlot(o2, c), G2 = GetSlot(o2, h));
    return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(t2, CreateTemporalDateTime(T2, p2, f2, S2, w2, g2, I2, D2, G2, y2), "compatible"), r), t2, y2);
  }
  toPlainYearMonth() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, u);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, u);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoMonth: GetSlot(this, a), isoYear: GetSlot(this, n) };
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDate(e2) ? (ToTemporalOverflow(r2), CreateTemporalDate(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, u))) : ToTemporalDate(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDate(e2), o2 = ToTemporalDate(t2);
    return CompareISODate(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(o2, n), GetSlot(o2, a), GetSlot(o2, i));
  }
};
MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
var PlainDateTime = class {
  constructor(e2, t2, r2, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = GetISO8601Calendar()) {
    const m2 = ToIntegerThrowOnInfinity(e2), c2 = ToIntegerThrowOnInfinity(t2), h2 = ToIntegerThrowOnInfinity(r2), u2 = ToIntegerThrowOnInfinity(o2), T2 = ToIntegerThrowOnInfinity(n2), p2 = ToIntegerThrowOnInfinity(a2), f2 = ToIntegerThrowOnInfinity(i2), y2 = ToIntegerThrowOnInfinity(s2), S2 = ToIntegerThrowOnInfinity(l2), w2 = ToTemporalCalendar(d2);
    if (arguments.length < 3)
      throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");
    CreateTemporalDateTimeSlots(this, m2, c2, h2, u2, T2, p2, f2, y2, S2, w2);
  }
  get calendar() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get year() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, u), this);
  }
  get month() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, u), this);
  }
  get monthCode() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, u), this);
  }
  get day() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, u), this);
  }
  get hour() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, s);
  }
  get minute() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, l);
  }
  get second() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get millisecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get microsecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get nanosecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get era() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, u), this);
  }
  get eraYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, u), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, u), this);
  }
  get dayOfYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, u), this);
  }
  get weekOfYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, u), this);
  }
  get daysInWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, u), this);
  }
  get daysInYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, u), this);
  }
  get daysInMonth() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, u), this);
  }
  get monthsInYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, u), this);
  }
  get inLeapYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, u), this);
  }
  with(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectObjectWithCalendarOrTimeZone(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, u), n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), a2 = PrepareTemporalFields(e2, n2, "partial");
    if (!a2)
      throw new TypeError("invalid date-time-like");
    let i2 = PrepareTemporalFields(this, n2, []);
    i2 = CalendarMergeFields(o2, i2, a2), i2 = PrepareTemporalFields(i2, n2, []);
    const { year: s2, month: l2, day: d2, hour: m2, minute: c2, second: h2, millisecond: T2, microsecond: p2, nanosecond: f2 } = InterpretTemporalDateTimeFields(o2, i2, r2);
    return CreateTemporalDateTime(s2, l2, d2, m2, c2, h2, T2, p2, f2, o2);
  }
  withPlainTime(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n), r2 = GetSlot(this, a), o2 = GetSlot(this, i), T2 = GetSlot(this, u);
    if (void 0 === e2)
      return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, T2);
    const p2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(p2, s), GetSlot(p2, l), GetSlot(p2, d), GetSlot(p2, m), GetSlot(p2, c), GetSlot(p2, h), T2);
  }
  withPlainDate(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, n), o2 = GetSlot(t2, a), T2 = GetSlot(t2, i);
    let p2 = GetSlot(t2, u);
    const f2 = GetSlot(this, s), y2 = GetSlot(this, l), S2 = GetSlot(this, d), w2 = GetSlot(this, m), g2 = GetSlot(this, c), I2 = GetSlot(this, h);
    return p2 = ConsolidateCalendars(GetSlot(this, u), p2), CreateTemporalDateTime(r2, o2, T2, f2, y2, S2, w2, g2, I2, p2);
  }
  withCalendar(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendar(e2);
    return new PlainDateTime(GetSlot(this, n), GetSlot(this, a), GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = GetTemporalUnit(t2, "smallestUnit", "time", je, ["day"]), o2 = ToTemporalRoundingMode(t2, "halfExpand"), T2 = ToTemporalRoundingIncrement(t2, { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[r2], false);
    let p2 = GetSlot(this, n), f2 = GetSlot(this, a), y2 = GetSlot(this, i), S2 = GetSlot(this, s), w2 = GetSlot(this, l), g2 = GetSlot(this, d), I2 = GetSlot(this, m), D2 = GetSlot(this, c), G2 = GetSlot(this, h);
    return { year: p2, month: f2, day: y2, hour: S2, minute: w2, second: g2, millisecond: I2, microsecond: D2, nanosecond: G2 } = RoundISODateTime(p2, f2, y2, S2, w2, g2, I2, D2, G2, T2, r2, o2), CreateTemporalDateTime(p2, f2, y2, S2, w2, g2, I2, D2, G2, GetSlot(this, u));
  }
  equals(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDateTime(e2);
    for (const e3 of [n, a, i, s, l, d, m, c, h]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
  }
  toString(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2);
    return TemporalDateTimeToString(this, r2, ToShowCalendarOption(t2), { unit: o2, increment: n2, roundingMode: ToTemporalRoundingMode(t2, "trunc") });
  }
  toJSON() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return new ot(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
  }
  toZonedDateTime(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalTimeZone(e2);
    return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(o2, this, ToTemporalDisambiguation(GetOptionsObject(t2))), r), o2, GetSlot(this, u));
  }
  toPlainDate() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, u);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, u);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  toPlainTime() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(this);
  }
  getISOFields() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoHour: GetSlot(this, s), isoMicrosecond: GetSlot(this, c), isoMillisecond: GetSlot(this, m), isoMinute: GetSlot(this, l), isoMonth: GetSlot(this, a), isoNanosecond: GetSlot(this, h), isoSecond: GetSlot(this, d), isoYear: GetSlot(this, n) };
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDateTime(e2) ? (ToTemporalOverflow(r2), CreateTemporalDateTime(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u))) : ToTemporalDateTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDateTime(e2), o2 = ToTemporalDateTime(t2);
    for (const e3 of [n, a, i, s, l, d, m, c, h]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2)
        return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
var Duration = class {
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = 0) {
    const m2 = ToIntegerWithoutRounding(e2), c2 = ToIntegerWithoutRounding(t2), h2 = ToIntegerWithoutRounding(r2), u2 = ToIntegerWithoutRounding(o2), T2 = ToIntegerWithoutRounding(n2), p2 = ToIntegerWithoutRounding(a2), C2 = ToIntegerWithoutRounding(i2), E2 = ToIntegerWithoutRounding(s2), b2 = ToIntegerWithoutRounding(l2), M2 = ToIntegerWithoutRounding(d2);
    RejectDuration(m2, c2, h2, u2, T2, p2, C2, E2, b2, M2), CreateSlots(this), SetSlot(this, f, m2), SetSlot(this, y, c2), SetSlot(this, S, h2), SetSlot(this, w, u2), SetSlot(this, g, T2), SetSlot(this, I, p2), SetSlot(this, D, C2), SetSlot(this, G, E2), SetSlot(this, v, b2), SetSlot(this, O, M2);
  }
  get years() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, f);
  }
  get months() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, y);
  }
  get weeks() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, S);
  }
  get days() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, w);
  }
  get hours() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, g);
  }
  get minutes() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, I);
  }
  get seconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, D);
  }
  get milliseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, G);
  }
  get microseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, v);
  }
  get nanoseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, O);
  }
  get sign() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return DurationSign(GetSlot(this, f), GetSlot(this, y), GetSlot(this, S), GetSlot(this, w), GetSlot(this, g), GetSlot(this, I), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, O));
  }
  get blank() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return 0 === DurationSign(GetSlot(this, f), GetSlot(this, y), GetSlot(this, S), GetSlot(this, w), GetSlot(this, g), GetSlot(this, I), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, O));
  }
  with(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    const t2 = PrepareTemporalFields(e2, ["days", "hours", "microseconds", "milliseconds", "minutes", "months", "nanoseconds", "seconds", "weeks", "years"], "partial");
    if (!t2)
      throw new TypeError("invalid duration-like");
    const { years: r2 = GetSlot(this, f), months: o2 = GetSlot(this, y), weeks: n2 = GetSlot(this, S), days: a2 = GetSlot(this, w), hours: i2 = GetSlot(this, g), minutes: s2 = GetSlot(this, I), seconds: l2 = GetSlot(this, D), milliseconds: d2 = GetSlot(this, G), microseconds: m2 = GetSlot(this, v), nanoseconds: c2 = GetSlot(this, O) } = t2;
    return new Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  negated() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return CreateNegatedTemporalDuration(this);
  }
  abs() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return new Duration(Math.abs(GetSlot(this, f)), Math.abs(GetSlot(this, y)), Math.abs(GetSlot(this, S)), Math.abs(GetSlot(this, w)), Math.abs(GetSlot(this, g)), Math.abs(GetSlot(this, I)), Math.abs(GetSlot(this, D)), Math.abs(GetSlot(this, G)), Math.abs(GetSlot(this, v)), Math.abs(GetSlot(this, O)));
  }
  add(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("subtract", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    let t2 = GetSlot(this, f), r2 = GetSlot(this, y), o2 = GetSlot(this, S), n2 = GetSlot(this, w), a2 = GetSlot(this, g), i2 = GetSlot(this, I), s2 = GetSlot(this, D), l2 = GetSlot(this, G), d2 = GetSlot(this, v), m2 = GetSlot(this, O), c2 = DefaultTemporalLargestUnit(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
    const h2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2);
    let T2 = GetTemporalUnit(h2, "smallestUnit", "datetime", void 0), p2 = true;
    T2 || (p2 = false, T2 = "nanosecond"), c2 = LargerOfTwoTemporalUnits(c2, T2);
    let C2 = GetTemporalUnit(h2, "largestUnit", "datetime", void 0, ["auto"]), E2 = true;
    if (C2 || (E2 = false, C2 = c2), "auto" === C2 && (C2 = c2), !p2 && !E2)
      throw new RangeError("at least one of smallestUnit or largestUnit is required");
    if (LargerOfTwoTemporalUnits(C2, T2) !== C2)
      throw new RangeError(`largestUnit ${C2} cannot be smaller than smallestUnit ${T2}`);
    const b2 = ToTemporalRoundingMode(h2, "halfExpand"), M2 = ToTemporalDateTimeRoundingIncrement(h2, T2);
    let R2 = ToRelativeTemporalObject(h2);
    return { years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, C2, R2), { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, M2, T2, b2, R2), { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, M2, T2, b2, R2), { years: t2, months: r2, weeks: o2, days: n2 } = function BalanceDurationRelative(e3, t3, r3, o3, n3, a3) {
      let i3 = e3, s3 = t3, l3 = r3, d3 = o3;
      const m3 = GetIntrinsic("%Temporal.Duration%"), c3 = DurationSign(i3, s3, l3, d3, 0, 0, 0, 0, 0, 0);
      if (0 === c3)
        return { years: i3, months: s3, weeks: l3, days: d3 };
      let h3, T3;
      a3 && (T3 = ToTemporalDate(a3), h3 = GetSlot(T3, u));
      const p3 = new m3(c3), f2 = new m3(0, c3), S2 = new m3(0, 0, c3);
      switch (n3) {
        case "year": {
          if (!h3)
            throw new RangeError("a starting point is required for years balancing");
          let e4, t4, r4;
          for ({ relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, p3); K(d3) >= K(t4); )
            d3 -= t4, i3 += c3, T3 = e4, { relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, p3);
          for ({ relativeTo: e4, days: r4 } = MoveRelativeDate(h3, T3, f2); K(d3) >= K(r4); )
            d3 -= r4, s3 += c3, T3 = e4, { relativeTo: e4, days: r4 } = MoveRelativeDate(h3, T3, f2);
          const o4 = h3.dateAdd;
          e4 = CalendarDateAdd(h3, T3, p3, void 0, o4);
          const n4 = h3.dateUntil, a4 = le(null);
          a4.largestUnit = "month";
          let l4 = CalendarDateUntil(h3, T3, e4, a4, n4), m4 = GetSlot(l4, y);
          for (; K(s3) >= K(m4); ) {
            s3 -= m4, i3 += c3, T3 = e4, e4 = CalendarDateAdd(h3, T3, p3, void 0, o4);
            const t5 = le(null);
            t5.largestUnit = "month", l4 = CalendarDateUntil(h3, T3, e4, t5, n4), m4 = GetSlot(l4, y);
          }
          break;
        }
        case "month": {
          if (!h3)
            throw new RangeError("a starting point is required for months balancing");
          let e4, t4;
          for ({ relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, f2); K(d3) >= K(t4); )
            d3 -= t4, s3 += c3, T3 = e4, { relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, f2);
          break;
        }
        case "week": {
          if (!h3)
            throw new RangeError("a starting point is required for weeks balancing");
          let e4, t4;
          for ({ relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, S2); K(d3) >= K(t4); )
            d3 -= t4, l3 += c3, T3 = e4, { relativeTo: e4, days: t4 } = MoveRelativeDate(h3, T3, S2);
          break;
        }
      }
      return { years: i3, months: s3, weeks: l3, days: d3 };
    }(t2, r2, o2, n2, C2, R2), IsTemporalZonedDateTime(R2) && (R2 = MoveRelativeZonedDateTime(R2, t2, r2, o2, 0)), { days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = BalanceDuration(n2, a2, i2, s2, l2, d2, m2, C2, R2), new Duration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
  }
  total(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    let t2 = GetSlot(this, f), r2 = GetSlot(this, y), o2 = GetSlot(this, S), n2 = GetSlot(this, w), a2 = GetSlot(this, g), i2 = GetSlot(this, I), s2 = GetSlot(this, D), l2 = GetSlot(this, G), d2 = GetSlot(this, v), m2 = GetSlot(this, O);
    if (void 0 === e2)
      throw new TypeError("options argument is required");
    const c2 = "string" == typeof e2 ? CreateOnePropObject("unit", e2) : GetOptionsObject(e2), h2 = GetTemporalUnit(c2, "unit", "datetime", je), u2 = ToRelativeTemporalObject(c2);
    let T2;
    ({ years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, h2, u2)), IsTemporalZonedDateTime(u2) && (T2 = MoveRelativeZonedDateTime(u2, t2, r2, o2, 0)), { days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = BalanceDuration(n2, a2, i2, s2, l2, d2, m2, h2, T2);
    const { total: p2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, 1, h2, "trunc", u2);
    return p2;
  }
  toString(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2);
    if ("minute" === r2)
      throw new RangeError('smallestUnit must not be "minute"');
    return TemporalDurationToString(this, r2, { unit: o2, increment: n2, roundingMode: ToTemporalRoundingMode(t2, "trunc") });
  }
  toJSON() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return TemporalDurationToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e2, t2).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), TemporalDurationToString(this));
  }
  valueOf() {
    throw new TypeError("use compare() to compare Temporal.Duration");
  }
  static from(e2) {
    return IsTemporalDuration(e2) ? new Duration(GetSlot(e2, f), GetSlot(e2, y), GetSlot(e2, S), GetSlot(e2, w), GetSlot(e2, g), GetSlot(e2, I), GetSlot(e2, D), GetSlot(e2, G), GetSlot(e2, v), GetSlot(e2, O)) : ToTemporalDuration(e2);
  }
  static compare(t2, r2, o2) {
    const n2 = ToTemporalDuration(t2), a2 = ToTemporalDuration(r2), i2 = ToRelativeTemporalObject(GetOptionsObject(o2)), s2 = GetSlot(n2, f), l2 = GetSlot(n2, y), d2 = GetSlot(n2, S);
    let m2 = GetSlot(n2, w);
    const c2 = GetSlot(n2, g), h2 = GetSlot(n2, I), u2 = GetSlot(n2, D), T2 = GetSlot(n2, G), p2 = GetSlot(n2, v);
    let C2 = GetSlot(n2, O);
    const E2 = GetSlot(a2, f), b2 = GetSlot(a2, y), M2 = GetSlot(a2, S);
    let R2 = GetSlot(a2, w);
    const Z2 = GetSlot(a2, g), P2 = GetSlot(a2, I), F2 = GetSlot(a2, D), Y2 = GetSlot(a2, G), j2 = GetSlot(a2, v);
    let $2 = GetSlot(a2, O);
    const B2 = CalculateOffsetShift(i2, s2, l2, d2, m2), N10 = CalculateOffsetShift(i2, E2, b2, M2, R2);
    0 === s2 && 0 === E2 && 0 === l2 && 0 === b2 && 0 === d2 && 0 === M2 || ({ days: m2 } = UnbalanceDurationRelative(s2, l2, d2, m2, "day", i2), { days: R2 } = UnbalanceDurationRelative(E2, b2, M2, R2, "day", i2));
    const k2 = TotalDurationNanoseconds(m2, c2, h2, u2, T2, p2, C2, B2), A2 = TotalDurationNanoseconds(R2, Z2, P2, F2, Y2, j2, $2, N10);
    return ComparisonResult(import_jsbi.default.toNumber(import_jsbi.default.subtract(k2, A2)));
  }
};
MakeIntrinsicClass(Duration, "Temporal.Duration");
var pt = Object.create;
var PlainMonthDay = class {
  constructor(e2, t2, r2 = GetISO8601Calendar(), o2 = 1972) {
    const n2 = ToIntegerThrowOnInfinity(e2), a2 = ToIntegerThrowOnInfinity(t2), i2 = ToTemporalCalendar(r2), s2 = ToIntegerThrowOnInfinity(o2);
    if (arguments.length < 2)
      throw new RangeError("missing argument: isoMonth and isoDay are required");
    CreateTemporalMonthDaySlots(this, n2, a2, i2, s2);
  }
  get monthCode() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, u), this);
  }
  get day() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, u), this);
  }
  get calendar() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  with(e2, t2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectObjectWithCalendarOrTimeZone(e2);
    const r2 = GetSlot(this, u), o2 = CalendarFields(r2, ["day", "month", "monthCode", "year"]), n2 = PrepareTemporalFields(e2, o2, "partial");
    if (!n2)
      throw new TypeError("invalid month-day-like");
    let a2 = PrepareTemporalFields(this, o2, []);
    a2 = CalendarMergeFields(r2, a2, n2), a2 = PrepareTemporalFields(a2, o2, []);
    return CalendarMonthDayFromFields(r2, a2, GetOptionsObject(t2));
  }
  equals(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalMonthDay(e2);
    for (const e3 of [a, i, n]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
  }
  toString(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this, ToShowCalendarOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return new ot(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
  }
  toPlainDate(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, u), r2 = CalendarFields(t2, ["day", "monthCode"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["year"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = pt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoMonth: GetSlot(this, a), isoYear: GetSlot(this, n) };
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalMonthDay(e2) ? (ToTemporalOverflow(r2), CreateTemporalMonthDay(GetSlot(e2, a), GetSlot(e2, i), GetSlot(e2, u), GetSlot(e2, n))) : ToTemporalMonthDay(e2, r2);
  }
};
MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
var instant = () => new (GetIntrinsic("%Temporal.Instant%"))($e());
var plainDateTime = (e2, t2 = timeZone()) => {
  const r2 = ToTemporalTimeZone(t2), o2 = ToTemporalCalendar(e2);
  return BuiltinTimeZoneGetPlainDateTimeFor(r2, instant(), o2);
};
var plainDateTimeISO = (e2 = timeZone()) => {
  const t2 = ToTemporalTimeZone(e2), r2 = GetISO8601Calendar();
  return BuiltinTimeZoneGetPlainDateTimeFor(t2, instant(), r2);
};
var zonedDateTime = (e2, t2 = timeZone()) => {
  const r2 = ToTemporalTimeZone(t2), o2 = ToTemporalCalendar(e2);
  return CreateTemporalZonedDateTime($e(), r2, o2);
};
var timeZone = () => function SystemTimeZone() {
  const e2 = new J("en-us");
  return new (GetIntrinsic("%Temporal.TimeZone%"))(ParseTemporalTimeZone(e2.resolvedOptions().timeZone));
}();
var ft = { instant, plainDateTime, plainDateTimeISO, plainDate: (e2, t2 = timeZone()) => TemporalDateTimeToDate(plainDateTime(e2, t2)), plainDateISO: (e2 = timeZone()) => TemporalDateTimeToDate(plainDateTimeISO(e2)), plainTimeISO: (e2 = timeZone()) => TemporalDateTimeToTime(plainDateTimeISO(e2)), timeZone, zonedDateTime, zonedDateTimeISO: (e2 = timeZone()) => zonedDateTime(GetISO8601Calendar(), e2), [Symbol.toStringTag]: "Temporal.Now" };
Object.defineProperty(ft, Symbol.toStringTag, { value: "Temporal.Now", writable: false, enumerable: false, configurable: true });
var yt = Object.assign;
function TemporalTimeToString(e2, t2, r2) {
  let o2 = GetSlot(e2, s), n2 = GetSlot(e2, l), a2 = GetSlot(e2, d), i2 = GetSlot(e2, m), u2 = GetSlot(e2, c), T2 = GetSlot(e2, h);
  if (r2) {
    const { unit: e3, increment: t3, roundingMode: s2 } = r2;
    ({ hour: o2, minute: n2, second: a2, millisecond: i2, microsecond: u2, nanosecond: T2 } = RoundTime(o2, n2, a2, i2, u2, T2, t3, e3, s2));
  }
  return `${ISODateTimePartString(o2)}:${ISODateTimePartString(n2)}${FormatSecondsStringPart(a2, i2, u2, T2, t2)}`;
}
var PlainTime = class {
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0) {
    const i2 = ToIntegerThrowOnInfinity(e2), T2 = ToIntegerThrowOnInfinity(t2), p2 = ToIntegerThrowOnInfinity(r2), f2 = ToIntegerThrowOnInfinity(o2), y2 = ToIntegerThrowOnInfinity(n2), S2 = ToIntegerThrowOnInfinity(a2);
    RejectTime(i2, T2, p2, f2, y2, S2), CreateSlots(this), SetSlot(this, s, i2), SetSlot(this, l, T2), SetSlot(this, d, p2), SetSlot(this, m, f2), SetSlot(this, c, y2), SetSlot(this, h, S2), SetSlot(this, u, GetISO8601Calendar());
  }
  get calendar() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get hour() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, s);
  }
  get minute() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, l);
  }
  get second() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get millisecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get microsecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get nanosecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  with(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectObjectWithCalendarOrTimeZone(e2);
    const r2 = ToTemporalTimeRecord(e2, "partial"), o2 = ToTemporalOverflow(GetOptionsObject(t2)), n2 = ToTemporalTimeRecord(this);
    let { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = yt(n2, r2);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = RegulateTime(a2, i2, s2, l2, d2, m2, o2), new PlainTime(a2, i2, s2, l2, d2, m2);
  }
  add(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = GetTemporalUnit(t2, "smallestUnit", "time", je), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = ToTemporalRoundingIncrement(t2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[r2], false);
    let a2 = GetSlot(this, s), i2 = GetSlot(this, l), u2 = GetSlot(this, d), T2 = GetSlot(this, m), p2 = GetSlot(this, c), f2 = GetSlot(this, h);
    return { hour: a2, minute: i2, second: u2, millisecond: T2, microsecond: p2, nanosecond: f2 } = RoundTime(a2, i2, u2, T2, p2, f2, n2, r2, o2), new PlainTime(a2, i2, u2, T2, p2, f2);
  }
  equals(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTime(e2);
    for (const e3 of [s, l, d, m, c, h]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return true;
  }
  toString(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2);
    return TemporalTimeToString(this, r2, { unit: o2, increment: n2, roundingMode: ToTemporalRoundingMode(t2, "trunc") });
  }
  toJSON() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return TemporalTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return new ot(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, n), o2 = GetSlot(t2, a), T2 = GetSlot(t2, i), p2 = GetSlot(t2, u);
    return CreateTemporalDateTime(r2, o2, T2, GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), p2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    const t2 = e2.plainDate;
    if (void 0 === t2)
      throw new TypeError("missing date property");
    const o2 = ToTemporalDate(t2), T2 = e2.timeZone;
    if (void 0 === T2)
      throw new TypeError("missing timeZone property");
    const p2 = ToTemporalTimeZone(T2), f2 = GetSlot(o2, n), y2 = GetSlot(o2, a), S2 = GetSlot(o2, i), w2 = GetSlot(o2, u), g2 = GetSlot(this, s), I2 = GetSlot(this, l), D2 = GetSlot(this, d), G2 = GetSlot(this, m), v2 = GetSlot(this, c), O2 = GetSlot(this, h);
    return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(p2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, S2, g2, I2, D2, G2, v2, O2, w2), "compatible"), r), p2, w2);
  }
  getISOFields() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, u), isoHour: GetSlot(this, s), isoMicrosecond: GetSlot(this, c), isoMillisecond: GetSlot(this, m), isoMinute: GetSlot(this, l), isoNanosecond: GetSlot(this, h), isoSecond: GetSlot(this, d) };
  }
  static from(e2, t2) {
    const r2 = ToTemporalOverflow(GetOptionsObject(t2));
    return IsTemporalTime(e2) ? new PlainTime(GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h)) : ToTemporalTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalTime(e2), o2 = ToTemporalTime(t2);
    for (const e3 of [s, l, d, m, c, h]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2)
        return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
var TimeZone = class {
  constructor(e2) {
    if (arguments.length < 1)
      throw new RangeError("missing argument: identifier is required");
    const t2 = GetCanonicalTimeZoneIdentifier(e2);
    CreateSlots(this), SetSlot(this, o, t2);
  }
  get id() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return ToString(this);
  }
  getOffsetNanosecondsFor(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), n2 = GetSlot(this, o);
    return TestTimeZoneOffsetString(n2) ? ParseTimeZoneOffsetString(n2) : GetIANATimeZoneOffsetNanoseconds(GetSlot(t2, r), n2);
  }
  getOffsetStringFor(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return BuiltinTimeZoneGetOffsetStringFor(this, ToTemporalInstant(e2));
  }
  getPlainDateTimeFor(e2, t2 = GetISO8601Calendar()) {
    return BuiltinTimeZoneGetPlainDateTimeFor(this, ToTemporalInstant(e2), ToTemporalCalendar(t2));
  }
  getInstantFor(e2, t2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return BuiltinTimeZoneGetInstantFor(this, ToTemporalDateTime(e2), ToTemporalDisambiguation(GetOptionsObject(t2)));
  }
  getPossibleInstantsFor(t2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalDateTime(t2), u2 = GetIntrinsic("%Temporal.Instant%"), T2 = GetSlot(this, o);
    if (TestTimeZoneOffsetString(T2)) {
      const t3 = GetEpochFromISOParts(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h));
      if (null === t3)
        throw new RangeError("DateTime outside of supported range");
      const o2 = ParseTimeZoneOffsetString(T2);
      return [new u2(import_jsbi.default.subtract(t3, import_jsbi.default.BigInt(o2)))];
    }
    return function GetIANATimeZoneEpochValue(t3, r3, o2, n2, a2, i2, s2, l2, d2, m2) {
      const c2 = GetEpochFromISOParts(r3, o2, n2, a2, i2, s2, l2, d2, m2);
      if (null === c2)
        throw new RangeError("DateTime outside of supported range");
      let h2 = import_jsbi.default.subtract(c2, we);
      import_jsbi.default.lessThan(h2, ge) && (h2 = c2);
      let u3 = import_jsbi.default.add(c2, we);
      import_jsbi.default.greaterThan(u3, Ie) && (u3 = c2);
      const T3 = GetIANATimeZoneOffsetNanoseconds(h2, t3), p2 = GetIANATimeZoneOffsetNanoseconds(u3, t3);
      return (T3 === p2 ? [T3] : [T3, p2]).map((h3) => {
        const u4 = import_jsbi.default.subtract(c2, import_jsbi.default.BigInt(h3)), T4 = GetIANATimeZoneDateTimeParts(u4, t3);
        if (r3 === T4.year && o2 === T4.month && n2 === T4.day && a2 === T4.hour && i2 === T4.minute && s2 === T4.second && l2 === T4.millisecond && d2 === T4.microsecond && m2 === T4.nanosecond)
          return u4;
      }).filter((e2) => void 0 !== e2);
    }(T2, GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h)).map((e2) => new u2(e2));
  }
  getNextTransition(t2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const n2 = ToTemporalInstant(t2), a2 = GetSlot(this, o);
    if (TestTimeZoneOffsetString(a2) || "UTC" === a2)
      return null;
    let i2 = GetSlot(n2, r);
    const s2 = GetIntrinsic("%Temporal.Instant%");
    return i2 = function GetIANATimeZoneNextTransition(t3, r2) {
      const o2 = import_jsbi.default.add(t3, ve), n3 = maxJSBI(afterLatestPossibleTzdbRuleChange(), o2);
      let a3 = maxJSBI(De, t3);
      const i3 = GetIANATimeZoneOffsetNanoseconds(a3, r2);
      let s3 = a3, l2 = i3;
      for (; i3 === l2 && import_jsbi.default.lessThan(import_jsbi.default.BigInt(a3), n3); )
        s3 = import_jsbi.default.add(a3, Oe), l2 = GetIANATimeZoneOffsetNanoseconds(s3, r2), i3 === l2 && (a3 = s3);
      return i3 === l2 ? null : bisect((e2) => GetIANATimeZoneOffsetNanoseconds(e2, r2), a3, s3, i3, l2);
    }(i2, a2), null === i2 ? null : new s2(i2);
  }
  getPreviousTransition(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), n2 = GetSlot(this, o);
    if (TestTimeZoneOffsetString(n2) || "UTC" === n2)
      return null;
    let a2 = GetSlot(t2, r);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return a2 = GetIANATimeZonePreviousTransition(a2, n2), null === a2 ? null : new i2(a2);
  }
  toString() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return ToString(GetSlot(this, o));
  }
  toJSON() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return ToString(this);
  }
  static from(e2) {
    return ToTemporalTimeZone(e2);
  }
};
MakeIntrinsicClass(TimeZone, "Temporal.TimeZone");
var St = Object.create;
var PlainYearMonth = class {
  constructor(e2, t2, r2 = GetISO8601Calendar(), o2 = 1) {
    const n2 = ToIntegerThrowOnInfinity(e2), a2 = ToIntegerThrowOnInfinity(t2), i2 = ToTemporalCalendar(r2), s2 = ToIntegerThrowOnInfinity(o2);
    if (arguments.length < 2)
      throw new RangeError("missing argument: isoYear and isoMonth are required");
    CreateTemporalYearMonthSlots(this, n2, a2, i2, s2);
  }
  get year() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, u), this);
  }
  get month() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, u), this);
  }
  get monthCode() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, u), this);
  }
  get calendar() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get era() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, u), this);
  }
  get eraYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, u), this);
  }
  get daysInMonth() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, u), this);
  }
  get daysInYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, u), this);
  }
  get monthsInYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, u), this);
  }
  get inLeapYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, u), this);
  }
  with(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectObjectWithCalendarOrTimeZone(e2);
    const r2 = GetSlot(this, u), o2 = CalendarFields(r2, ["month", "monthCode", "year"]), n2 = PrepareTemporalFields(e2, o2, "partial");
    if (!n2)
      throw new TypeError("invalid year-month-like");
    let a2 = PrepareTemporalFields(this, o2, []);
    a2 = CalendarMergeFields(r2, a2, n2), a2 = PrepareTemporalFields(a2, o2, []);
    return CalendarYearMonthFromFields(r2, a2, GetOptionsObject(t2));
  }
  add(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalYearMonth(e2);
    for (const e3 of [n, a, i]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, u), GetSlot(t2, u));
  }
  toString(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this, ToShowCalendarOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return new ot(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
  }
  toPlainDate(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, u), r2 = CalendarFields(t2, ["monthCode", "year"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["day"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = St(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, u), isoDay: GetSlot(this, i), isoMonth: GetSlot(this, a), isoYear: GetSlot(this, n) };
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalYearMonth(e2) ? (ToTemporalOverflow(r2), CreateTemporalYearMonth(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, u), GetSlot(e2, i))) : ToTemporalYearMonth(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalYearMonth(e2), o2 = ToTemporalYearMonth(t2);
    return CompareISODate(GetSlot(r2, n), GetSlot(r2, a), GetSlot(r2, i), GetSlot(o2, n), GetSlot(o2, a), GetSlot(o2, i));
  }
};
MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
var ZonedDateTime = class {
  constructor(e2, t2, r2 = GetISO8601Calendar()) {
    if (arguments.length < 1)
      throw new TypeError("missing argument: epochNanoseconds is required");
    CreateTemporalZonedDateTimeSlots(this, ToBigInt(e2), ToTemporalTimeZone(t2), ToTemporalCalendar(r2));
  }
  get calendar() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get timeZone() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, p);
  }
  get year() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, u), dateTime(this));
  }
  get month() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, u), dateTime(this));
  }
  get monthCode() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, u), dateTime(this));
  }
  get day() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, u), dateTime(this));
  }
  get hour() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), s);
  }
  get minute() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), l);
  }
  get second() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), d);
  }
  get millisecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), m);
  }
  get microsecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), c);
  }
  get nanosecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), h);
  }
  get era() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, u), dateTime(this));
  }
  get eraYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, u), dateTime(this));
  }
  get epochSeconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, r);
    return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, ye));
  }
  get epochMilliseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, r);
    return import_jsbi.default.toNumber(import_jsbi.default.divide(t2, fe));
  }
  get epochMicroseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, r);
    return ToBigIntExternal(import_jsbi.default.divide(t2, pe));
  }
  get epochNanoseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(GetSlot(this, r));
  }
  get dayOfWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, u), dateTime(this));
  }
  get dayOfYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, u), dateTime(this));
  }
  get weekOfYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, u), dateTime(this));
  }
  get hoursInDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = dateTime(this), o2 = GetIntrinsic("%Temporal.PlainDateTime%"), s2 = GetSlot(t2, n), l2 = GetSlot(t2, a), d2 = GetSlot(t2, i), m2 = new o2(s2, l2, d2, 0, 0, 0, 0, 0, 0), c2 = AddISODate(s2, l2, d2, 0, 0, 0, 1, "reject"), h2 = new o2(c2.year, c2.month, c2.day, 0, 0, 0, 0, 0, 0), u2 = GetSlot(this, p), T2 = GetSlot(BuiltinTimeZoneGetInstantFor(u2, m2, "compatible"), r), f2 = GetSlot(BuiltinTimeZoneGetInstantFor(u2, h2, "compatible"), r);
    return import_jsbi.default.toNumber(import_jsbi.default.subtract(f2, T2)) / 36e11;
  }
  get daysInWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, u), dateTime(this));
  }
  get daysInMonth() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, u), dateTime(this));
  }
  get daysInYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, u), dateTime(this));
  }
  get monthsInYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, u), dateTime(this));
  }
  get inLeapYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, u), dateTime(this));
  }
  get offset() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, p), GetSlot(this, T));
  }
  get offsetNanoseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetOffsetNanosecondsFor(GetSlot(this, p), GetSlot(this, T));
  }
  with(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid zoned-date-time-like");
    RejectObjectWithCalendarOrTimeZone(e2);
    const r2 = GetOptionsObject(t2), o2 = ToTemporalDisambiguation(r2), n2 = ToTemporalOffset(r2, "prefer"), a2 = GetSlot(this, p), i2 = GetSlot(this, u), s2 = ArrayPush(CalendarFields(i2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), "offset"), l2 = PrepareTemporalFields(e2, s2, "partial"), d2 = ArrayPush(s2, "timeZone");
    let m2 = PrepareTemporalFields(this, d2, ["timeZone", "offset"]);
    m2 = CalendarMergeFields(i2, m2, l2), m2 = PrepareTemporalFields(m2, d2, ["timeZone", "offset"]);
    let { year: c2, month: h2, day: T2, hour: f2, minute: y2, second: S2, millisecond: w2, microsecond: g2, nanosecond: I2 } = InterpretTemporalDateTimeFields(i2, m2, r2);
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(c2, h2, T2, f2, y2, S2, w2, g2, I2, "option", ParseTimeZoneOffsetString(m2.offset), a2, o2, n2, false), GetSlot(this, p), i2);
  }
  withPlainDate(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), o2 = GetSlot(t2, n), T2 = GetSlot(t2, a), f2 = GetSlot(t2, i);
    let y2 = GetSlot(t2, u);
    const S2 = dateTime(this), w2 = GetSlot(S2, s), g2 = GetSlot(S2, l), I2 = GetSlot(S2, d), D2 = GetSlot(S2, m), G2 = GetSlot(S2, c), v2 = GetSlot(S2, h);
    y2 = ConsolidateCalendars(GetSlot(this, u), y2);
    const O2 = GetSlot(this, p);
    return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(O2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(o2, T2, f2, w2, g2, I2, D2, G2, v2, y2), "compatible"), r), O2, y2);
  }
  withPlainTime(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetIntrinsic("%Temporal.PlainTime%"), o2 = void 0 === e2 ? new t2() : ToTemporalTime(e2), T2 = dateTime(this), f2 = GetSlot(T2, n), y2 = GetSlot(T2, a), S2 = GetSlot(T2, i), w2 = GetSlot(this, u), g2 = GetSlot(o2, s), I2 = GetSlot(o2, l), D2 = GetSlot(o2, d), G2 = GetSlot(o2, m), v2 = GetSlot(o2, c), O2 = GetSlot(o2, h), C2 = GetSlot(this, p);
    return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(C2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, S2, g2, I2, D2, G2, v2, O2, w2), "compatible"), r), C2, w2);
  }
  withTimeZone(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZone(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, r), t2, GetSlot(this, u));
  }
  withCalendar(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendar(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, r), GetSlot(this, p), t2);
  }
  add(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("since", this, e2, t2);
  }
  round(t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === t2)
      throw new TypeError("options parameter is required");
    const o2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2), f2 = GetTemporalUnit(o2, "smallestUnit", "time", je, ["day"]), y2 = ToTemporalRoundingMode(o2, "halfExpand"), S2 = ToTemporalRoundingIncrement(o2, { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[f2], false), w2 = dateTime(this);
    let g2 = GetSlot(w2, n), I2 = GetSlot(w2, a), D2 = GetSlot(w2, i), G2 = GetSlot(w2, s), v2 = GetSlot(w2, l), O2 = GetSlot(w2, d), C2 = GetSlot(w2, m), E2 = GetSlot(w2, c), b2 = GetSlot(w2, h);
    const M2 = GetIntrinsic("%Temporal.PlainDateTime%"), R2 = GetSlot(this, p), Z2 = GetSlot(this, u), P2 = BuiltinTimeZoneGetInstantFor(R2, new M2(GetSlot(w2, n), GetSlot(w2, a), GetSlot(w2, i), 0, 0, 0, 0, 0, 0), "compatible"), F2 = AddZonedDateTime(P2, R2, Z2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0), Y2 = import_jsbi.default.subtract(F2, import_jsbi.default.BigInt(GetSlot(P2, r)));
    if (import_jsbi.default.equal(Y2, he))
      throw new RangeError("cannot round a ZonedDateTime in a calendar with zero-length days");
    ({ year: g2, month: I2, day: D2, hour: G2, minute: v2, second: O2, millisecond: C2, microsecond: E2, nanosecond: b2 } = RoundISODateTime(g2, I2, D2, G2, v2, O2, C2, E2, b2, S2, f2, y2, import_jsbi.default.toNumber(Y2)));
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(g2, I2, D2, G2, v2, O2, C2, E2, b2, "option", GetOffsetNanosecondsFor(R2, GetSlot(this, T)), R2, "compatible", "prefer", false), R2, GetSlot(this, u));
  }
  equals(t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalZonedDateTime(t2), n2 = GetSlot(this, r), a2 = GetSlot(o2, r);
    return !!import_jsbi.default.equal(import_jsbi.default.BigInt(n2), import_jsbi.default.BigInt(a2)) && (!!TimeZoneEquals(GetSlot(this, p), GetSlot(o2, p)) && CalendarEquals(GetSlot(this, u), GetSlot(o2, u)));
  }
  toString(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), { precision: r2, unit: o2, increment: n2 } = ToSecondsStringPrecision(t2), a2 = ToTemporalRoundingMode(t2, "trunc");
    return TemporalZonedDateTimeToString(this, r2, ToShowCalendarOption(t2), function ToShowTimeZoneNameOption(e3) {
      return GetOption(e3, "timeZoneName", ["auto", "never"], "auto");
    }(t2), function ToShowOffsetOption(e3) {
      return GetOption(e3, "offset", ["auto", "never"], "auto");
    }(t2), { unit: o2, increment: n2, roundingMode: a2 });
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return new ot(e2, t2).format(this);
  }
  toJSON() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalZonedDateTimeToString(this, "auto");
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
  }
  startOfDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetIntrinsic("%Temporal.PlainDateTime%"), o2 = GetSlot(this, u), s2 = new t2(GetSlot(e2, n), GetSlot(e2, a), GetSlot(e2, i), 0, 0, 0, 0, 0, 0, o2), l2 = GetSlot(this, p);
    return CreateTemporalZonedDateTime(GetSlot(BuiltinTimeZoneGetInstantFor(l2, s2, "compatible"), r), l2, o2);
  }
  toInstant() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, r));
  }
  toPlainDate() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(dateTime(this));
  }
  toPlainTime() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(dateTime(this));
  }
  toPlainDateTime() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return dateTime(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, u);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, u);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetSlot(this, p);
    return { calendar: GetSlot(this, u), isoDay: GetSlot(e2, i), isoHour: GetSlot(e2, s), isoMicrosecond: GetSlot(e2, c), isoMillisecond: GetSlot(e2, m), isoMinute: GetSlot(e2, l), isoMonth: GetSlot(e2, a), isoNanosecond: GetSlot(e2, h), isoSecond: GetSlot(e2, d), isoYear: GetSlot(e2, n), offset: BuiltinTimeZoneGetOffsetStringFor(t2, GetSlot(this, T)), timeZone: t2 };
  }
  static from(e2, t2) {
    const o2 = GetOptionsObject(t2);
    return IsTemporalZonedDateTime(e2) ? (ToTemporalOverflow(o2), ToTemporalDisambiguation(o2), ToTemporalOffset(o2, "reject"), CreateTemporalZonedDateTime(GetSlot(e2, r), GetSlot(e2, p), GetSlot(e2, u))) : ToTemporalZonedDateTime(e2, o2);
  }
  static compare(t2, o2) {
    const n2 = ToTemporalZonedDateTime(t2), a2 = ToTemporalZonedDateTime(o2), i2 = GetSlot(n2, r), s2 = GetSlot(a2, r);
    return import_jsbi.default.lessThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? -1 : import_jsbi.default.greaterThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? 1 : 0;
  }
};
function dateTime(e2) {
  return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(e2, p), GetSlot(e2, T), GetSlot(e2, u));
}
MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
var wt = Object.freeze({ __proto__: null, Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, Now: ft, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime });
var gt = [Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime];
for (const e2 of gt) {
  const t2 = Object.getOwnPropertyDescriptor(e2, "prototype");
  (t2.configurable || t2.enumerable || t2.writable) && (t2.configurable = false, t2.enumerable = false, t2.writable = false, Object.defineProperty(e2, "prototype", t2));
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/time.js
function sleep(durationInMillisecond) {
  return new Promise((resolve5) => setTimeout(resolve5, durationInMillisecond));
}
function getCurrentTimeInHighPrecision() {
  return wt.Now.instant().toString({ smallestUnit: "microseconds" });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/store/level-wrapper.js
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __await = function(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
};
var __asyncValues2 = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve5, reject) {
        v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve5, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve5({ value: v3, done: d2 });
    }, reject);
  }
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
};
function createLevelDatabase(location, options) {
  return __awaiter4(this, void 0, void 0, function* () {
    const { Level: Level3 } = yield import("level");
    return new Level3(location, Object.assign(Object.assign({}, options), { keyEncoding: "utf8" }));
  });
}
var LevelWrapper = class {
  /**
   * @param config.location - must be a directory path (relative or absolute) where `Level`` will
   * store its files, or in browsers, the name of the {@link https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase `IDBDatabase`}
   * to be opened.
   */
  constructor(config, db) {
    this.config = Object.assign({ createLevelDatabase }, config);
    this.db = db;
  }
  open() {
    return __awaiter4(this, void 0, void 0, function* () {
      yield this.createLevelDatabase();
      while (this.db.status === "opening" || this.db.status === "closing") {
        yield sleep(200);
      }
      if (this.db.status === "open") {
        return;
      }
      return this.db.open();
    });
  }
  close() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this.db) {
        return;
      }
      while (this.db.status === "opening" || this.db.status === "closing") {
        yield sleep(200);
      }
      if (this.db.status === "closed") {
        return;
      }
      return this.db.close();
    });
  }
  partition(name6) {
    return __awaiter4(this, void 0, void 0, function* () {
      yield this.createLevelDatabase();
      return new LevelWrapper(this.config, this.db.sublevel(name6, {
        keyEncoding: "utf8",
        valueEncoding: this.config.valueEncoding
      }));
    });
  }
  get(key, options) {
    var _a2;
    return __awaiter4(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.createLevelDatabase());
      try {
        const value = yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.db.get(String(key)));
        return value;
      } catch (error) {
        const e2 = error;
        if (e2.code === "LEVEL_NOT_FOUND") {
          return void 0;
        } else {
          throw error;
        }
      }
    });
  }
  has(key, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      return !!(yield this.get(key, options));
    });
  }
  keys(options) {
    var _a2, _b;
    return __asyncGenerator(this, arguments, function* keys_1() {
      var e_1, _c;
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      yield __await(abortOr(options === null || options === void 0 ? void 0 : options.signal, this.createLevelDatabase()));
      try {
        for (var _d = __asyncValues2(this.db.keys()), _e2; _e2 = yield __await(_d.next()), !_e2.done; ) {
          const key = _e2.value;
          (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
          yield yield __await(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_e2 && !_e2.done && (_c = _d.return))
            yield __await(_c.call(_d));
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
  }
  iterator(iteratorOptions, options) {
    var _a2, _b;
    return __asyncGenerator(this, arguments, function* iterator_1() {
      var e_2, _c;
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      yield __await(abortOr(options === null || options === void 0 ? void 0 : options.signal, this.createLevelDatabase()));
      try {
        for (var _d = __asyncValues2(this.db.iterator(iteratorOptions)), _e2; _e2 = yield __await(_d.next()), !_e2.done; ) {
          const entry = _e2.value;
          (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
          yield yield __await(entry);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_e2 && !_e2.done && (_c = _d.return))
            yield __await(_c.call(_d));
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    });
  }
  put(key, value, options) {
    var _a2;
    return __awaiter4(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.createLevelDatabase());
      return abortOr(options === null || options === void 0 ? void 0 : options.signal, this.db.put(String(key), value));
    });
  }
  delete(key, options) {
    var _a2;
    return __awaiter4(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.createLevelDatabase());
      return abortOr(options === null || options === void 0 ? void 0 : options.signal, this.db.del(String(key)));
    });
  }
  isEmpty(options) {
    var e_3, _a2;
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        for (var _b = __asyncValues2(this.keys(options)), _c; _c = yield _b.next(), !_c.done; ) {
          const _key = _c.value;
          return false;
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield _a2.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return true;
    });
  }
  clear() {
    return __awaiter4(this, void 0, void 0, function* () {
      yield this.createLevelDatabase();
      yield this.db.clear();
      yield this.compactUnderlyingStorage();
    });
  }
  batch(operations, options) {
    var _a2;
    return __awaiter4(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.createLevelDatabase());
      return abortOr(options === null || options === void 0 ? void 0 : options.signal, this.db.batch(operations));
    });
  }
  compactUnderlyingStorage(options) {
    var _a2, _b, _c;
    return __awaiter4(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.createLevelDatabase());
      const range = this.sublevelRange;
      if (!range) {
        return;
      }
      const root = this.root;
      if (root.db.supports.additionalMethods.compactRange) {
        return abortOr(options === null || options === void 0 ? void 0 : options.signal, (_c = (_b = root.db).compactRange) === null || _c === void 0 ? void 0 : _c.call(_b, ...range));
      }
    });
  }
  get sublevelRange() {
    const prefix = this.db.prefix;
    if (!prefix) {
      return void 0;
    }
    return [prefix, prefix.slice(0, -1) + String.fromCharCode(prefix.charCodeAt(prefix.length - 1) + 1)];
  }
  get root() {
    let db = this.db;
    for (const parent = db.db; parent && parent !== db; ) {
      db = parent;
    }
    return new LevelWrapper(this.config, db);
  }
  createLevelDatabase() {
    var _a2;
    return __awaiter4(this, void 0, void 0, function* () {
      (_a2 = this.db) !== null && _a2 !== void 0 ? _a2 : this.db = yield this.config.createLevelDatabase(this.config.location, {
        keyEncoding: "utf8",
        valueEncoding: this.config.valueEncoding
      });
    });
  }
  dump() {
    var e_4, _a2;
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this.db) {
        return;
      }
      try {
        for (var _b = __asyncValues2(this.db.iterator()), _c; _c = yield _b.next(), !_c.done; ) {
          const [key, value] = _c.value;
          console.debug(key, value);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield _a2.call(_b);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/store/blockstore-level.js
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues3 = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve5, reject) {
        v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve5, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve5({ value: v3, done: d2 });
    }, reject);
  }
};
var __await2 = function(v2) {
  return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
};
var __asyncGenerator2 = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
};
var BlockstoreLevel = class {
  constructor(config, db) {
    this.config = Object.assign({ createLevelDatabase }, config);
    this.db = db !== null && db !== void 0 ? db : new LevelWrapper(Object.assign(Object.assign({}, this.config), { valueEncoding: "binary" }));
  }
  open() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.db.open();
    });
  }
  close() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.db.close();
    });
  }
  partition(name6) {
    return __awaiter5(this, void 0, void 0, function* () {
      const db = yield this.db.partition(name6);
      return new BlockstoreLevel(Object.assign(Object.assign({}, this.config), { location: "" }), db);
    });
  }
  put(key, val, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.db.put(String(key), val, options);
    });
  }
  get(key, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const result = yield this.db.get(String(key), options);
      return result;
    });
  }
  has(key, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.db.has(String(key), options);
    });
  }
  delete(key, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.db.delete(String(key), options);
    });
  }
  isEmpty(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.db.isEmpty(options);
    });
  }
  putMany(source, options) {
    return __asyncGenerator2(this, arguments, function* putMany_1() {
      var e_1, _a2;
      try {
        for (var source_1 = __asyncValues3(source), source_1_1; source_1_1 = yield __await2(source_1.next()), !source_1_1.done; ) {
          const entry = source_1_1.value;
          yield __await2(this.put(entry.key, entry.value, options));
          yield yield __await2(entry);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (source_1_1 && !source_1_1.done && (_a2 = source_1.return))
            yield __await2(_a2.call(source_1));
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
  }
  getMany(source, options) {
    return __asyncGenerator2(this, arguments, function* getMany_1() {
      var e_2, _a2;
      try {
        for (var source_2 = __asyncValues3(source), source_2_1; source_2_1 = yield __await2(source_2.next()), !source_2_1.done; ) {
          const key = source_2_1.value;
          yield yield __await2(this.get(key, options));
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (source_2_1 && !source_2_1.done && (_a2 = source_2.return))
            yield __await2(_a2.call(source_2));
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    });
  }
  deleteMany(source, options) {
    return __asyncGenerator2(this, arguments, function* deleteMany_1() {
      var e_3, _a2;
      try {
        for (var source_3 = __asyncValues3(source), source_3_1; source_3_1 = yield __await2(source_3.next()), !source_3_1.done; ) {
          const key = source_3_1.value;
          yield __await2(this.delete(key, options));
          yield yield __await2(key);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (source_3_1 && !source_3_1.done && (_a2 = source_3.return))
            yield __await2(_a2.call(source_3));
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    });
  }
  /**
   * deletes all entries
   */
  clear() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.db.clear();
    });
  }
  batch() {
    throw new Error("not implemented");
  }
  query(_query, _options) {
    throw new Error("not implemented");
  }
  queryKeys(_query, _options) {
    throw new Error("not implemented");
  }
  dump() {
    var _a2, _b;
    return __awaiter5(this, void 0, void 0, function* () {
      console.group("db");
      yield (_b = (_a2 = this.db)["dump"]) === null || _b === void 0 ? void 0 : _b.call(_a2);
      console.groupEnd();
    });
  }
};

// ../../node_modules/ipfs-unixfs-exporter/esm/src/index.js
var import_err_code14 = __toESM(require_err_code(), 1);

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/vendor/varint.js
var encode_12 = encode9;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode9(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode9.bytes = offset - oldOffset + 1;
  return out;
}
var decode10 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$12) << shift : (b2 & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode10,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/varint.js
var decode11 = (data, offset = 0) => {
  const code9 = varint_default2.decode(data, offset);
  return [
    code9,
    varint_default2.decode.bytes
  ];
};
var encodeTo2 = (int, target, offset = 0) => {
  varint_default2.encode(int, target, offset);
  return target;
};
var encodingLength2 = (int) => {
  return varint_default2.encodingLength(int);
};

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bytes.js
var empty2 = new Uint8Array(0);
var equals4 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/hashes/digest.js
var create2 = (code9, digest3) => {
  const size = digest3.byteLength;
  const sizeOffset = encodingLength2(code9);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo2(code9, bytes, 0);
  encodeTo2(size, bytes, sizeOffset);
  bytes.set(digest3, digestOffset);
  return new Digest2(code9, size, digest3, bytes);
};
var decode12 = (multihash) => {
  const bytes = coerce2(multihash);
  const [code9, sizeOffset] = decode11(bytes);
  const [size, digestOffset] = decode11(bytes.subarray(sizeOffset));
  const digest3 = bytes.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code9, size, digest3, bytes);
};
var equals5 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals4(a2.bytes, b2.bytes);
  }
};
var Digest2 = class {
  constructor(code9, size, digest3, bytes) {
    this.code = code9;
    this.size = size;
    this.digest = digest3;
    this.bytes = bytes;
  }
};

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/vendor/base-x.js
function base3(ALPHABET, name6) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode17(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length5) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      pbegin++;
    }
    var it2 = size - length5;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length5) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length5;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode25(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name6} character`);
  }
  return {
    encode: encode17,
    decodeUnsafe,
    decode: decode25
  };
}
var src2 = base3;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base.js
var Encoder2 = class {
  constructor(name6, prefix, baseEncode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  constructor(name6, prefix, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder2({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec2 = class {
  constructor(name6, prefix, baseEncode, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name6, prefix, baseEncode);
    this.decoder = new Decoder2(name6, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from3 = ({ name: name6, prefix, encode: encode17, decode: decode25 }) => new Codec2(name6, prefix, encode17, decode25);
var baseX2 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
  const { encode: encode17, decode: decode25 } = base_x_default2(alphabet2, name6);
  return from3({
    prefix,
    name: name6,
    encode: encode17,
    decode: (text) => coerce2(decode25(text))
  });
};
var decode13 = (string2, alphabet2, bitsPerChar, name6) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes[alphabet2[i2]] = i2;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name6} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode10 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46482 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from3({
    prefix,
    name: name6,
    encode(input) {
      return encode10(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode13(input, alphabet2, bitsPerChar, name6);
    }
  });
};

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/bases/base32.js
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/cid.js
var CID2 = class {
  constructor(version4, code9, multihash, bytes) {
    this.code = code9;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code9, multihash } = this;
        if (code9 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID2.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code9, digest: digest3 } = this.multihash;
        const multihash = create2(code9, digest3);
        return CID2.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals5(this.multihash, other.multihash);
  }
  toString(base6) {
    const { bytes, version: version4, _baseCache } = this;
    switch (version4) {
      case 0:
        return toStringV02(bytes, _baseCache, base6 || base58btc2.encoder);
      default:
        return toStringV12(bytes, _baseCache, base6 || base322.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol2] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID2) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version4, code: code9, multihash, bytes } = value;
      return new CID2(version4, code9, multihash, bytes || encodeCID2(version4, code9, multihash.bytes));
    } else if (value != null && value[cidSymbol2] === true) {
      const { version: version4, multihash, code: code9 } = value;
      const digest3 = decode12(multihash);
      return CID2.create(version4, code9, digest3);
    } else {
      return null;
    }
  }
  static create(version4, code9, digest3) {
    if (typeof code9 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version4) {
      case 0: {
        if (code9 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new CID2(version4, code9, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID2(version4, code9, digest3.bytes);
        return new CID2(version4, code9, digest3, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest3) {
    return CID2.create(0, DAG_PB_CODE2, digest3);
  }
  static createV1(code9, digest3) {
    return CID2.create(1, code9, digest3);
  }
  static decode(bytes) {
    const [cid, remainder] = CID2.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = CID2.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest3 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID2.createV0(digest3) : CID2.createV1(specs.codec, digest3);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length5] = decode11(initialBytes.subarray(offset));
      offset += length5;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE2;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else if (version4 === 1) {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version4,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base6) {
    const [prefix, bytes] = parseCIDtoBytes2(source, base6);
    const cid = CID2.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes2 = (source, base6) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base6 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base6 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(source)
      ];
    }
    case base322.prefix: {
      const decoder = base6 || base322;
      return [
        base322.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base6 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base6.decode(source)
      ];
    }
  }
};
var toStringV02 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV12 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
var encodeCID2 = (version4, code9, multihash) => {
  const codeOffset = encodingLength2(version4);
  const hashOffset = codeOffset + encodingLength2(code9);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version4, bytes, 0);
  encodeTo2(code9, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message2) => {
  if (range.test(version)) {
    console.warn(message2);
  } else {
    throw new Error(message2);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
var import_err_code13 = __toESM(require_err_code(), 1);

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/vendor/varint.js
var encode_13 = encode11;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode11(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode11.bytes = offset - oldOffset + 1;
  return out;
}
var decode14 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$13) << shift : (b2 & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode14,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/varint.js
var decode15 = (data, offset = 0) => {
  const code9 = varint_default3.decode(data, offset);
  return [
    code9,
    varint_default3.decode.bytes
  ];
};
var encodeTo3 = (int, target, offset = 0) => {
  varint_default3.encode(int, target, offset);
  return target;
};
var encodingLength3 = (int) => {
  return varint_default3.encodingLength(int);
};

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bytes.js
var empty3 = new Uint8Array(0);
var equals6 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce3 = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/hashes/digest.js
var create3 = (code9, digest3) => {
  const size = digest3.byteLength;
  const sizeOffset = encodingLength3(code9);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo3(code9, bytes, 0);
  encodeTo3(size, bytes, sizeOffset);
  bytes.set(digest3, digestOffset);
  return new Digest3(code9, size, digest3, bytes);
};
var decode16 = (multihash) => {
  const bytes = coerce3(multihash);
  const [code9, sizeOffset] = decode15(bytes);
  const [size, digestOffset] = decode15(bytes.subarray(sizeOffset));
  const digest3 = bytes.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code9, size, digest3, bytes);
};
var equals7 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals6(a2.bytes, b2.bytes);
  }
};
var Digest3 = class {
  constructor(code9, size, digest3, bytes) {
    this.code = code9;
    this.size = size;
    this.digest = digest3;
    this.bytes = bytes;
  }
};

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/vendor/base-x.js
function base4(ALPHABET, name6) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode17(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length5) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      pbegin++;
    }
    var it2 = size - length5;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length5) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length5;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode25(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name6} character`);
  }
  return {
    encode: encode17,
    decodeUnsafe,
    decode: decode25
  };
}
var src3 = base4;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base.js
var Encoder3 = class {
  constructor(name6, prefix, baseEncode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  constructor(name6, prefix, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or3 = (left, right) => new ComposedDecoder3({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec3 = class {
  constructor(name6, prefix, baseEncode, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name6, prefix, baseEncode);
    this.decoder = new Decoder3(name6, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from4 = ({ name: name6, prefix, encode: encode17, decode: decode25 }) => new Codec3(name6, prefix, encode17, decode25);
var baseX3 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
  const { encode: encode17, decode: decode25 } = base_x_default3(alphabet2, name6);
  return from4({
    prefix,
    name: name6,
    encode: encode17,
    decode: (text) => coerce3(decode25(text))
  });
};
var decode17 = (string2, alphabet2, bitsPerChar, name6) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes[alphabet2[i2]] = i2;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name6} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode12 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46483 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from4({
    prefix,
    name: name6,
    encode(input) {
      return encode12(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode17(input, alphabet2, bitsPerChar, name6);
    }
  });
};

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base58.js
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/bases/base32.js
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/@ipld/dag-pb/node_modules/multiformats/esm/src/cid.js
var CID3 = class {
  constructor(version4, code9, multihash, bytes) {
    this.code = code9;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden2,
      byteLength: hidden2,
      code: readonly2,
      version: readonly2,
      multihash: readonly2,
      bytes: readonly2,
      _baseCache: hidden2,
      asCID: hidden2
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code9, multihash } = this;
        if (code9 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID3.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code9, digest: digest3 } = this.multihash;
        const multihash = create3(code9, digest3);
        return CID3.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals7(this.multihash, other.multihash);
  }
  toString(base6) {
    const { bytes, version: version4, _baseCache } = this;
    switch (version4) {
      case 0:
        return toStringV03(bytes, _baseCache, base6 || base58btc3.encoder);
      default:
        return toStringV13(bytes, _baseCache, base6 || base323.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
    return !!(value && (value[cidSymbol3] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID3) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version4, code: code9, multihash, bytes } = value;
      return new CID3(version4, code9, multihash, bytes || encodeCID3(version4, code9, multihash.bytes));
    } else if (value != null && value[cidSymbol3] === true) {
      const { version: version4, multihash, code: code9 } = value;
      const digest3 = decode16(multihash);
      return CID3.create(version4, code9, digest3);
    } else {
      return null;
    }
  }
  static create(version4, code9, digest3) {
    if (typeof code9 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version4) {
      case 0: {
        if (code9 !== DAG_PB_CODE3) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
        } else {
          return new CID3(version4, code9, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID3(version4, code9, digest3.bytes);
        return new CID3(version4, code9, digest3, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest3) {
    return CID3.create(0, DAG_PB_CODE3, digest3);
  }
  static createV1(code9, digest3) {
    return CID3.create(1, code9, digest3);
  }
  static decode(bytes) {
    const [cid, remainder] = CID3.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = CID3.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest3 = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID3.createV0(digest3) : CID3.createV1(specs.codec, digest3);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length5] = decode15(initialBytes.subarray(offset));
      offset += length5;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE3;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else if (version4 === 1) {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version4,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base6) {
    const [prefix, bytes] = parseCIDtoBytes3(source, base6);
    const cid = CID3.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes3 = (source, base6) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base6 || base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base6 || base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(source)
      ];
    }
    case base323.prefix: {
      const decoder = base6 || base323;
      return [
        base323.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base6 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base6.decode(source)
      ];
    }
  }
};
var toStringV03 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV13 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
var encodeCID3 = (version4, code9, multihash) => {
  const codeOffset = encodingLength3(version4);
  const hashOffset = codeOffset + encodingLength3(code9);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version4, bytes, 0);
  encodeTo3(code9, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");
var readonly2 = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden2 = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version2 = "0.0.0-dev";
var deprecate2 = (range, message2) => {
  if (range.test(version2)) {
    console.warn(message2);
  } else {
    throw new Error(message2);
  }
};
var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/@ipld/dag-pb/esm/src/pb-decode.js
var textDecoder4 = new TextDecoder();
function decodeVarint2(bytes, offset) {
  let v2 = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b2 = bytes[offset++];
    v2 += shift < 28 ? (b2 & 127) << shift : (b2 & 127) * 2 ** shift;
    if (b2 < 128) {
      break;
    }
  }
  return [
    v2,
    offset
  ];
}
function decodeBytes2(bytes, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint2(bytes, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey2(bytes, index) {
  let wire;
  [wire, index] = decodeVarint2(bytes, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink2(bytes) {
  const link = {};
  const l2 = bytes.length;
  let index = 0;
  while (index < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey2(bytes, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes2(bytes, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes2(bytes, index);
      link.Name = textDecoder4.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint2(bytes, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l2) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode2(bytes) {
  const l2 = bytes.length;
  let index = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey2(bytes, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes2(bytes, index);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index] = decodeBytes2(bytes, index);
      links2.push(decodeLink2(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l2) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}

// ../../node_modules/@ipld/dag-pb/esm/src/pb-encode.js
var textEncoder5 = new TextEncoder();
var maxInt322 = 2 ** 32;
var maxUInt322 = 2 ** 31;

// ../../node_modules/@ipld/dag-pb/esm/src/util.js
var textEncoder6 = new TextEncoder();

// ../../node_modules/@ipld/dag-pb/esm/src/index.js
var code5 = 112;
function decode18(bytes) {
  const pbn = decodeNode2(bytes);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l2) => {
      const link = {};
      try {
        link.Hash = CID3.decode(l2.Hash);
      } catch (e2) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  return node;
}

// ../../node_modules/ipfs-unixfs-exporter/node_modules/@ipld/dag-cbor/esm/index.js
var CID_CBOR_TAG2 = 42;
function cidDecoder2(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID2.decode(bytes.subarray(1));
}
var decodeOptions2 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions2.tags[CID_CBOR_TAG2] = cidDecoder2;
var code6 = 113;
var decode19 = (data) => decode(data, decodeOptions2);

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/codecs/raw.js
var code7 = 85;

// ../../node_modules/ipfs-unixfs-exporter/node_modules/multiformats/esm/src/hashes/identity.js
var code8 = 0;
var name5 = "identity";
var encode13 = coerce2;
var digest2 = (input) => create2(code8, encode13(input));
var identity3 = {
  code: code8,
  name: name5,
  encode: encode13,
  digest: digest2
};

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
var import_err_code9 = __toESM(require_err_code(), 1);

// ../../node_modules/ipfs-unixfs/esm/src/index.js
var import_err_code6 = __toESM(require_err_code(), 1);

// ../../node_modules/ipfs-unixfs/esm/src/unixfs.js
var import_minimal2 = __toESM(require_minimal3(), 1);
var $Reader = import_minimal2.default.Reader;
var $Writer = import_minimal2.default.Writer;
var $util = import_minimal2.default.util;
var $root = import_minimal2.default.roots["ipfs-unixfs"] || (import_minimal2.default.roots["ipfs-unixfs"] = {});
var Data2 = $root.Data = (() => {
  function Data3(p2) {
    this.blocksizes = [];
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  Data3.prototype.Type = 0;
  Data3.prototype.Data = $util.newBuffer([]);
  Data3.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data3.prototype.blocksizes = $util.emptyArray;
  Data3.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data3.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data3.prototype.mode = 0;
  Data3.prototype.mtime = null;
  Data3.encode = function encode17(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    w2.uint32(8).int32(m2.Type);
    if (m2.Data != null && Object.hasOwnProperty.call(m2, "Data"))
      w2.uint32(18).bytes(m2.Data);
    if (m2.filesize != null && Object.hasOwnProperty.call(m2, "filesize"))
      w2.uint32(24).uint64(m2.filesize);
    if (m2.blocksizes != null && m2.blocksizes.length) {
      for (var i2 = 0; i2 < m2.blocksizes.length; ++i2)
        w2.uint32(32).uint64(m2.blocksizes[i2]);
    }
    if (m2.hashType != null && Object.hasOwnProperty.call(m2, "hashType"))
      w2.uint32(40).uint64(m2.hashType);
    if (m2.fanout != null && Object.hasOwnProperty.call(m2, "fanout"))
      w2.uint32(48).uint64(m2.fanout);
    if (m2.mode != null && Object.hasOwnProperty.call(m2, "mode"))
      w2.uint32(56).uint32(m2.mode);
    if (m2.mtime != null && Object.hasOwnProperty.call(m2, "mtime"))
      $root.UnixTime.encode(m2.mtime, w2.uint32(66).fork()).ldelim();
    return w2;
  };
  Data3.decode = function decode25(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Data();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Type = r2.int32();
          break;
        case 2:
          m2.Data = r2.bytes();
          break;
        case 3:
          m2.filesize = r2.uint64();
          break;
        case 4:
          if (!(m2.blocksizes && m2.blocksizes.length))
            m2.blocksizes = [];
          if ((t2 & 7) === 2) {
            var c22 = r2.uint32() + r2.pos;
            while (r2.pos < c22)
              m2.blocksizes.push(r2.uint64());
          } else
            m2.blocksizes.push(r2.uint64());
          break;
        case 5:
          m2.hashType = r2.uint64();
          break;
        case 6:
          m2.fanout = r2.uint64();
          break;
        case 7:
          m2.mode = r2.uint32();
          break;
        case 8:
          m2.mtime = $root.UnixTime.decode(r2, r2.uint32());
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
    return m2;
  };
  Data3.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.Data)
      return d2;
    var m2 = new $root.Data();
    switch (d2.Type) {
      case "Raw":
      case 0:
        m2.Type = 0;
        break;
      case "Directory":
      case 1:
        m2.Type = 1;
        break;
      case "File":
      case 2:
        m2.Type = 2;
        break;
      case "Metadata":
      case 3:
        m2.Type = 3;
        break;
      case "Symlink":
      case 4:
        m2.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m2.Type = 5;
        break;
    }
    if (d2.Data != null) {
      if (typeof d2.Data === "string")
        $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
      else if (d2.Data.length)
        m2.Data = d2.Data;
    }
    if (d2.filesize != null) {
      if ($util.Long)
        (m2.filesize = $util.Long.fromValue(d2.filesize)).unsigned = true;
      else if (typeof d2.filesize === "string")
        m2.filesize = parseInt(d2.filesize, 10);
      else if (typeof d2.filesize === "number")
        m2.filesize = d2.filesize;
      else if (typeof d2.filesize === "object")
        m2.filesize = new $util.LongBits(d2.filesize.low >>> 0, d2.filesize.high >>> 0).toNumber(true);
    }
    if (d2.blocksizes) {
      if (!Array.isArray(d2.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m2.blocksizes = [];
      for (var i2 = 0; i2 < d2.blocksizes.length; ++i2) {
        if ($util.Long)
          (m2.blocksizes[i2] = $util.Long.fromValue(d2.blocksizes[i2])).unsigned = true;
        else if (typeof d2.blocksizes[i2] === "string")
          m2.blocksizes[i2] = parseInt(d2.blocksizes[i2], 10);
        else if (typeof d2.blocksizes[i2] === "number")
          m2.blocksizes[i2] = d2.blocksizes[i2];
        else if (typeof d2.blocksizes[i2] === "object")
          m2.blocksizes[i2] = new $util.LongBits(d2.blocksizes[i2].low >>> 0, d2.blocksizes[i2].high >>> 0).toNumber(true);
      }
    }
    if (d2.hashType != null) {
      if ($util.Long)
        (m2.hashType = $util.Long.fromValue(d2.hashType)).unsigned = true;
      else if (typeof d2.hashType === "string")
        m2.hashType = parseInt(d2.hashType, 10);
      else if (typeof d2.hashType === "number")
        m2.hashType = d2.hashType;
      else if (typeof d2.hashType === "object")
        m2.hashType = new $util.LongBits(d2.hashType.low >>> 0, d2.hashType.high >>> 0).toNumber(true);
    }
    if (d2.fanout != null) {
      if ($util.Long)
        (m2.fanout = $util.Long.fromValue(d2.fanout)).unsigned = true;
      else if (typeof d2.fanout === "string")
        m2.fanout = parseInt(d2.fanout, 10);
      else if (typeof d2.fanout === "number")
        m2.fanout = d2.fanout;
      else if (typeof d2.fanout === "object")
        m2.fanout = new $util.LongBits(d2.fanout.low >>> 0, d2.fanout.high >>> 0).toNumber(true);
    }
    if (d2.mode != null) {
      m2.mode = d2.mode >>> 0;
    }
    if (d2.mtime != null) {
      if (typeof d2.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m2.mtime = $root.UnixTime.fromObject(d2.mtime);
    }
    return m2;
  };
  Data3.toObject = function toObject(m2, o2) {
    if (!o2)
      o2 = {};
    var d2 = {};
    if (o2.arrays || o2.defaults) {
      d2.blocksizes = [];
    }
    if (o2.defaults) {
      d2.Type = o2.enums === String ? "Raw" : 0;
      if (o2.bytes === String)
        d2.Data = "";
      else {
        d2.Data = [];
        if (o2.bytes !== Array)
          d2.Data = $util.newBuffer(d2.Data);
      }
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d2.filesize = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
      } else
        d2.filesize = o2.longs === String ? "0" : 0;
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d2.hashType = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
      } else
        d2.hashType = o2.longs === String ? "0" : 0;
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, true);
        d2.fanout = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
      } else
        d2.fanout = o2.longs === String ? "0" : 0;
      d2.mode = 0;
      d2.mtime = null;
    }
    if (m2.Type != null && m2.hasOwnProperty("Type")) {
      d2.Type = o2.enums === String ? $root.Data.DataType[m2.Type] : m2.Type;
    }
    if (m2.Data != null && m2.hasOwnProperty("Data")) {
      d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
    }
    if (m2.filesize != null && m2.hasOwnProperty("filesize")) {
      if (typeof m2.filesize === "number")
        d2.filesize = o2.longs === String ? String(m2.filesize) : m2.filesize;
      else
        d2.filesize = o2.longs === String ? $util.Long.prototype.toString.call(m2.filesize) : o2.longs === Number ? new $util.LongBits(m2.filesize.low >>> 0, m2.filesize.high >>> 0).toNumber(true) : m2.filesize;
    }
    if (m2.blocksizes && m2.blocksizes.length) {
      d2.blocksizes = [];
      for (var j2 = 0; j2 < m2.blocksizes.length; ++j2) {
        if (typeof m2.blocksizes[j2] === "number")
          d2.blocksizes[j2] = o2.longs === String ? String(m2.blocksizes[j2]) : m2.blocksizes[j2];
        else
          d2.blocksizes[j2] = o2.longs === String ? $util.Long.prototype.toString.call(m2.blocksizes[j2]) : o2.longs === Number ? new $util.LongBits(m2.blocksizes[j2].low >>> 0, m2.blocksizes[j2].high >>> 0).toNumber(true) : m2.blocksizes[j2];
      }
    }
    if (m2.hashType != null && m2.hasOwnProperty("hashType")) {
      if (typeof m2.hashType === "number")
        d2.hashType = o2.longs === String ? String(m2.hashType) : m2.hashType;
      else
        d2.hashType = o2.longs === String ? $util.Long.prototype.toString.call(m2.hashType) : o2.longs === Number ? new $util.LongBits(m2.hashType.low >>> 0, m2.hashType.high >>> 0).toNumber(true) : m2.hashType;
    }
    if (m2.fanout != null && m2.hasOwnProperty("fanout")) {
      if (typeof m2.fanout === "number")
        d2.fanout = o2.longs === String ? String(m2.fanout) : m2.fanout;
      else
        d2.fanout = o2.longs === String ? $util.Long.prototype.toString.call(m2.fanout) : o2.longs === Number ? new $util.LongBits(m2.fanout.low >>> 0, m2.fanout.high >>> 0).toNumber(true) : m2.fanout;
    }
    if (m2.mode != null && m2.hasOwnProperty("mode")) {
      d2.mode = m2.mode;
    }
    if (m2.mtime != null && m2.hasOwnProperty("mtime")) {
      d2.mtime = $root.UnixTime.toObject(m2.mtime, o2);
    }
    return d2;
  };
  Data3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
  };
  Data3.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data3;
})();
var UnixTime2 = $root.UnixTime = (() => {
  function UnixTime3(p2) {
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  UnixTime3.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime3.prototype.FractionalNanoseconds = 0;
  UnixTime3.encode = function encode17(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    w2.uint32(8).int64(m2.Seconds);
    if (m2.FractionalNanoseconds != null && Object.hasOwnProperty.call(m2, "FractionalNanoseconds"))
      w2.uint32(21).fixed32(m2.FractionalNanoseconds);
    return w2;
  };
  UnixTime3.decode = function decode25(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.UnixTime();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.Seconds = r2.int64();
          break;
        case 2:
          m2.FractionalNanoseconds = r2.fixed32();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    if (!m2.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m2 });
    return m2;
  };
  UnixTime3.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.UnixTime)
      return d2;
    var m2 = new $root.UnixTime();
    if (d2.Seconds != null) {
      if ($util.Long)
        (m2.Seconds = $util.Long.fromValue(d2.Seconds)).unsigned = false;
      else if (typeof d2.Seconds === "string")
        m2.Seconds = parseInt(d2.Seconds, 10);
      else if (typeof d2.Seconds === "number")
        m2.Seconds = d2.Seconds;
      else if (typeof d2.Seconds === "object")
        m2.Seconds = new $util.LongBits(d2.Seconds.low >>> 0, d2.Seconds.high >>> 0).toNumber();
    }
    if (d2.FractionalNanoseconds != null) {
      m2.FractionalNanoseconds = d2.FractionalNanoseconds >>> 0;
    }
    return m2;
  };
  UnixTime3.toObject = function toObject(m2, o2) {
    if (!o2)
      o2 = {};
    var d2 = {};
    if (o2.defaults) {
      if ($util.Long) {
        var n2 = new $util.Long(0, 0, false);
        d2.Seconds = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
      } else
        d2.Seconds = o2.longs === String ? "0" : 0;
      d2.FractionalNanoseconds = 0;
    }
    if (m2.Seconds != null && m2.hasOwnProperty("Seconds")) {
      if (typeof m2.Seconds === "number")
        d2.Seconds = o2.longs === String ? String(m2.Seconds) : m2.Seconds;
      else
        d2.Seconds = o2.longs === String ? $util.Long.prototype.toString.call(m2.Seconds) : o2.longs === Number ? new $util.LongBits(m2.Seconds.low >>> 0, m2.Seconds.high >>> 0).toNumber() : m2.Seconds;
    }
    if (m2.FractionalNanoseconds != null && m2.hasOwnProperty("FractionalNanoseconds")) {
      d2.FractionalNanoseconds = m2.FractionalNanoseconds;
    }
    return d2;
  };
  UnixTime3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
  };
  return UnixTime3;
})();
var Metadata2 = $root.Metadata = (() => {
  function Metadata3(p2) {
    if (p2) {
      for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
        if (p2[ks[i2]] != null)
          this[ks[i2]] = p2[ks[i2]];
    }
  }
  Metadata3.prototype.MimeType = "";
  Metadata3.encode = function encode17(m2, w2) {
    if (!w2)
      w2 = $Writer.create();
    if (m2.MimeType != null && Object.hasOwnProperty.call(m2, "MimeType"))
      w2.uint32(10).string(m2.MimeType);
    return w2;
  };
  Metadata3.decode = function decode25(r2, l2) {
    if (!(r2 instanceof $Reader))
      r2 = $Reader.create(r2);
    var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Metadata();
    while (r2.pos < c2) {
      var t2 = r2.uint32();
      switch (t2 >>> 3) {
        case 1:
          m2.MimeType = r2.string();
          break;
        default:
          r2.skipType(t2 & 7);
          break;
      }
    }
    return m2;
  };
  Metadata3.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.Metadata)
      return d2;
    var m2 = new $root.Metadata();
    if (d2.MimeType != null) {
      m2.MimeType = String(d2.MimeType);
    }
    return m2;
  };
  Metadata3.toObject = function toObject(m2, o2) {
    if (!o2)
      o2 = {};
    var d2 = {};
    if (o2.defaults) {
      d2.MimeType = "";
    }
    if (m2.MimeType != null && m2.hasOwnProperty("MimeType")) {
      d2.MimeType = m2.MimeType;
    }
    return d2;
  };
  Metadata3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
  };
  return Metadata3;
})();

// ../../node_modules/ipfs-unixfs/esm/src/index.js
var PBData = Data2;
var types2 = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
var dirTypes2 = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE2 = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE2 = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code6.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var UnixFS2 = class {
  static unmarshal(marshaled) {
    const message2 = PBData.decode(marshaled);
    const decoded = PBData.toObject(message2, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new UnixFS2({
      type: types2[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = { type: "file" }) {
    const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
    if (type && !types2.includes(type)) {
      throw (0, import_err_code6.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE2 : DEFAULT_FILE_MODE2;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes2.includes(this.type));
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code6.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE2 && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE2 && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
};

// ../../node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js
var import_hamt_sharding2 = __toESM(require_src2(), 1);

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bytes.js
var bytes_exports3 = {};
__export(bytes_exports3, {
  coerce: () => coerce4,
  empty: () => empty4,
  equals: () => equals8,
  fromHex: () => fromHex2,
  fromString: () => fromString4,
  isBinary: () => isBinary2,
  toHex: () => toHex2,
  toString: () => toString3
});
var empty4 = new Uint8Array(0);
var toHex2 = (d2) => d2.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
var fromHex2 = (hex) => {
  const hexes3 = hex.match(/../g);
  return hexes3 ? new Uint8Array(hexes3.map((b2) => parseInt(b2, 16))) : empty4;
};
var equals8 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce4 = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var isBinary2 = (o2) => o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
var fromString4 = (str) => new TextEncoder().encode(str);
var toString3 = (b2) => new TextDecoder().decode(b2);

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/vendor/varint.js
var encode_14 = encode14;
var MSB4 = 128;
var REST4 = 127;
var MSBALL4 = ~REST4;
var INT4 = Math.pow(2, 31);
function encode14(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT4) {
    out[offset++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode14.bytes = offset - oldOffset + 1;
  return out;
}
var decode20 = read4;
var MSB$14 = 128;
var REST$14 = 127;
function read4(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$14) << shift : (b2 & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$14);
  read4.bytes = counter - offset;
  return res;
}
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var N84 = Math.pow(2, 56);
var N94 = Math.pow(2, 63);
var length4 = function(value) {
  return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
};
var varint4 = {
  encode: encode_14,
  decode: decode20,
  encodingLength: length4
};
var _brrp_varint4 = varint4;
var varint_default4 = _brrp_varint4;

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/varint.js
var decode21 = (data, offset = 0) => {
  const code9 = varint_default4.decode(data, offset);
  return [
    code9,
    varint_default4.decode.bytes
  ];
};
var encodeTo4 = (int, target, offset = 0) => {
  varint_default4.encode(int, target, offset);
  return target;
};
var encodingLength4 = (int) => {
  return varint_default4.encodingLength(int);
};

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/hashes/digest.js
var create4 = (code9, digest3) => {
  const size = digest3.byteLength;
  const sizeOffset = encodingLength4(code9);
  const digestOffset = sizeOffset + encodingLength4(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo4(code9, bytes, 0);
  encodeTo4(size, bytes, sizeOffset);
  bytes.set(digest3, digestOffset);
  return new Digest4(code9, size, digest3, bytes);
};
var decode22 = (multihash) => {
  const bytes = coerce4(multihash);
  const [code9, sizeOffset] = decode21(bytes);
  const [size, digestOffset] = decode21(bytes.subarray(sizeOffset));
  const digest3 = bytes.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest4(code9, size, digest3, bytes);
};
var equals9 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals8(a2.bytes, b2.bytes);
  }
};
var Digest4 = class {
  constructor(code9, size, digest3, bytes) {
    this.code = code9;
    this.size = size;
    this.digest = digest3;
    this.bytes = bytes;
  }
};

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/hashes/hasher.js
var from5 = ({ name: name6, code: code9, encode: encode17 }) => new Hasher2(name6, code9, encode17);
var Hasher2 = class {
  constructor(name6, code9, encode17) {
    this.name = name6;
    this.code = code9;
    this.encode = encode17;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest3) => create4(this.code, digest3));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/vendor/base-x.js
function base5(ALPHABET, name6) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode17(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length5) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      pbegin++;
    }
    var it2 = size - length5;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length5) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length5;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode25(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name6} character`);
  }
  return {
    encode: encode17,
    decodeUnsafe,
    decode: decode25
  };
}
var src4 = base5;
var _brrp__multiformats_scope_baseX4 = src4;
var base_x_default4 = _brrp__multiformats_scope_baseX4;

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base.js
var Encoder4 = class {
  constructor(name6, prefix, baseEncode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  constructor(name6, prefix, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder4 = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or4(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or4 = (left, right) => new ComposedDecoder4({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec4 = class {
  constructor(name6, prefix, baseEncode, baseDecode) {
    this.name = name6;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name6, prefix, baseEncode);
    this.decoder = new Decoder4(name6, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from6 = ({ name: name6, prefix, encode: encode17, decode: decode25 }) => new Codec4(name6, prefix, encode17, decode25);
var baseX4 = ({ prefix, name: name6, alphabet: alphabet2 }) => {
  const { encode: encode17, decode: decode25 } = base_x_default4(alphabet2, name6);
  return from6({
    prefix,
    name: name6,
    encode: encode17,
    decode: (text) => coerce4(decode25(text))
  });
};
var decode23 = (string2, alphabet2, bitsPerChar, name6) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes[alphabet2[i2]] = i2;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name6} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode15 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46484 = ({ name: name6, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from6({
    prefix,
    name: name6,
    encode(input) {
      return encode15(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode23(input, alphabet2, bitsPerChar, name6);
    }
  });
};

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base58.js
var base58btc4 = baseX4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr4 = baseX4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/bases/base32.js
var base324 = rfc46484({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper4 = rfc46484({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad4 = rfc46484({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper4 = rfc46484({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex4 = rfc46484({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper4 = rfc46484({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad4 = rfc46484({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper4 = rfc46484({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z4 = rfc46484({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/@multiformats/murmur3/node_modules/multiformats/esm/src/cid.js
var CID4 = class {
  constructor(version4, code9, multihash, bytes) {
    this.code = code9;
    this.version = version4;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden3,
      byteLength: hidden3,
      code: readonly3,
      version: readonly3,
      multihash: readonly3,
      bytes: readonly3,
      _baseCache: hidden3,
      asCID: hidden3
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code9, multihash } = this;
        if (code9 !== DAG_PB_CODE4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID4.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code9, digest: digest3 } = this.multihash;
        const multihash = create4(code9, digest3);
        return CID4.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals9(this.multihash, other.multihash);
  }
  toString(base6) {
    const { bytes, version: version4, _baseCache } = this;
    switch (version4) {
      case 0:
        return toStringV04(bytes, _baseCache, base6 || base58btc4.encoder);
      default:
        return toStringV14(bytes, _baseCache, base6 || base324.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate3(/^0\.0/, IS_CID_DEPRECATION3);
    return !!(value && (value[cidSymbol4] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID4) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version4, code: code9, multihash, bytes } = value;
      return new CID4(version4, code9, multihash, bytes || encodeCID4(version4, code9, multihash.bytes));
    } else if (value != null && value[cidSymbol4] === true) {
      const { version: version4, multihash, code: code9 } = value;
      const digest3 = decode22(multihash);
      return CID4.create(version4, code9, digest3);
    } else {
      return null;
    }
  }
  static create(version4, code9, digest3) {
    if (typeof code9 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version4) {
      case 0: {
        if (code9 !== DAG_PB_CODE4) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`);
        } else {
          return new CID4(version4, code9, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID4(version4, code9, digest3.bytes);
        return new CID4(version4, code9, digest3, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest3) {
    return CID4.create(0, DAG_PB_CODE4, digest3);
  }
  static createV1(code9, digest3) {
    return CID4.create(1, code9, digest3);
  }
  static decode(bytes) {
    const [cid, remainder] = CID4.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = CID4.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce4(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest3 = new Digest4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID4.createV0(digest3) : CID4.createV1(specs.codec, digest3);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length5] = decode21(initialBytes.subarray(offset));
      offset += length5;
      return i2;
    };
    let version4 = next();
    let codec = DAG_PB_CODE4;
    if (version4 === 18) {
      version4 = 0;
      offset = 0;
    } else if (version4 === 1) {
      codec = next();
    }
    if (version4 !== 0 && version4 !== 1) {
      throw new RangeError(`Invalid CID version ${version4}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version4,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base6) {
    const [prefix, bytes] = parseCIDtoBytes4(source, base6);
    const cid = CID4.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes4 = (source, base6) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base6 || base58btc4;
      return [
        base58btc4.prefix,
        decoder.decode(`${base58btc4.prefix}${source}`)
      ];
    }
    case base58btc4.prefix: {
      const decoder = base6 || base58btc4;
      return [
        base58btc4.prefix,
        decoder.decode(source)
      ];
    }
    case base324.prefix: {
      const decoder = base6 || base324;
      return [
        base324.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base6 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base6.decode(source)
      ];
    }
  }
};
var toStringV04 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  if (prefix !== base58btc4.prefix) {
    throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV14 = (bytes, cache2, base6) => {
  const { prefix } = base6;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base6.encode(bytes);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE4 = 112;
var SHA_256_CODE4 = 18;
var encodeCID4 = (version4, code9, multihash) => {
  const codeOffset = encodingLength4(version4);
  const hashOffset = codeOffset + encodingLength4(code9);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo4(version4, bytes, 0);
  encodeTo4(code9, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");
var readonly3 = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden3 = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version3 = "0.0.0-dev";
var deprecate3 = (range, message2) => {
  if (range.test(version3)) {
    console.warn(message2);
  } else {
    throw new Error(message2);
  }
};
var IS_CID_DEPRECATION3 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/@multiformats/murmur3/esm/index.js
var import_murmurhash3js_revisited2 = __toESM(require_murmurhash3js_revisited(), 1);
function fromNumberTo32BitBuf2(number) {
  const bytes = new Array(4);
  for (let i2 = 0; i2 < 4; i2++) {
    bytes[i2] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes);
}
var murmur3322 = from5({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf2(import_murmurhash3js_revisited2.default.x86.hash32(input))
});
var murmur31282 = from5({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports3.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input))
});

// ../../node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js
var hashFn = async function(buf2) {
  return (await murmur31282.encode(buf2)).slice(0, 8).reverse();
};
var addLinksToHamtBucket = (links2, bucket, rootBucket) => {
  return Promise.all(links2.map((link) => {
    if (link.Name == null) {
      throw new Error("Unexpected Link without a Name");
    }
    if (link.Name.length === 2) {
      const pos = parseInt(link.Name, 16);
      return bucket._putObjectAt(pos, new import_hamt_sharding2.Bucket({
        hash: rootBucket._options.hash,
        bits: rootBucket._options.bits
      }, bucket, pos));
    }
    return rootBucket.put(link.Name.substring(2), true);
  }));
};
var toPrefix = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var toBucketPath = (position) => {
  let bucket = position.bucket;
  const path = [];
  while (bucket._parent) {
    path.push(bucket);
    bucket = bucket._parent;
  }
  path.push(bucket);
  return path.reverse();
};
var findShardCid = async (node, name6, blockstore, context, options) => {
  if (!context) {
    const rootBucket = (0, import_hamt_sharding2.createHAMT)({ hashFn });
    context = {
      rootBucket,
      hamtDepth: 1,
      lastBucket: rootBucket
    };
  }
  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
  const position = await context.rootBucket._findNewBucketAndPos(name6);
  let prefix = toPrefix(position.pos);
  const bucketPath = toBucketPath(position);
  if (bucketPath.length > context.hamtDepth) {
    context.lastBucket = bucketPath[context.hamtDepth];
    prefix = toPrefix(context.lastBucket._posAtParent);
  }
  const link = node.Links.find((link2) => {
    if (link2.Name == null) {
      return false;
    }
    const entryPrefix = link2.Name.substring(0, 2);
    const entryName = link2.Name.substring(2);
    if (entryPrefix !== prefix) {
      return false;
    }
    if (entryName && entryName !== name6) {
      return false;
    }
    return true;
  });
  if (!link) {
    return null;
  }
  if (link.Name != null && link.Name.substring(2) === name6) {
    return link.Hash;
  }
  context.hamtDepth++;
  const block = await blockstore.get(link.Hash, options);
  node = decode18(block);
  return findShardCid(node, name6, blockstore, context, options);
};
var find_cid_in_shard_default = findShardCid;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.slice(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.slice(requestedStart - blockStart);
  }
  return block;
}
var extract_data_from_block_default = extractDataFromBlock;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js
var import_err_code7 = __toESM(require_err_code(), 1);
var validateOffsetAndLength = (size, offset, length5) => {
  if (!offset) {
    offset = 0;
  }
  if (offset < 0) {
    throw (0, import_err_code7.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset > size) {
    throw (0, import_err_code7.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  if (!length5 && length5 !== 0) {
    length5 = size - offset;
  }
  if (length5 < 0) {
    throw (0, import_err_code7.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset + length5 > size) {
    length5 = size - offset;
  }
  return {
    offset,
    length: length5
  };
};
var validate_offset_and_length_default = validateOffsetAndLength;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js
var import_err_code8 = __toESM(require_err_code(), 1);
async function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {
  if (node instanceof Uint8Array) {
    const buf2 = extract_data_from_block_default(node, streamPosition, start, end);
    if (buf2.length) {
      yield buf2;
    }
    streamPosition += buf2.length;
    return streamPosition;
  }
  if (node.Data == null) {
    throw (0, import_err_code8.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS2.unmarshal(node.Data);
  } catch (err) {
    throw (0, import_err_code8.default)(err, "ERR_NOT_UNIXFS");
  }
  if (file.data && file.data.length) {
    const buf2 = extract_data_from_block_default(file.data, streamPosition, start, end);
    if (buf2.length) {
      yield buf2;
    }
    streamPosition += file.data.length;
  }
  let childStart = streamPosition;
  for (let i2 = 0; i2 < node.Links.length; i2++) {
    const childLink = node.Links[i2];
    const childEnd = streamPosition + file.blockSizes[i2];
    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {
      const block = await blockstore.get(childLink.Hash, { signal: options.signal });
      let child;
      switch (childLink.Hash.code) {
        case code5:
          child = await decode18(block);
          break;
        case code7:
          child = block;
          break;
        case code6:
          child = await decode19(block);
          break;
        default:
          throw Error(`Unsupported codec: ${childLink.Hash.code}`);
      }
      for await (const buf2 of emitBytes(blockstore, child, start, end, streamPosition, options)) {
        streamPosition += buf2.length;
        yield buf2;
      }
    }
    streamPosition = childEnd;
    childStart = childEnd + 1;
  }
}
var fileContent = (cid, node, unixfs, path, resolve5, depth, blockstore) => {
  function yieldFileContent(options = {}) {
    const fileSize = unixfs.fileSize();
    if (fileSize === void 0) {
      throw new Error("File was a directory");
    }
    const { offset, length: length5 } = validate_offset_and_length_default(fileSize, options.offset, options.length);
    const start = offset;
    const end = offset + length5;
    return emitBytes(blockstore, node, start, end, 0, options);
  }
  return yieldFileContent;
};
var file_default = fileContent;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js
var directoryContent = (cid, node, unixfs, path, resolve5, depth, blockstore) => {
  async function* yieldDirectoryContent(options = {}) {
    const offset = options.offset || 0;
    const length5 = options.length || node.Links.length;
    const links2 = node.Links.slice(offset, length5);
    for (const link of links2) {
      const result = await resolve5(link.Hash, link.Name || "", `${path}/${link.Name || ""}`, [], depth + 1, blockstore, options);
      if (result.entry) {
        yield result.entry;
      }
    }
  }
  return yieldDirectoryContent;
};
var directory_default = directoryContent;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
var hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve5, depth, blockstore) => {
  function yieldHamtDirectoryContent(options = {}) {
    return listDirectory(node, path, resolve5, depth, blockstore, options);
  }
  return yieldHamtDirectoryContent;
};
async function* listDirectory(node, path, resolve5, depth, blockstore, options) {
  const links2 = node.Links;
  for (const link of links2) {
    const name6 = link.Name != null ? link.Name.substring(2) : null;
    if (name6) {
      const result = await resolve5(link.Hash, name6, `${path}/${name6}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node = decode18(block);
      for await (const file of listDirectory(node, path, resolve5, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
var hamt_sharded_directory_default = hamtShardedDirectoryContent;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
var findLinkCid = (node, name6) => {
  const link = node.Links.find((link2) => link2.Name === name6);
  return link && link.Hash;
};
var contentExporters = {
  raw: file_default,
  file: file_default,
  directory: directory_default,
  "hamt-sharded-directory": hamt_sharded_directory_default,
  metadata: (cid, node, unixfs, path, resolve5, depth, blockstore) => {
    return () => [];
  },
  symlink: (cid, node, unixfs, path, resolve5, depth, blockstore) => {
    return () => [];
  }
};
var unixFsResolver = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
  const block = await blockstore.get(cid, options);
  const node = decode18(block);
  let unixfs;
  let next;
  if (!name6) {
    name6 = cid.toString();
  }
  if (node.Data == null) {
    throw (0, import_err_code9.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  try {
    unixfs = UnixFS2.unmarshal(node.Data);
  } catch (err) {
    throw (0, import_err_code9.default)(err, "ERR_NOT_UNIXFS");
  }
  if (!path) {
    path = name6;
  }
  if (toResolve.length) {
    let linkCid;
    if (unixfs && unixfs.type === "hamt-sharded-directory") {
      linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
    } else {
      linkCid = findLinkCid(node, toResolve[0]);
    }
    if (!linkCid) {
      throw (0, import_err_code9.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
    }
    const nextName = toResolve.shift();
    const nextPath = `${path}/${nextName}`;
    next = {
      cid: linkCid,
      toResolve,
      name: nextName || "",
      path: nextPath
    };
  }
  return {
    entry: {
      type: unixfs.isDirectory() ? "directory" : "file",
      name: name6,
      path,
      cid,
      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve5, depth, blockstore),
      unixfs,
      depth,
      node,
      size: unixfs.fileSize()
    },
    next
  };
};
var unixfs_v1_default = unixFsResolver;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/raw.js
var import_err_code10 = __toESM(require_err_code(), 1);
var rawContent = (node) => {
  async function* contentGenerator(options = {}) {
    const { offset, length: length5 } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length5);
  }
  return contentGenerator;
};
var resolve = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code10.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const block = await blockstore.get(cid, options);
  return {
    entry: {
      type: "raw",
      name: name6,
      path,
      cid,
      content: rawContent(block),
      depth,
      size: block.length,
      node: block
    }
  };
};
var raw_default = resolve;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js
var import_err_code11 = __toESM(require_err_code(), 1);
var resolve2 = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
  const block = await blockstore.get(cid);
  const object = decode19(block);
  let subObject = object;
  let subPath = path;
  while (toResolve.length) {
    const prop = toResolve[0];
    if (prop in subObject) {
      toResolve.shift();
      subPath = `${subPath}/${prop}`;
      const subObjectCid = CID2.asCID(subObject[prop]);
      if (subObjectCid) {
        return {
          entry: {
            type: "object",
            name: name6,
            path,
            cid,
            node: block,
            depth,
            size: block.length,
            content: async function* () {
              yield object;
            }
          },
          next: {
            cid: subObjectCid,
            name: prop,
            path: subPath,
            toResolve
          }
        };
      }
      subObject = subObject[prop];
    } else {
      throw (0, import_err_code11.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
    }
  }
  return {
    entry: {
      type: "object",
      name: name6,
      path,
      cid,
      node: block,
      depth,
      size: block.length,
      content: async function* () {
        yield object;
      }
    }
  };
};
var dag_cbor_default = resolve2;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js
var import_err_code12 = __toESM(require_err_code(), 1);
var rawContent2 = (node) => {
  async function* contentGenerator(options = {}) {
    const { offset, length: length5 } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length5);
  }
  return contentGenerator;
};
var resolve3 = async (cid, name6, path, toResolve, resolve5, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code12.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const buf2 = await decode12(cid.multihash.bytes);
  return {
    entry: {
      type: "identity",
      name: name6,
      path,
      cid,
      content: rawContent2(buf2.digest),
      depth,
      size: buf2.digest.length,
      node: buf2.digest
    }
  };
};
var identity_default = resolve3;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
var resolvers = {
  [code5]: unixfs_v1_default,
  [code7]: raw_default,
  [code6]: dag_cbor_default,
  [identity3.code]: identity_default
};
function resolve4(cid, name6, path, toResolve, depth, blockstore, options) {
  const resolver = resolvers[cid.code];
  if (!resolver) {
    throw (0, import_err_code13.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name6, path, toResolve, resolve4, depth, blockstore, options);
}
var resolvers_default = resolve4;

// ../../node_modules/ipfs-unixfs-exporter/esm/src/index.js
var import_it_last = __toESM(require_it_last(), 1);
var toPathComponents2 = (path = "") => {
  return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
};
var cidAndRest = (path) => {
  if (path instanceof Uint8Array) {
    return {
      cid: CID2.decode(path),
      toResolve: []
    };
  }
  const cid = CID2.asCID(path);
  if (cid) {
    return {
      cid,
      toResolve: []
    };
  }
  if (typeof path === "string") {
    if (path.indexOf("/ipfs/") === 0) {
      path = path.substring(6);
    }
    const output = toPathComponents2(path);
    return {
      cid: CID2.parse(output[0]),
      toResolve: output.slice(1)
    };
  }
  throw (0, import_err_code14.default)(new Error(`Unknown path type ${path}`), "ERR_BAD_PATH");
};
async function* walkPath(path, blockstore, options = {}) {
  let { cid, toResolve } = cidAndRest(path);
  let name6 = cid.toString();
  let entryPath = name6;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolvers_default(cid, name6, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw (0, import_err_code14.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name6 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter(path, blockstore, options = {}) {
  const result = await (0, import_it_last.default)(walkPath(path, blockstore, options));
  if (!result) {
    throw (0, import_err_code14.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
  }
  return result;
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/store/data-store-level.js
var import_readable_stream = __toESM(require_ours(), 1);
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues4 = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve5, reject) {
        v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve5, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve5({ value: v3, done: d2 });
    }, reject);
  }
};
var DATA_PARTITION = "data";
var HOST_PARTITION = "host";
var PLACEHOLDER_VALUE = new Uint8Array();
var DataStoreLevel = class {
  constructor(config = {}) {
    this.config = Object.assign({ blockstoreLocation: "DATASTORE", createLevelDatabase }, config);
    this.blockstore = new BlockstoreLevel({
      location: this.config.blockstoreLocation,
      createLevelDatabase: this.config.createLevelDatabase
    });
  }
  open() {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.blockstore.open();
    });
  }
  close() {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.blockstore.close();
    });
  }
  put(tenant, messageCid, dataCid, dataStream) {
    var e_1, _a2;
    var _b, _c;
    return __awaiter6(this, void 0, void 0, function* () {
      const tenantsForData = yield this.blockstore.partition(HOST_PARTITION);
      const messagesForTenant = yield tenantsForData.partition(dataCid);
      const messages = yield messagesForTenant.partition(tenant);
      yield messages.put(messageCid, PLACEHOLDER_VALUE);
      const blocksForData = yield this.blockstore.partition(DATA_PARTITION);
      const blocks = yield blocksForData.partition(dataCid);
      const asyncDataBlocks = importer([{ content: dataStream }], blocks, { cidVersion: 1 });
      let dataDagRoot = void 0;
      try {
        for (var asyncDataBlocks_1 = __asyncValues4(asyncDataBlocks), asyncDataBlocks_1_1; asyncDataBlocks_1_1 = yield asyncDataBlocks_1.next(), !asyncDataBlocks_1_1.done; ) {
          dataDagRoot = asyncDataBlocks_1_1.value;
          ;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (asyncDataBlocks_1_1 && !asyncDataBlocks_1_1.done && (_a2 = asyncDataBlocks_1.return))
            yield _a2.call(asyncDataBlocks_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (dataDagRoot == void 0) {
        return { dataCid, dataSize: 0 };
      }
      return {
        dataCid: String(dataDagRoot.cid),
        dataSize: Number((_c = (_b = dataDagRoot.unixfs) === null || _b === void 0 ? void 0 : _b.fileSize()) !== null && _c !== void 0 ? _c : dataDagRoot.size)
      };
    });
  }
  get(tenant, messageCid, dataCid) {
    var _a2, _b;
    return __awaiter6(this, void 0, void 0, function* () {
      const tenantsForData = yield this.blockstore.partition(HOST_PARTITION);
      const messagesForTenant = yield tenantsForData.partition(dataCid);
      const messages = yield messagesForTenant.partition(tenant);
      const allowed = yield messages.has(messageCid);
      if (!allowed) {
        return void 0;
      }
      const blocksForData = yield this.blockstore.partition(DATA_PARTITION);
      const blocks = yield blocksForData.partition(dataCid);
      const exists2 = yield blocks.has(dataCid);
      if (!exists2) {
        return void 0;
      }
      const dataDagRoot = yield exporter(dataCid, blocks);
      const contentIterator = dataDagRoot.content()[Symbol.asyncIterator]();
      const dataStream = new import_readable_stream.Readable({
        read() {
          return __awaiter6(this, void 0, void 0, function* () {
            const result = yield contentIterator.next();
            if (result.done) {
              this.push(null);
            } else {
              this.push(result.value);
            }
          });
        }
      });
      return {
        dataCid: String(dataDagRoot.cid),
        dataSize: Number((_b = (_a2 = dataDagRoot.unixfs) === null || _a2 === void 0 ? void 0 : _a2.fileSize()) !== null && _b !== void 0 ? _b : dataDagRoot.size),
        dataStream
      };
    });
  }
  associate(tenant, messageCid, dataCid) {
    var _a2, _b;
    return __awaiter6(this, void 0, void 0, function* () {
      const tenantsForData = yield this.blockstore.partition(HOST_PARTITION);
      const messagesForTenant = yield tenantsForData.partition(dataCid);
      const messages = yield messagesForTenant.partition(tenant);
      const isFirstMessage = yield messages.isEmpty();
      if (isFirstMessage) {
        return void 0;
      }
      const blocksForData = yield this.blockstore.partition(DATA_PARTITION);
      const blocks = yield blocksForData.partition(dataCid);
      const exists2 = yield blocks.has(dataCid);
      if (!exists2) {
        return void 0;
      }
      yield messages.put(messageCid, PLACEHOLDER_VALUE);
      const dataDagRoot = yield exporter(dataCid, blocks);
      return {
        dataCid: String(dataDagRoot.cid),
        dataSize: Number((_b = (_a2 = dataDagRoot.unixfs) === null || _a2 === void 0 ? void 0 : _a2.fileSize()) !== null && _b !== void 0 ? _b : dataDagRoot.size)
      };
    });
  }
  delete(tenant, messageCid, dataCid) {
    return __awaiter6(this, void 0, void 0, function* () {
      const tenantsForData = yield this.blockstore.partition(HOST_PARTITION);
      const messagesForTenant = yield tenantsForData.partition(dataCid);
      const messages = yield messagesForTenant.partition(tenant);
      yield messages.delete(messageCid);
      const wasLastMessage = yield messages.isEmpty();
      if (!wasLastMessage) {
        return;
      }
      const wasLastTenant = yield messagesForTenant.isEmpty();
      if (!wasLastTenant) {
        return;
      }
      const blocksForData = yield this.blockstore.partition(DATA_PARTITION);
      const blocks = yield blocksForData.partition(dataCid);
      yield blocks.clear();
    });
  }
  /**
   * Deletes everything in the store. Mainly used in tests.
   */
  clear() {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.blockstore.clear();
    });
  }
  dump() {
    var _a2, _b;
    return __awaiter6(this, void 0, void 0, function* () {
      console.group("blockstore");
      yield (_b = (_a2 = this.blockstore)["dump"]) === null || _b === void 0 ? void 0 : _b.call(_a2);
      console.groupEnd();
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/encoder.js
var textEncoder7 = new TextEncoder();
var textDecoder5 = new TextDecoder();
var Encoder5 = class {
  static base64UrlToBytes(base64urlString) {
    const content = base64url.baseDecode(base64urlString);
    return content;
  }
  static base64UrlToObject(base64urlString) {
    const payloadBytes = base64url.baseDecode(base64urlString);
    const payloadString = Encoder5.bytesToString(payloadBytes);
    const payloadObject = JSON.parse(payloadString);
    return payloadObject;
  }
  static bytesToBase64Url(bytes) {
    const base64UrlString = base64url.baseEncode(bytes);
    return base64UrlString;
  }
  static bytesToString(content) {
    const bytes = textDecoder5.decode(content);
    return bytes;
  }
  static objectToBytes(obj) {
    const objectString = JSON.stringify(obj);
    const objectBytes = textEncoder7.encode(objectString);
    return objectBytes;
  }
  static stringToBase64Url(content) {
    const bytes = textEncoder7.encode(content);
    const base64UrlString = base64url.baseEncode(bytes);
    return base64UrlString;
  }
  static stringToBytes(content) {
    const bytes = textEncoder7.encode(content);
    return bytes;
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/node_modules/@noble/ed25519/lib/esm/index.js
var nodeCrypto = __toESM(require("crypto"), 1);
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var ExtendedPoint = class {
  constructor(x2, y2, z2, t2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.t = t2;
  }
  static fromAffine(p2) {
    if (!(p2 instanceof Point)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p2.equals(Point.ZERO))
      return ExtendedPoint.ZERO;
    return new ExtendedPoint(p2.x, p2.y, _1n, mod2(p2.x * p2.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p2) => p2.z));
    return points.map((p2, i2) => p2.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const X1Z2 = mod2(X1 * Z2);
    const X2Z1 = mod2(X2 * Z1);
    const Y1Z2 = mod2(Y1 * Z2);
    const Y2Z1 = mod2(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new ExtendedPoint(mod2(-this.x), this.y, this.z, mod2(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const { a: a2 } = CURVE;
    const A2 = mod2(X1 * X1);
    const B2 = mod2(Y1 * Y1);
    const C2 = mod2(_2n * mod2(Z1 * Z1));
    const D2 = mod2(a2 * A2);
    const x1y1 = X1 + Y1;
    const E2 = mod2(mod2(x1y1 * x1y1) - A2 - B2);
    const G2 = D2 + B2;
    const F2 = G2 - C2;
    const H2 = D2 - B2;
    const X3 = mod2(E2 * F2);
    const Y3 = mod2(G2 * H2);
    const T3 = mod2(E2 * H2);
    const Z3 = mod2(F2 * G2);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1, t: T1 } = this;
    const { x: X2, y: Y2, z: Z2, t: T2 } = other;
    const A2 = mod2((Y1 - X1) * (Y2 + X2));
    const B2 = mod2((Y1 + X1) * (Y2 - X2));
    const F2 = mod2(B2 - A2);
    if (F2 === _0n)
      return this.double();
    const C2 = mod2(Z1 * _2n * T2);
    const D2 = mod2(T1 * _2n * Z2);
    const E2 = D2 + C2;
    const G2 = B2 + A2;
    const H2 = D2 - C2;
    const X3 = mod2(E2 * F2);
    const Y3 = mod2(G2 * H2);
    const T3 = mod2(E2 * H2);
    const Z3 = mod2(F2 * G2);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W2) {
    const windows = 1 + 256 / W2;
    const points = [];
    let p2 = this;
    let base6 = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base6 = p2;
      points.push(base6);
      for (let i2 = 1; i2 < 2 ** (W2 - 1); i2++) {
        base6 = base6.add(p2);
        points.push(base6);
      }
      p2 = base6.double();
    }
    return points;
  }
  wNAF(n2, affinePoint) {
    if (!affinePoint && this.equals(ExtendedPoint.BASE))
      affinePoint = Point.BASE;
    const W2 = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W2) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W2);
      if (affinePoint && W2 !== 1) {
        precomputes = ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p2 = ExtendedPoint.ZERO;
    let f2 = ExtendedPoint.ZERO;
    const windows = 1 + 256 / W2;
    const windowSize = 2 ** (W2 - 1);
    const mask = BigInt(2 ** W2 - 1);
    const maxNumber = 2 ** W2;
    const shiftBy = BigInt(W2);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n2 & mask);
      n2 >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n2 += _1n;
      }
      if (wbits === 0) {
        let pr = precomputes[offset];
        if (window2 % 2)
          pr = pr.negate();
        f2 = f2.add(pr);
      } else {
        let cached = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          cached = cached.negate();
        p2 = p2.add(cached);
      }
    }
    return ExtendedPoint.normalizeZ([p2, f2])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n2 = normalizeScalar(scalar, CURVE.l, false);
    const G2 = ExtendedPoint.BASE;
    const P0 = ExtendedPoint.ZERO;
    if (n2 === _0n)
      return P0;
    if (this.equals(P0) || n2 === _1n)
      return this;
    if (this.equals(G2))
      return this.wNAF(n2);
    let p2 = P0;
    let d2 = this;
    while (n2 > _0n) {
      if (n2 & _1n)
        p2 = p2.add(d2);
      d2 = d2.double();
      n2 >>= _1n;
    }
    return p2;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);
  }
  toAffine(invZ = invert(this.z)) {
    const { x: x2, y: y2, z: z2 } = this;
    const ax = mod2(x2 * invZ);
    const ay = mod2(y2 * invZ);
    const zz = mod2(z2 * invZ);
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
};
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod2(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
var RistrettoPoint = class {
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d: d2 } = CURVE;
    const r2 = mod2(SQRT_M1 * r0 * r0);
    const Ns = mod2((r2 + _1n) * ONE_MINUS_D_SQ);
    let c2 = BigInt(-1);
    const D2 = mod2((c2 - d2 * r2) * mod2(r2 + d2));
    let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D2);
    let s_ = mod2(s2 * r0);
    if (!edIsNegative(s_))
      s_ = mod2(-s_);
    if (!Ns_D_is_sq)
      s2 = s_;
    if (!Ns_D_is_sq)
      c2 = r2;
    const Nt = mod2(c2 * (r2 - _1n) * D_MINUS_ONE_SQ - D2);
    const s22 = s2 * s2;
    const W0 = mod2((s2 + s2) * D2);
    const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod2(_1n - s22);
    const W3 = mod2(_1n + s22);
    return new ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = this.calcElligatorRistrettoMap(r2);
    return new RistrettoPoint(R1.add(R2));
  }
  static fromHex(hex) {
    hex = ensureBytes(hex, 32);
    const { a: a2, d: d2 } = CURVE;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s2 = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s2), hex) || edIsNegative(s2))
      throw new Error(emsg);
    const s22 = mod2(s2 * s2);
    const u1 = mod2(_1n + a2 * s22);
    const u2 = mod2(_1n - a2 * s22);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u2 * u2);
    const v2 = mod2(a2 * d2 * u1_2 - u2_2);
    const { isValid, value: I2 } = invertSqrt(mod2(v2 * u2_2));
    const Dx = mod2(I2 * u2);
    const Dy = mod2(I2 * Dx * v2);
    let x2 = mod2((s2 + s2) * Dx);
    if (edIsNegative(x2))
      x2 = mod2(-x2);
    const y2 = mod2(u1 * Dy);
    const t2 = mod2(x2 * y2);
    if (!isValid || edIsNegative(t2) || y2 === _0n)
      throw new Error(emsg);
    return new RistrettoPoint(new ExtendedPoint(x2, y2, _1n, t2));
  }
  toRawBytes() {
    let { x: x2, y: y2, z: z2, t: t2 } = this.ep;
    const u1 = mod2(mod2(z2 + y2) * mod2(z2 - y2));
    const u2 = mod2(x2 * y2);
    const u2sq = mod2(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D2 = mod2(invsqrt * u2);
    const zInv = mod2(D1 * D2 * t2);
    let D3;
    if (edIsNegative(t2 * zInv)) {
      let _x = mod2(y2 * SQRT_M1);
      let _y = mod2(x2 * SQRT_M1);
      x2 = _x;
      y2 = _y;
      D3 = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D3 = D2;
    }
    if (edIsNegative(x2 * zInv))
      y2 = mod2(-y2);
    let s2 = mod2((z2 - y2) * D3);
    if (edIsNegative(s2))
      s2 = mod2(-s2);
    return numberTo32BytesLE(s2);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a2 = this.ep;
    const b2 = other.ep;
    const one = mod2(a2.x * b2.y) === mod2(a2.y * b2.x);
    const two = mod2(a2.y * b2.y) === mod2(a2.x * b2.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
};
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d: d2, P: P2 } = CURVE;
    hex = ensureBytes(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y2 = bytesToNumberLE(normed);
    if (strict && y2 >= P2)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y2 >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const y22 = mod2(y2 * y2);
    const u2 = mod2(y22 - _1n);
    const v2 = mod2(d2 * y22 + _1n);
    let { isValid, value: x2 } = uvRatio(u2, v2);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x2 & _1n) === _1n;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x2 = mod2(-x2);
    }
    return new Point(x2, y2);
  }
  static async fromPrivateKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).point;
  }
  toRawBytes() {
    const bytes = numberTo32BytesLE(this.y);
    bytes[31] |= this.x & _1n ? 128 : 0;
    return bytes;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toX25519() {
    const { y: y2 } = this;
    const u2 = mod2((_1n + y2) * invert(_1n - y2));
    return numberTo32BytesLE(u2);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(mod2(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
var Signature = class {
  constructor(r2, s2) {
    this.r = r2;
    this.s = s2;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes = ensureBytes(hex, 64);
    const r2 = Point.fromHex(bytes.slice(0, 32), false);
    const s2 = bytesToNumberLE(bytes.slice(32, 64));
    return new Signature(r2, s2);
  }
  assertValidity() {
    const { r: r2, s: s2 } = this;
    if (!(r2 instanceof Point))
      throw new Error("Expected Point instance");
    normalizeScalar(s2, CURVE.l, false);
    return this;
  }
  toRawBytes() {
    const u8 = new Uint8Array(64);
    u8.set(this.r.toRawBytes());
    u8.set(numberTo32BytesLE(this.s), 32);
    return u8;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
};
function concatBytes(...arrays) {
  if (!arrays.every((a2) => a2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length5 = arrays.reduce((a2, arr) => a2 + arr.length, 0);
  const result = new Uint8Array(length5);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({ length: 256 }, (v2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes[uint8a[i2]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j2 = i2 * 2;
    const hexByte = hex.slice(j2, j2 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function numberTo32BytesBE(num) {
  const length5 = 32;
  const hex = num.toString(16).padStart(length5 * 2, "0");
  return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod2(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes) {
  return mod2(bytesToNumberLE(bytes) & MAX_255B);
}
function mod2(a2, b2 = CURVE.P) {
  const res = a2 % b2;
  return res >= _0n ? res : b2 + res;
}
function invert(number, modulo = CURVE.P) {
  if (number === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a2 = mod2(number, modulo);
  let b2 = modulo;
  let x2 = _0n, y2 = _1n, u2 = _1n, v2 = _0n;
  while (a2 !== _0n) {
    const q2 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q2;
    const n2 = y2 - v2 * q2;
    b2 = a2, a2 = r2, x2 = u2, y2 = v2, u2 = m2, v2 = n2;
  }
  const gcd = b2;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod2(x2, modulo);
}
function invertBatch(nums, p2 = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n)
      return acc;
    tmp[i2] = acc;
    return mod2(acc * num, p2);
  }, _1n);
  const inverted = invert(lastMultiplied, p2);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n)
      return acc;
    tmp[i2] = mod2(acc * tmp[i2], p2);
    return mod2(acc * num, p2);
  }, inverted);
  return tmp;
}
function pow2(x2, power) {
  const { P: P2 } = CURVE;
  let res = x2;
  while (power-- > _0n) {
    res *= res;
    res %= P2;
  }
  return res;
}
function pow_2_252_3(x2) {
  const { P: P2 } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x22 = x2 * x2 % P2;
  const b2 = x22 * x2 % P2;
  const b4 = pow2(b2, _2n) * b2 % P2;
  const b5 = pow2(b4, _1n) * x2 % P2;
  const b10 = pow2(b5, _5n) * b5 % P2;
  const b20 = pow2(b10, _10n) * b10 % P2;
  const b40 = pow2(b20, _20n) * b20 % P2;
  const b80 = pow2(b40, _40n) * b40 % P2;
  const b160 = pow2(b80, _80n) * b80 % P2;
  const b240 = pow2(b160, _80n) * b80 % P2;
  const b250 = pow2(b240, _10n) * b10 % P2;
  const pow_p_5_8 = pow2(b250, _2n) * x2 % P2;
  return { pow_p_5_8, b2 };
}
function uvRatio(u2, v2) {
  const v3 = mod2(v2 * v2 * v2);
  const v7 = mod2(v3 * v3 * v2);
  const pow = pow_2_252_3(u2 * v7).pow_p_5_8;
  let x2 = mod2(u2 * v3 * pow);
  const vx2 = mod2(v2 * x2 * x2);
  const root1 = x2;
  const root2 = mod2(x2 * SQRT_M1);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod2(-u2);
  const noRoot = vx2 === mod2(-u2 * SQRT_M1);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (edIsNegative(x2))
    x2 = mod2(-x2);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
function invertSqrt(number) {
  return uvRatio(_1n, number);
}
function modlLE(hash) {
  return mod2(bytesToNumberLE(hash), CURVE.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex, expectedLength) {
  const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
var _sha512Sync;
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign(message2, privateKey) {
  message2 = ensureBytes(message2);
  const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r2 = modlLE(await utils.sha512(prefix, message2));
  const R2 = Point.BASE.multiply(r2);
  const k2 = modlLE(await utils.sha512(R2.toRawBytes(), pointBytes, message2));
  const s2 = mod2(r2 + k2 * scalar, CURVE.l);
  return new Signature(R2, s2).toRawBytes();
}
function prepareVerification(sig, message2, publicKey) {
  message2 = ensureBytes(message2);
  if (!(publicKey instanceof Point))
    publicKey = Point.fromHex(publicKey, false);
  const { r: r2, s: s2 } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s2);
  return { r: r2, s: s2, SB, pub: publicKey, msg: message2 };
}
function finishVerification(publicKey, r2, SB, hashed) {
  const k2 = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k2);
  const RkA = ExtendedPoint.fromAffine(r2).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message2, publicKey) {
  const { r: r2, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
  const hashed = await utils.sha512(r2.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r2, SB, hashed);
}
Point.BASE._setWindowSize(8);
var crypto2 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  getExtendedPublicKey,
  mod: mod2,
  invert,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash) => {
    hash = ensureBytes(hash);
    if (hash.length < 40 || hash.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod2(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto2.web) {
      return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto2.node) {
      const { randomBytes } = crypto2.node;
      return new Uint8Array(randomBytes(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.randomBytes(32);
  },
  sha512: async (...messages) => {
    const message2 = concatBytes(...messages);
    if (crypto2.web) {
      const buffer2 = await crypto2.web.subtle.digest("SHA-512", message2.buffer);
      return new Uint8Array(buffer2);
    } else if (crypto2.node) {
      return Uint8Array.from(crypto2.node.createHash("sha512").update(message2).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_2n);
    return cached;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/jose/algorithms/signing/ed25519.js
var __awaiter7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function validateKey(jwk) {
  if (jwk.kty !== "OKP" || jwk.crv !== "Ed25519") {
    throw new Error("invalid jwk. kty MUST be OKP. crv MUST be Ed25519");
  }
}
function publicKeyToJwk(publicKeyBytes) {
  const x2 = Encoder5.bytesToBase64Url(publicKeyBytes);
  const publicJwk = {
    alg: "EdDSA",
    kty: "OKP",
    crv: "Ed25519",
    x: x2
  };
  return publicJwk;
}
var ed25519 = {
  sign: (content, privateJwk) => {
    validateKey(privateJwk);
    const privateKeyBytes = Encoder5.base64UrlToBytes(privateJwk.d);
    return sign(content, privateKeyBytes);
  },
  verify: (content, signature, publicJwk) => {
    validateKey(publicJwk);
    const publicKeyBytes = Encoder5.base64UrlToBytes(publicJwk.x);
    return verify(signature, content, publicKeyBytes);
  },
  generateKeyPair: () => __awaiter7(void 0, void 0, void 0, function* () {
    const privateKeyBytes = utils.randomPrivateKey();
    const publicKeyBytes = yield getPublicKey(privateKeyBytes);
    const d2 = Encoder5.bytesToBase64Url(privateKeyBytes);
    const publicJwk = publicKeyToJwk(publicKeyBytes);
    const privateJwk = Object.assign(Object.assign({}, publicJwk), { d: d2 });
    return { publicJwk, privateJwk };
  }),
  publicKeyToJwk: (publicKeyBytes) => __awaiter7(void 0, void 0, void 0, function* () {
    return publicKeyToJwk(publicKeyBytes);
  })
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/node_modules/@noble/secp256k1/lib/esm/index.js
var nodeCrypto2 = __toESM(require("crypto"), 1);
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _8n = BigInt(8);
var CURVE2 = Object.freeze({
  a: _0n2,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n2,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest = (a2, b2) => (a2 + b2 / _2n2) / b2;
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k2) {
    const { n: n2 } = CURVE2;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n2 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest(b2 * k2, n2);
    const c2 = divNearest(-b1 * k2, n2);
    let k1 = mod3(k2 - c1 * a1 - c2 * a2, n2);
    let k22 = mod3(-c1 * b1 - c2 * b2, n2);
    const k1neg = k1 > POW_2_128;
    const k2neg = k22 > POW_2_128;
    if (k1neg)
      k1 = n2 - k1;
    if (k2neg)
      k22 = n2 - k22;
    if (k1 > POW_2_128 || k22 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k2);
    }
    return { k1neg, k1, k2neg, k2: k22 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x2) {
  const { a: a2, b: b2 } = CURVE2;
  const x22 = mod3(x2 * x2);
  const x3 = mod3(x22 * x2);
  return mod3(x3 + a2 * x2 + b2);
}
var USE_ENDOMORPHISM = CURVE2.a === _0n2;
var ShaError = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
var JacobianPoint = class {
  constructor(x2, y2, z2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  static fromAffine(p2) {
    if (!(p2 instanceof Point2)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p2.equals(Point2.ZERO))
      return JacobianPoint.ZERO;
    return new JacobianPoint(p2.x, p2.y, _1n2);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch2(points.map((p2) => p2.z));
    return points.map((p2, i2) => p2.toAffine(toInv[i2]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod3(Z1 * Z1);
    const Z2Z2 = mod3(Z2 * Z2);
    const U1 = mod3(X1 * Z2Z2);
    const U2 = mod3(X2 * Z1Z1);
    const S1 = mod3(mod3(Y1 * Z2) * Z2Z2);
    const S2 = mod3(mod3(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod3(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A2 = mod3(X1 * X1);
    const B2 = mod3(Y1 * Y1);
    const C2 = mod3(B2 * B2);
    const x1b = X1 + B2;
    const D2 = mod3(_2n2 * (mod3(x1b * x1b) - A2 - C2));
    const E2 = mod3(_3n * A2);
    const F2 = mod3(E2 * E2);
    const X3 = mod3(F2 - _2n2 * D2);
    const Y3 = mod3(E2 * (D2 - X3) - _8n * C2);
    const Z3 = mod3(_2n2 * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n2 || Y2 === _0n2)
      return this;
    if (X1 === _0n2 || Y1 === _0n2)
      return other;
    const Z1Z1 = mod3(Z1 * Z1);
    const Z2Z2 = mod3(Z2 * Z2);
    const U1 = mod3(X1 * Z2Z2);
    const U2 = mod3(X2 * Z1Z1);
    const S1 = mod3(mod3(Y1 * Z2) * Z2Z2);
    const S2 = mod3(mod3(Y2 * Z1) * Z1Z1);
    const H2 = mod3(U2 - U1);
    const r2 = mod3(S2 - S1);
    if (H2 === _0n2) {
      if (r2 === _0n2) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod3(H2 * H2);
    const HHH = mod3(H2 * HH);
    const V2 = mod3(U1 * HH);
    const X3 = mod3(r2 * r2 - HHH - _2n2 * V2);
    const Y3 = mod3(r2 * (V2 - X3) - S1 * HHH);
    const Z3 = mod3(Z1 * Z2 * H2);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n2)
      return P0;
    let n2 = normalizeScalar2(scalar);
    if (n2 === _1n2)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p2 = P0;
      let d3 = this;
      while (n2 > _0n2) {
        if (n2 & _1n2)
          p2 = p2.add(d3);
        d3 = d3.double();
        n2 >>= _1n2;
      }
      return p2;
    }
    let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
    let k1p = P0;
    let k2p = P0;
    let d2 = this;
    while (k1 > _0n2 || k2 > _0n2) {
      if (k1 & _1n2)
        k1p = k1p.add(d2);
      if (k2 & _1n2)
        k2p = k2p.add(d2);
      d2 = d2.double();
      k1 >>= _1n2;
      k2 >>= _1n2;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod3(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W2) {
    const windows = USE_ENDOMORPHISM ? 128 / W2 + 1 : 256 / W2 + 1;
    const points = [];
    let p2 = this;
    let base6 = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base6 = p2;
      points.push(base6);
      for (let i2 = 1; i2 < 2 ** (W2 - 1); i2++) {
        base6 = base6.add(p2);
        points.push(base6);
      }
      p2 = base6.double();
    }
    return points;
  }
  wNAF(n2, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point2.BASE;
    const W2 = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W2) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W2);
      if (affinePoint && W2 !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes2.set(affinePoint, precomputes);
      }
    }
    let p2 = JacobianPoint.ZERO;
    let f2 = JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W2 : 256 / W2);
    const windowSize = 2 ** (W2 - 1);
    const mask = BigInt(2 ** W2 - 1);
    const maxNumber = 2 ** W2;
    const shiftBy = BigInt(W2);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n2 & mask);
      n2 >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n2 += _1n2;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return { p: p2, f: f2 };
  }
  multiply(scalar, affinePoint) {
    let n2 = normalizeScalar2(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      k1p = constTimeNegate(k1neg, k1p);
      k2p = constTimeNegate(k2neg, k2p);
      k2p = new JacobianPoint(mod3(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p: p2, f: f2 } = this.wNAF(n2, affinePoint);
      point = p2;
      fake = f2;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x: x2, y: y2, z: z2 } = this;
    const is0 = this.equals(JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert2(z2);
    const iz1 = invZ;
    const iz2 = mod3(iz1 * iz1);
    const iz3 = mod3(iz2 * iz1);
    const ax = mod3(x2 * iz2);
    const ay = mod3(y2 * iz3);
    const zz = mod3(z2 * iz1);
    if (is0)
      return Point2.ZERO;
    if (zz !== _1n2)
      throw new Error("invZ was invalid");
    return new Point2(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE2.Gx, CURVE2.Gy, _1n2);
JacobianPoint.ZERO = new JacobianPoint(_0n2, _1n2, _0n2);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var Point2 = class {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes2.delete(this);
  }
  hasEvenY() {
    return this.y % _2n2 === _0n2;
  }
  static fromCompressedHex(bytes) {
    const isShort = bytes.length === 32;
    const x2 = bytesToNumber(isShort ? bytes : bytes.subarray(1));
    if (!isValidFieldElement(x2))
      throw new Error("Point is not on curve");
    const y2 = weierstrass(x2);
    let y3 = sqrtMod(y2);
    const isYOdd = (y3 & _1n2) === _1n2;
    if (isShort) {
      if (isYOdd)
        y3 = mod3(-y3);
    } else {
      const isFirstByteOdd = (bytes[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y3 = mod3(-y3);
    }
    const point = new Point2(x2, y3);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes) {
    const x2 = bytesToNumber(bytes.subarray(1, fieldLen + 1));
    const y2 = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new Point2(x2, y2);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes = ensureBytes2(hex);
    const len = bytes.length;
    const header = bytes[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return Point2.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    const { r: r2, s: s2 } = normalizeSignature(signature);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h2 = truncateHash(ensureBytes2(msgHash));
    const { n: n2 } = CURVE2;
    const radj = recovery === 2 || recovery === 3 ? r2 + n2 : r2;
    const rinv = invert2(radj, n2);
    const u1 = mod3(-h2 * rinv, n2);
    const u2 = mod3(s2 * rinv, n2);
    const prefix = recovery & 1 ? "03" : "02";
    const R2 = Point2.fromHex(prefix + numTo32bStr(radj));
    const Q2 = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
    if (!Q2)
      throw new Error("Cannot recover signature: point at infinify");
    Q2.assertValidity();
    return Q2;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes2(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x2 = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x2}`;
    } else {
      return `04${x2}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x: x2, y: y2 } = this;
    if (!isValidFieldElement(x2) || !isValidFieldElement(y2))
      throw new Error(msg);
    const left = mod3(y2 * y2);
    const right = weierstrass(x2);
    if (mod3(left - right) !== _0n2)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point2(this.x, mod3(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q2, a2, b2) {
    const P2 = JacobianPoint.fromAffine(this);
    const aP = a2 === _0n2 || a2 === _1n2 || this !== Point2.BASE ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
    const bQ = JacobianPoint.fromAffine(Q2).multiplyUnsafe(b2);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy);
Point2.ZERO = new Point2(_0n2, _0n2);
function sliceDER(s2) {
  return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex2(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex2(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r2, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex2(rBytesLeft)}`);
  }
  return { r: r2, s: s2 };
}
var Signature2 = class {
  constructor(r2, s2) {
    this.r = r2;
    this.s = s2;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name6 = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name6}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex2(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name6}: Expected 64-byte hex`);
    return new Signature2(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r: r2, s: s2 } = parseDERSignature(arr ? hex : hexToBytes2(hex));
    return new Signature2(r2, s2);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r: r2, s: s2 } = this;
    if (!isWithinCurveOrder(r2))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s2))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE2.n >> _1n2;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature2(this.r, mod3(-this.s, CURVE2.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes2(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded(sHexL);
    const rLen = numberToHexUnpadded(rHexL);
    const length5 = numberToHexUnpadded(rHexL + sHexL + 4);
    return `30${length5}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes2(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes2(...arrays) {
  if (!arrays.every((b2) => b2 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length5 = arrays.reduce((a2, arr) => a2 + arr.length, 0);
  const result = new Uint8Array(length5);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const arr = arrays[i2];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes2 = Array.from({ length: 256 }, (v2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i2 = 0; i2 < uint8a.length; i2++) {
    hex += hexes2[uint8a[i2]];
  }
  return hex;
}
var POW_2_2562 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n2 <= num && num < POW_2_2562))
    throw new Error("Expected number 0 <= n < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b2 = hexToBytes2(numTo32bStr(num));
  if (b2.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b2;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j2 = i2 * 2;
    const hexByte = hex.slice(j2, j2 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumber(bytes) {
  return hexToNumber(bytesToHex2(bytes));
}
function ensureBytes2(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
}
function normalizeScalar2(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod3(a2, b2 = CURVE2.P) {
  const result = a2 % b2;
  return result >= _0n2 ? result : b2 + result;
}
function pow22(x2, power) {
  const { P: P2 } = CURVE2;
  let res = x2;
  while (power-- > _0n2) {
    res *= res;
    res %= P2;
  }
  return res;
}
function sqrtMod(x2) {
  const { P: P2 } = CURVE2;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x2 * x2 * x2 % P2;
  const b3 = b2 * b2 * x2 % P2;
  const b6 = pow22(b3, _3n) * b3 % P2;
  const b9 = pow22(b6, _3n) * b3 % P2;
  const b11 = pow22(b9, _2n2) * b2 % P2;
  const b22 = pow22(b11, _11n) * b11 % P2;
  const b44 = pow22(b22, _22n) * b22 % P2;
  const b88 = pow22(b44, _44n) * b44 % P2;
  const b176 = pow22(b88, _88n) * b88 % P2;
  const b220 = pow22(b176, _44n) * b44 % P2;
  const b223 = pow22(b220, _3n) * b3 % P2;
  const t1 = pow22(b223, _23n) * b22 % P2;
  const t2 = pow22(t1, _6n) * b2 % P2;
  const rt2 = pow22(t2, _2n2);
  const xc = rt2 * rt2 % P2;
  if (xc !== x2)
    throw new Error("Cannot find square root");
  return rt2;
}
function invert2(number, modulo = CURVE2.P) {
  if (number === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a2 = mod3(number, modulo);
  let b2 = modulo;
  let x2 = _0n2, y2 = _1n2, u2 = _1n2, v2 = _0n2;
  while (a2 !== _0n2) {
    const q2 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q2;
    const n2 = y2 - v2 * q2;
    b2 = a2, a2 = r2, x2 = u2, y2 = v2, u2 = m2, v2 = n2;
  }
  const gcd = b2;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod3(x2, modulo);
}
function invertBatch2(nums, p2 = CURVE2.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (num === _0n2)
      return acc;
    scratch[i2] = acc;
    return mod3(acc * num, p2);
  }, _1n2);
  const inverted = invert2(lastMultiplied, p2);
  nums.reduceRight((acc, num, i2) => {
    if (num === _0n2)
      return acc;
    scratch[i2] = mod3(acc * scratch[i2], p2);
    return mod3(acc * num, p2);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes) {
  const delta = bytes.length * 8 - groupLen * 8;
  const num = bytesToNumber(bytes);
  return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash, truncateOnly = false) {
  const h2 = bits2int_2(hash);
  if (truncateOnly)
    return h2;
  const { n: n2 } = CURVE2;
  return h2 >= n2 ? h2 - n2 : h2;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils2.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
    this.v = await this.hmac(this.v);
    if (seed.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
    this.v = this.hmacSync(this.v);
    if (seed.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = await this.hmac(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes2(...out);
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes2(...out);
  }
};
function isWithinCurveOrder(num) {
  return _0n2 < num && num < CURVE2.n;
}
function isValidFieldElement(num) {
  return _0n2 < num && num < CURVE2.P;
}
function kmdToSig(kBytes, m2, d2, lowS = true) {
  const { n: n2 } = CURVE2;
  const k2 = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k2))
    return;
  const kinv = invert2(k2, n2);
  const q2 = Point2.BASE.multiply(k2);
  const r2 = mod3(q2.x, n2);
  if (r2 === _0n2)
    return;
  const s2 = mod3(kinv * mod3(m2 + d2 * r2, n2), n2);
  if (s2 === _0n2)
    return;
  let sig = new Signature2(r2, s2);
  let recovery = (q2.x === sig.r ? 0 : 2) | Number(q2.y & _1n2);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point2) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point2.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature2) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature2.fromDER(signature);
  } catch (error) {
    return Signature2.fromCompact(signature);
  }
}
function getPublicKey2(privateKey, isCompressed = false) {
  return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes) {
  const slice2 = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
  return bytesToNumber(slice2);
}
function bits2octets(bytes) {
  const z1 = bits2int(bytes);
  const z2 = mod3(z1, CURVE2.n);
  return int2octets(z2 < _0n2 ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes2(msgHash);
  const d2 = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d2), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils2.randomBytes(fieldLen);
    const e2 = ensureBytes2(extraEntropy);
    if (e2.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e2);
  }
  const seed = concatBytes2(...seedArgs);
  const m2 = bits2int(h1);
  return { seed, m: m2, d: d2 };
}
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
async function sign2(msgHash, privKey, opts = {}) {
  const { seed, m: m2, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  await drbg.reseed(seed);
  let sig;
  while (!(sig = kmdToSig(await drbg.generate(), m2, d2, opts.canonical)))
    await drbg.reseed();
  return finalizeSig(sig, opts);
}
var vopts = { strict: true };
function verify2(signature, msgHash, publicKey, opts = vopts) {
  let sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes2(msgHash);
  } catch (error) {
    return false;
  }
  const { r: r2, s: s2 } = sig;
  if (opts.strict && sig.hasHighS())
    return false;
  const h2 = truncateHash(msgHash);
  let P2;
  try {
    P2 = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  const { n: n2 } = CURVE2;
  const sinv = invert2(s2, n2);
  const u1 = mod3(h2 * sinv, n2);
  const u2 = mod3(r2 * sinv, n2);
  const R2 = Point2.BASE.multiplyAndAddUnsafe(P2, u1, u2);
  if (!R2)
    return false;
  const v2 = mod3(R2.x, n2);
  return v2 === r2;
}
Point2.BASE._setWindowSize(8);
var crypto3 = {
  node: nodeCrypto2,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES = {};
var utils2 = {
  bytesToHex: bytesToHex2,
  hexToBytes: hexToBytes2,
  concatBytes: concatBytes2,
  mod: mod3,
  invert: invert2,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash) => {
    hash = ensureBytes2(hash);
    const minLen = groupLen + 8;
    if (hash.length < minLen || hash.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num = mod3(bytesToNumber(hash), CURVE2.n - _1n2) + _1n2;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      const { randomBytes } = crypto3.node;
      return Uint8Array.from(randomBytes(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils2.hashToPrivateKey(utils2.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point2.BASE) {
    const cached = point === Point2.BASE ? point : new Point2(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: async (...messages) => {
    if (crypto3.web) {
      const buffer2 = await crypto3.web.subtle.digest("SHA-256", concatBytes2(...messages));
      return new Uint8Array(buffer2);
    } else if (crypto3.node) {
      const { createHash } = crypto3.node;
      const hash = createHash("sha256");
      messages.forEach((m2) => hash.update(m2));
      return Uint8Array.from(hash.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages) => {
    if (crypto3.web) {
      const ckey = await crypto3.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message2 = concatBytes2(...messages);
      const buffer2 = await crypto3.web.subtle.sign("HMAC", ckey, message2);
      return new Uint8Array(buffer2);
    } else if (crypto3.node) {
      const { createHmac } = crypto3.node;
      const hash = createHmac("sha256", key);
      messages.forEach((m2) => hash.update(m2));
      return Uint8Array.from(hash.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = await utils2.sha256(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils2.sha256(tagP, ...messages);
  },
  taggedHashSync: (tag, ...messages) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils2, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/secp256k1.js
var import_secp256k1 = __toESM(require_secp256k12(), 1);

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/core/dwn-error.js
var DwnError = class extends Error {
  constructor(code9, message2) {
    super(`${code9}: ${message2}`);
    this.code = code9;
    this.name = "DwnError";
  }
};
var DwnErrorCode;
(function(DwnErrorCode2) {
  DwnErrorCode2["AuthenticateJwsMissing"] = "AuthenticateJwsMissing";
  DwnErrorCode2["AuthorizationMissing"] = "AuthorizationMissing";
  DwnErrorCode2["AuthorizationUnknownAuthor"] = "AuthorizationUnknownAuthor";
  DwnErrorCode2["HdKeyDerivationPathInvalid"] = "HdKeyDerivationPathInvalid";
  DwnErrorCode2["MessageStoreDataCidMismatch"] = "MessageStoreDataCidMismatch";
  DwnErrorCode2["MessageStoreDataNotFound"] = "MessageStoreDataNotFound";
  DwnErrorCode2["MessageStoreDataSizeMismatch"] = "MessageStoreDataSizeMismatch";
  DwnErrorCode2["RecordsDecryptNoMatchingKeyDerivationScheme"] = "RecordsDecryptNoMatchingKeyDerivationScheme";
  DwnErrorCode2["RecordsDeriveLeafPrivateKeyUnSupportedCurve"] = "RecordsDeriveLeafPrivateKeyUnSupportedCurve";
  DwnErrorCode2["RecordsDeriveLeafPublicKeyUnSupportedCurve"] = "RecordsDeriveLeafPublicKeyUnSupportedCurve";
  DwnErrorCode2["RecordsInvalidAncestorKeyDerivationSegment"] = "RecordsInvalidAncestorKeyDerivationSegment";
  DwnErrorCode2["RecordsWriteGetEntryIdUndefinedAuthor"] = "RecordsWriteGetEntryIdUndefinedAuthor";
  DwnErrorCode2["RecordsWriteValidateIntegrityEncryptionCidMismatch"] = "RecordsWriteValidateIntegrityEncryptionCidMismatch";
  DwnErrorCode2["Secp256k1KeyNotValid"] = "Secp256k1KeyNotValid";
})(DwnErrorCode || (DwnErrorCode = {}));

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/secp256k1.js
var __awaiter8 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Secp256k1 = class {
  /**
   * Validates the given JWK is a SECP256K1 key.
   * @throws {Error} if fails validation.
   */
  static validateKey(jwk) {
    if (jwk.kty !== "EC" || jwk.crv !== "secp256k1") {
      throw new DwnError(DwnErrorCode.Secp256k1KeyNotValid, "Invalid SECP256K1 JWK: `kty` MUST be `EC`. `crv` MUST be `secp256k1`");
    }
  }
  /**
   * Converts a public key in bytes into a JWK.
   */
  static publicKeyToJwk(publicKeyBytes) {
    return __awaiter8(this, void 0, void 0, function* () {
      let uncompressedPublicKeyBytes;
      if (publicKeyBytes.byteLength === 33) {
        const publicKeyHex = utils2.bytesToHex(publicKeyBytes);
        const curvePoints = Point2.fromHex(publicKeyHex);
        uncompressedPublicKeyBytes = curvePoints.toRawBytes(false);
      } else {
        uncompressedPublicKeyBytes = publicKeyBytes;
      }
      const x2 = Encoder5.bytesToBase64Url(uncompressedPublicKeyBytes.subarray(1, 33));
      const y2 = Encoder5.bytesToBase64Url(uncompressedPublicKeyBytes.subarray(33, 65));
      const publicJwk = {
        alg: "ES256K",
        kty: "EC",
        crv: "secp256k1",
        x: x2,
        y: y2
      };
      return publicJwk;
    });
  }
  /**
   * Converts a private key in bytes into a JWK.
   */
  static privateKeyToJwk(privateKeyBytes) {
    return __awaiter8(this, void 0, void 0, function* () {
      const publicKeyBytes = yield Secp256k1.getPublicKey(privateKeyBytes);
      const jwk = yield Secp256k1.publicKeyToJwk(publicKeyBytes);
      jwk.d = Encoder5.bytesToBase64Url(privateKeyBytes);
      return jwk;
    });
  }
  /**
   * Creates a uncompressed key in raw bytes from the given SECP256K1 JWK.
   */
  static publicJwkToBytes(publicJwk) {
    const x2 = Encoder5.base64UrlToBytes(publicJwk.x);
    const y2 = Encoder5.base64UrlToBytes(publicJwk.y);
    const publicKey = new Uint8Array([4, ...x2, ...y2]);
    return publicKey;
  }
  /**
   * Creates a private key in raw bytes from the given SECP256K1 JWK.
   */
  static privateJwkToBytes(privateJwk) {
    const privateKey = Encoder5.base64UrlToBytes(privateJwk.d);
    return privateKey;
  }
  /**
   * Signs the provided content using the provided JWK.
   */
  static sign(content, privateJwk) {
    return __awaiter8(this, void 0, void 0, function* () {
      Secp256k1.validateKey(privateJwk);
      const hashedContent = yield sha256.encode(content);
      const privateKeyBytes = Secp256k1.privateJwkToBytes(privateJwk);
      return yield sign2(hashedContent, privateKeyBytes, { der: false });
    });
  }
  /**
   * Verifies a signature against the provided payload hash and public key.
   * @returns a boolean indicating whether the signature is valid.
   */
  static verify(content, signature, publicJwk) {
    return __awaiter8(this, void 0, void 0, function* () {
      Secp256k1.validateKey(publicJwk);
      const publicKeyBytes = Secp256k1.publicJwkToBytes(publicJwk);
      const hashedContent = yield sha256.encode(content);
      return verify2(signature, hashedContent, publicKeyBytes);
    });
  }
  /**
   * Generates a random key pair in JWK format.
   */
  static generateKeyPair() {
    return __awaiter8(this, void 0, void 0, function* () {
      const privateKeyBytes = utils2.randomPrivateKey();
      const publicKeyBytes = getPublicKey2(privateKeyBytes);
      const d2 = Encoder5.bytesToBase64Url(privateKeyBytes);
      const publicJwk = yield Secp256k1.publicKeyToJwk(publicKeyBytes);
      const privateJwk = Object.assign(Object.assign({}, publicJwk), { d: d2 });
      return { publicJwk, privateJwk };
    });
  }
  /**
   * Generates key pair in raw bytes, where the `publicKey` is uncompressed.
   */
  static generateKeyPairRaw() {
    return __awaiter8(this, void 0, void 0, function* () {
      const privateKey = utils2.randomPrivateKey();
      const publicKey = getPublicKey2(privateKey);
      return { publicKey, privateKey };
    });
  }
  /**
   * Gets the uncompressed public key of the given private key.
   */
  static getPublicKey(privateKey) {
    return __awaiter8(this, void 0, void 0, function* () {
      const compressedPublicKey = false;
      const publicKey = getPublicKey2(privateKey, compressedPublicKey);
      return publicKey;
    });
  }
  /**
   * Derives a hierarchical deterministic public key.
   * @param key Either a private or an uncompressed public key used to derive the descendant public key.
   * @returns uncompressed public key
   */
  static derivePublicKey(key, relativePath) {
    return __awaiter8(this, void 0, void 0, function* () {
      Secp256k1.validateKeyDerivationPath(relativePath);
      let currentPublicKey;
      if (key.length === 32) {
        currentPublicKey = getPublicKey2(key);
      } else {
        currentPublicKey = key;
      }
      for (const segment of relativePath) {
        const hash = yield sha256.encode(Encoder5.stringToBytes(segment));
        currentPublicKey = Secp256k1.deriveChildPublicKey(currentPublicKey, hash);
      }
      return currentPublicKey;
    });
  }
  /**
   * Derives a hierarchical deterministic private key.
   */
  static derivePrivateKey(privateKey, relativePath) {
    return __awaiter8(this, void 0, void 0, function* () {
      Secp256k1.validateKeyDerivationPath(relativePath);
      let currentPrivateKey = privateKey;
      for (const segment of relativePath) {
        const hash = yield sha256.encode(Encoder5.stringToBytes(segment));
        currentPrivateKey = Secp256k1.deriveChildPrivateKey(currentPrivateKey, hash);
      }
      return currentPrivateKey;
    });
  }
  /**
   * Derives a child public key using the given tweak input.
   */
  static deriveChildPublicKey(uncompressedPublicKey, tweakInput) {
    const compressedPublicKey = false;
    const publicKeyBuffer = Buffer.from(uncompressedPublicKey);
    const tweakBuffer = Buffer.from(tweakInput);
    const derivedPublicKey = import_secp256k1.default.publicKeyTweakAdd(publicKeyBuffer, tweakBuffer, compressedPublicKey);
    return derivedPublicKey;
  }
  /**
   * Derives a child private key using the given tweak input.
   */
  static deriveChildPrivateKey(privateKey, tweakInput) {
    const privateKeyBuffer = Buffer.from(privateKey);
    const tweakBuffer = Buffer.from(tweakInput);
    const derivedPrivateKey = import_secp256k1.default.privateKeyTweakAdd(privateKeyBuffer, tweakBuffer);
    return derivedPrivateKey;
  }
  /**
   * Parses the given key derivation path.
   * @returns Path segments if successfully validate the derivation path.
   * @throws {DwnError} with `DwnErrorCode.HdKeyDerivationPathInvalid` if derivation path fails validation.
   */
  static validateKeyDerivationPath(pathSegments) {
    if (pathSegments.includes("")) {
      throw new DwnError(DwnErrorCode.HdKeyDerivationPathInvalid, `Invalid key derivation path: ${pathSegments}`);
    }
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/jose/algorithms/signing/signers.js
var signers = {
  "Ed25519": ed25519,
  "secp256k1": {
    sign: Secp256k1.sign,
    verify: Secp256k1.verify,
    generateKeyPair: Secp256k1.generateKeyPair,
    publicKeyToJwk: Secp256k1.publicKeyToJwk
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/jose/jws/general/signer.js
var __awaiter9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var GeneralJwsSigner = class {
  constructor(jws) {
    this.jws = jws;
  }
  static create(payload, signatureInputs = []) {
    return __awaiter9(this, void 0, void 0, function* () {
      const jws = {
        payload: Encoder5.bytesToBase64Url(payload),
        signatures: []
      };
      const signer = new GeneralJwsSigner(jws);
      for (const signatureInput of signatureInputs) {
        yield signer.addSignature(signatureInput);
      }
      return signer;
    });
  }
  addSignature(signatureInput) {
    return __awaiter9(this, void 0, void 0, function* () {
      const { privateJwk, protectedHeader } = signatureInput;
      const signer = signers[privateJwk.crv];
      if (!signer) {
        throw new Error(`unsupported crv. crv must be one of ${Object.keys(signers)}`);
      }
      const protectedHeaderString = JSON.stringify(protectedHeader);
      const protectedHeaderBase64UrlString = Encoder5.stringToBase64Url(protectedHeaderString);
      const signingInputString = `${protectedHeaderBase64UrlString}.${this.jws.payload}`;
      const signingInputBytes = Encoder5.stringToBytes(signingInputString);
      const signatureBytes = yield signer.sign(signingInputBytes, privateJwk);
      const signature = Encoder5.bytesToBase64Url(signatureBytes);
      this.jws.signatures.push({ protected: protectedHeaderBase64UrlString, signature });
    });
  }
  getJws() {
    return this.jws;
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/jws.js
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
var __awaiter10 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Jws = class {
  /**
   * Gets the `kid` from a general JWS signature entry.
   */
  static getKid(signatureEntry) {
    const { kid } = Encoder5.base64UrlToObject(signatureEntry.protected);
    return kid;
  }
  /**
   * Gets the signer DID from a general JWS signature entry.
   */
  static getSignerDid(signatureEntry) {
    const kid = Jws.getKid(signatureEntry);
    const did = Jws.extractDid(kid);
    return did;
  }
  /**
   * Verifies the signature against the given payload.
   * @returns `true` if signature is valid; `false` otherwise
   */
  static verifySignature(base64UrlPayload, signatureEntry, jwkPublic) {
    return __awaiter10(this, void 0, void 0, function* () {
      const verifier = signers[jwkPublic.crv];
      if (!verifier) {
        throw new Error(`unsupported crv. crv must be one of ${Object.keys(signers)}`);
      }
      const payload = Encoder5.stringToBytes(`${signatureEntry.protected}.${base64UrlPayload}`);
      const signatureBytes = Encoder5.base64UrlToBytes(signatureEntry.signature);
      return yield verifier.verify(payload, signatureBytes, jwkPublic);
    });
  }
  /**
   * Decodes the payload of the given JWS object as a plain object.
   */
  static decodePlainObjectPayload(jws) {
    let payloadJson;
    try {
      payloadJson = Encoder5.base64UrlToObject(jws.payload);
    } catch (_a2) {
      throw new Error("payload is not a JSON object");
    }
    if (!(0, import_isPlainObject.default)(payloadJson)) {
      throw new Error("signed payload must be a plain object");
    }
    return payloadJson;
  }
  /**
   * Extracts the DID from the given `kid` string.
   */
  static extractDid(kid) {
    const [did] = kid.split("#");
    return did;
  }
  /**
   * Creates a SignatureInput[] from the given Personas.
   */
  static createSignatureInputs(keyMaterials) {
    const signatureInputs = keyMaterials.map((keyMaterial) => Jws.createSignatureInput(keyMaterial));
    return signatureInputs;
  }
  /**
   * Creates a SignatureInput from the given Persona.
   */
  static createSignatureInput(keyMaterial) {
    const signatureInput = {
      privateJwk: keyMaterial.keyPair.privateJwk,
      protectedHeader: {
        alg: keyMaterial.keyPair.privateJwk.alg,
        kid: keyMaterial.keyId
      }
    };
    return signatureInput;
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/string.js
function lexicographicalCompare(a2, b2) {
  if (a2 > b2) {
    return 1;
  } else if (a2 < b2) {
    return -1;
  } else {
    return 0;
  }
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/generated/precompiled-validators.js
var precompiled_validators_exports = {};
__export(precompiled_validators_exports, {
  Definitions: () => Definitions,
  EventsGet: () => EventsGet,
  GeneralJwk: () => GeneralJwk,
  GeneralJws: () => GeneralJws,
  HooksWrite: () => HooksWrite,
  JwkVerificationMethod: () => JwkVerificationMethod,
  MessagesGet: () => MessagesGet,
  PermissionsDefinitions: () => PermissionsDefinitions,
  PermissionsGrant: () => PermissionsGrant,
  PermissionsRequest: () => PermissionsRequest,
  ProtocolDefinition: () => ProtocolDefinition,
  ProtocolRuleSet: () => ProtocolRuleSet,
  ProtocolsConfigure: () => ProtocolsConfigure,
  ProtocolsQuery: () => ProtocolsQuery,
  PublicJwk: () => PublicJwk,
  RecordsDelete: () => RecordsDelete,
  RecordsQuery: () => RecordsQuery,
  RecordsRead: () => RecordsRead,
  RecordsWrite: () => RecordsWrite
});
var RecordsDelete = validate10;
var schema11 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/records-delete.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "dateModified", "recordId"], "properties": { "interface": { "enum": ["Records"], "type": "string" }, "method": { "enum": ["Delete"], "type": "string" }, "dateModified": { "type": "string" }, "recordId": { "type": "string" } } } } };
var pattern0 = new RegExp("^[A-Za-z0-9_-]+$", "u");
function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "payload" || key0 === "signatures")) {
          validate11.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.payload !== void 0) {
          let data0 = data.payload;
          const _errs2 = errors;
          const _errs3 = errors;
          if (errors === _errs3) {
            if (typeof data0 === "string") {
              if (!pattern0.test(data0)) {
                validate11.errors = [{ instancePath: instancePath + "/payload", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_-]+$" }, message: 'must match pattern "^[A-Za-z0-9_-]+$"' }];
                return false;
              }
            } else {
              validate11.errors = [{ instancePath: instancePath + "/payload", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.signatures !== void 0) {
            let data1 = data.signatures;
            const _errs5 = errors;
            if (errors === _errs5) {
              if (Array.isArray(data1)) {
                if (data1.length < 1) {
                  validate11.errors = [{ instancePath: instancePath + "/signatures", schemaPath: "#/properties/signatures/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                  return false;
                } else {
                  var valid2 = true;
                  const len0 = data1.length;
                  for (let i0 = 0; i0 < len0; i0++) {
                    let data2 = data1[i0];
                    const _errs7 = errors;
                    if (errors === _errs7) {
                      if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                        if (data2.protected !== void 0) {
                          let data3 = data2.protected;
                          const _errs9 = errors;
                          const _errs10 = errors;
                          if (errors === _errs10) {
                            if (typeof data3 === "string") {
                              if (!pattern0.test(data3)) {
                                validate11.errors = [{ instancePath: instancePath + "/signatures/" + i0 + "/protected", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_-]+$" }, message: 'must match pattern "^[A-Za-z0-9_-]+$"' }];
                                return false;
                              }
                            } else {
                              validate11.errors = [{ instancePath: instancePath + "/signatures/" + i0 + "/protected", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          var valid3 = _errs9 === errors;
                        } else {
                          var valid3 = true;
                        }
                        if (valid3) {
                          if (data2.signature !== void 0) {
                            let data4 = data2.signature;
                            const _errs12 = errors;
                            const _errs13 = errors;
                            if (errors === _errs13) {
                              if (typeof data4 === "string") {
                                if (!pattern0.test(data4)) {
                                  validate11.errors = [{ instancePath: instancePath + "/signatures/" + i0 + "/signature", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_-]+$" }, message: 'must match pattern "^[A-Za-z0-9_-]+$"' }];
                                  return false;
                                }
                              } else {
                                validate11.errors = [{ instancePath: instancePath + "/signatures/" + i0 + "/signature", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            var valid3 = _errs12 === errors;
                          } else {
                            var valid3 = true;
                          }
                        }
                      } else {
                        validate11.errors = [{ instancePath: instancePath + "/signatures/" + i0, schemaPath: "#/properties/signatures/items/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid2 = _errs7 === errors;
                    if (!valid2) {
                      break;
                    }
                  }
                }
              } else {
                validate11.errors = [{ instancePath: instancePath + "/signatures", schemaPath: "#/properties/signatures/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                return false;
              }
            }
            var valid0 = _errs5 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate11.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate11.errors = vErrors;
  return errors === 0;
}
function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate10.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate10.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method") || data1.dateModified === void 0 && (missing1 = "dateModified") || data1.recordId === void 0 && (missing1 = "recordId")) {
                    validate10.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "dateModified" || key1 === "recordId")) {
                        validate10.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate10.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Records")) {
                          validate10.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema11.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate10.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Delete")) {
                            validate10.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema11.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.dateModified !== void 0) {
                            const _errs10 = errors;
                            if (typeof data1.dateModified !== "string") {
                              validate10.errors = [{ instancePath: instancePath + "/descriptor/dateModified", schemaPath: "#/properties/descriptor/properties/dateModified/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data1.recordId !== void 0) {
                              const _errs12 = errors;
                              if (typeof data1.recordId !== "string") {
                                validate10.errors = [{ instancePath: instancePath + "/descriptor/recordId", schemaPath: "#/properties/descriptor/properties/recordId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                              var valid1 = _errs12 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate10.errors = vErrors;
  return errors === 0;
}
var RecordsQuery = validate14;
var schema17 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/records-query.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "dateCreated", "filter"], "properties": { "interface": { "enum": ["Records"], "type": "string" }, "method": { "enum": ["Query"], "type": "string" }, "dateCreated": { "type": "string" }, "filter": { "type": "object", "minProperties": 1, "additionalProperties": false, "properties": { "protocol": { "type": "string" }, "attester": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did" }, "recipient": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did" }, "contextId": { "type": "string" }, "schema": { "type": "string" }, "recordId": { "type": "string" }, "parentId": { "type": "string" }, "dataFormat": { "type": "string" }, "dateCreated": { "type": "object", "minProperties": 1, "additionalProperties": false, "properties": { "from": { "type": "string" }, "to": { "type": "string" } } } } }, "dateSort": { "enum": ["createdAscending", "createdDescending", "publishedAscending", "publishedDescending"], "type": "string" } } } } };
var func2 = Object.prototype.hasOwnProperty;
var pattern3 = new RegExp("^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$", "u");
function validate14(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate14.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate14.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method") || data1.dateCreated === void 0 && (missing1 = "dateCreated") || data1.filter === void 0 && (missing1 = "filter")) {
                    validate14.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "dateCreated" || key1 === "filter" || key1 === "dateSort")) {
                        validate14.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate14.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Records")) {
                          validate14.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema17.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate14.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Query")) {
                            validate14.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema17.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.dateCreated !== void 0) {
                            const _errs10 = errors;
                            if (typeof data1.dateCreated !== "string") {
                              validate14.errors = [{ instancePath: instancePath + "/descriptor/dateCreated", schemaPath: "#/properties/descriptor/properties/dateCreated/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data1.filter !== void 0) {
                              let data5 = data1.filter;
                              const _errs12 = errors;
                              if (errors === _errs12) {
                                if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                                  if (Object.keys(data5).length < 1) {
                                    validate14.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/minProperties", keyword: "minProperties", params: { limit: 1 }, message: "must NOT have fewer than 1 properties" }];
                                    return false;
                                  } else {
                                    const _errs14 = errors;
                                    for (const key2 in data5) {
                                      if (!func2.call(schema17.properties.descriptor.properties.filter.properties, key2)) {
                                        validate14.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                                        return false;
                                        break;
                                      }
                                    }
                                    if (_errs14 === errors) {
                                      if (data5.protocol !== void 0) {
                                        const _errs15 = errors;
                                        if (typeof data5.protocol !== "string") {
                                          validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/protocol", schemaPath: "#/properties/descriptor/properties/filter/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                          return false;
                                        }
                                        var valid2 = _errs15 === errors;
                                      } else {
                                        var valid2 = true;
                                      }
                                      if (valid2) {
                                        if (data5.attester !== void 0) {
                                          let data7 = data5.attester;
                                          const _errs17 = errors;
                                          const _errs18 = errors;
                                          if (errors === _errs18) {
                                            if (typeof data7 === "string") {
                                              if (!pattern3.test(data7)) {
                                                validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/attester", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                                return false;
                                              }
                                            } else {
                                              validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/attester", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                          var valid2 = _errs17 === errors;
                                        } else {
                                          var valid2 = true;
                                        }
                                        if (valid2) {
                                          if (data5.recipient !== void 0) {
                                            let data8 = data5.recipient;
                                            const _errs20 = errors;
                                            const _errs21 = errors;
                                            if (errors === _errs21) {
                                              if (typeof data8 === "string") {
                                                if (!pattern3.test(data8)) {
                                                  validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/recipient", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                                  return false;
                                                }
                                              } else {
                                                validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/recipient", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                            var valid2 = _errs20 === errors;
                                          } else {
                                            var valid2 = true;
                                          }
                                          if (valid2) {
                                            if (data5.contextId !== void 0) {
                                              const _errs23 = errors;
                                              if (typeof data5.contextId !== "string") {
                                                validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/contextId", schemaPath: "#/properties/descriptor/properties/filter/properties/contextId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                              var valid2 = _errs23 === errors;
                                            } else {
                                              var valid2 = true;
                                            }
                                            if (valid2) {
                                              if (data5.schema !== void 0) {
                                                const _errs25 = errors;
                                                if (typeof data5.schema !== "string") {
                                                  validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/schema", schemaPath: "#/properties/descriptor/properties/filter/properties/schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                  return false;
                                                }
                                                var valid2 = _errs25 === errors;
                                              } else {
                                                var valid2 = true;
                                              }
                                              if (valid2) {
                                                if (data5.recordId !== void 0) {
                                                  const _errs27 = errors;
                                                  if (typeof data5.recordId !== "string") {
                                                    validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/recordId", schemaPath: "#/properties/descriptor/properties/filter/properties/recordId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                    return false;
                                                  }
                                                  var valid2 = _errs27 === errors;
                                                } else {
                                                  var valid2 = true;
                                                }
                                                if (valid2) {
                                                  if (data5.parentId !== void 0) {
                                                    const _errs29 = errors;
                                                    if (typeof data5.parentId !== "string") {
                                                      validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/parentId", schemaPath: "#/properties/descriptor/properties/filter/properties/parentId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                    var valid2 = _errs29 === errors;
                                                  } else {
                                                    var valid2 = true;
                                                  }
                                                  if (valid2) {
                                                    if (data5.dataFormat !== void 0) {
                                                      const _errs31 = errors;
                                                      if (typeof data5.dataFormat !== "string") {
                                                        validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/dataFormat", schemaPath: "#/properties/descriptor/properties/filter/properties/dataFormat/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                        return false;
                                                      }
                                                      var valid2 = _errs31 === errors;
                                                    } else {
                                                      var valid2 = true;
                                                    }
                                                    if (valid2) {
                                                      if (data5.dateCreated !== void 0) {
                                                        let data14 = data5.dateCreated;
                                                        const _errs33 = errors;
                                                        if (errors === _errs33) {
                                                          if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
                                                            if (Object.keys(data14).length < 1) {
                                                              validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/dateCreated", schemaPath: "#/properties/descriptor/properties/filter/properties/dateCreated/minProperties", keyword: "minProperties", params: { limit: 1 }, message: "must NOT have fewer than 1 properties" }];
                                                              return false;
                                                            } else {
                                                              const _errs35 = errors;
                                                              for (const key3 in data14) {
                                                                if (!(key3 === "from" || key3 === "to")) {
                                                                  validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/dateCreated", schemaPath: "#/properties/descriptor/properties/filter/properties/dateCreated/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" }];
                                                                  return false;
                                                                  break;
                                                                }
                                                              }
                                                              if (_errs35 === errors) {
                                                                if (data14.from !== void 0) {
                                                                  const _errs36 = errors;
                                                                  if (typeof data14.from !== "string") {
                                                                    validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/dateCreated/from", schemaPath: "#/properties/descriptor/properties/filter/properties/dateCreated/properties/from/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                    return false;
                                                                  }
                                                                  var valid5 = _errs36 === errors;
                                                                } else {
                                                                  var valid5 = true;
                                                                }
                                                                if (valid5) {
                                                                  if (data14.to !== void 0) {
                                                                    const _errs38 = errors;
                                                                    if (typeof data14.to !== "string") {
                                                                      validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/dateCreated/to", schemaPath: "#/properties/descriptor/properties/filter/properties/dateCreated/properties/to/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                      return false;
                                                                    }
                                                                    var valid5 = _errs38 === errors;
                                                                  } else {
                                                                    var valid5 = true;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            validate14.errors = [{ instancePath: instancePath + "/descriptor/filter/dateCreated", schemaPath: "#/properties/descriptor/properties/filter/properties/dateCreated/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                            return false;
                                                          }
                                                        }
                                                        var valid2 = _errs33 === errors;
                                                      } else {
                                                        var valid2 = true;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  validate14.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                  return false;
                                }
                              }
                              var valid1 = _errs12 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data1.dateSort !== void 0) {
                                let data17 = data1.dateSort;
                                const _errs40 = errors;
                                if (typeof data17 !== "string") {
                                  validate14.errors = [{ instancePath: instancePath + "/descriptor/dateSort", schemaPath: "#/properties/descriptor/properties/dateSort/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                                if (!(data17 === "createdAscending" || data17 === "createdDescending" || data17 === "publishedAscending" || data17 === "publishedDescending")) {
                                  validate14.errors = [{ instancePath: instancePath + "/descriptor/dateSort", schemaPath: "#/properties/descriptor/properties/dateSort/enum", keyword: "enum", params: { allowedValues: schema17.properties.descriptor.properties.dateSort.enum }, message: "must be equal to one of the allowed values" }];
                                  return false;
                                }
                                var valid1 = _errs40 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate14.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate14.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate14.errors = vErrors;
  return errors === 0;
}
var RecordsWrite = validate16;
var schema20 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/records-write.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor", "recordId"], "properties": { "recordId": { "type": "string" }, "contextId": { "type": "string" }, "attestation": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "encryption": { "type": "object", "properties": { "algorithm": { "type": "string", "enum": ["A256CTR"] }, "initializationVector": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url" }, "keyEncryption": { "type": "array", "minItems": 1, "items": { "type": "object", "properties": { "derivationScheme": { "type": "string", "enum": ["protocol-context"] }, "algorithm": { "type": "string", "enum": ["ECIES-ES256K"] }, "encryptedKey": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url" }, "initializationVector": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url" }, "ephemeralPublicKey": { "$ref": "https://identity.foundation/dwn/json-schemas/public-jwk.json" }, "messageAuthenticationCode": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url" } }, "additionalProperties": false, "required": ["derivationScheme", "algorithm", "encryptedKey", "initializationVector", "ephemeralPublicKey", "messageAuthenticationCode"] } } }, "additionalProperties": false, "required": ["algorithm", "initializationVector", "keyEncryption"] }, "descriptor": { "type": "object", "properties": { "interface": { "enum": ["Records"], "type": "string" }, "method": { "enum": ["Write"], "type": "string" }, "recipient": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did" }, "protocol": { "type": "string" }, "schema": { "type": "string" }, "parentId": { "type": "string" }, "dataCid": { "type": "string" }, "dataSize": { "type": "number" }, "dateCreated": { "type": "string" }, "dateModified": { "type": "string" }, "published": { "type": "boolean" }, "datePublished": { "type": "string" }, "dataFormat": { "type": "string" } }, "additionalProperties": false, "required": ["interface", "method", "dataCid", "dataSize", "dateCreated", "dateModified", "dataFormat"], "allOf": [{ "$comment": "rule defining `published` and `datePublished` relationship", "anyOf": [{ "properties": { "published": { "type": "boolean", "enum": [true] } }, "required": ["published", "datePublished"] }, { "properties": { "published": { "type": "boolean", "enum": [false] } }, "not": { "required": ["datePublished"] } }, { "allOf": [{ "not": { "required": ["published"] } }, { "not": { "required": ["datePublished"] } }] }] }] } }, "$comment": "rule defining `protocol` and `contextId` relationship", "anyOf": [{ "properties": { "descriptor": { "type": "object", "required": ["protocol"] } }, "required": ["contextId"] }, { "allOf": [{ "not": { "required": ["contextId"] } }, { "properties": { "descriptor": { "type": "object", "not": { "required": ["protocol"] } } } }] }] };
var schema25 = { "$id": "https://identity.foundation/dwn/json-schemas/general-jwk.json", "$schema": "http://json-schema.org/draft-07/schema#", "type": "object", "required": ["kty"], "properties": { "alg": { "type": "string" }, "kid": { "type": "string" }, "kty": { "enum": ["EC", "RSA", "oct", "OKP"] }, "crv": { "type": "string" }, "use": { "type": "string" }, "key_ops": { "type": "string" }, "x5u": { "type": "string" }, "x5c": { "type": "string" }, "x5t": { "type": "string" }, "x5t#S256": { "type": "string" } }, "oneOf": [{ "properties": { "kty": { "const": "EC" }, "crv": { "type": "string" }, "x": { "type": "string" }, "y": { "type": "string" }, "d": { "type": "string" } }, "required": ["crv", "x"] }, { "properties": { "kty": { "const": "OKP" }, "crv": { "type": "string" }, "x": { "type": "string" }, "d": { "type": "string" } }, "required": ["crv", "x"] }, { "properties": { "kty": { "const": "RSA" }, "n": { "type": "string" }, "e": { "type": "string" }, "d": { "type": "string" }, "p": { "type": "string" }, "q": { "type": "string" }, "dp": { "type": "string" }, "dq": { "type": "string" }, "qi": { "type": "string" }, "oth": { "type": "object" } }, "required": ["n", "e"] }, { "properties": { "kty": { "const": "oct" }, "k": { "type": "string" } }, "required": ["k"] }] };
function validate19(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  const _errs2 = errors;
  let valid1 = false;
  let passing0 = null;
  const _errs3 = errors;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    let missing0;
    if (data.crv === void 0 && (missing0 = "crv") || data.x === void 0 && (missing0 = "x")) {
      const err0 = { instancePath, schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    } else {
      if (data.kty !== void 0) {
        const _errs4 = errors;
        if ("EC" !== data.kty) {
          const err1 = { instancePath: instancePath + "/kty", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/0/properties/kty/const", keyword: "const", params: { allowedValue: "EC" }, message: "must be equal to constant" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
        var valid2 = _errs4 === errors;
      } else {
        var valid2 = true;
      }
      if (valid2) {
        if (data.crv !== void 0) {
          const _errs5 = errors;
          if (typeof data.crv !== "string") {
            const err2 = { instancePath: instancePath + "/crv", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/0/properties/crv/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
          var valid2 = _errs5 === errors;
        } else {
          var valid2 = true;
        }
        if (valid2) {
          if (data.x !== void 0) {
            const _errs7 = errors;
            if (typeof data.x !== "string") {
              const err3 = { instancePath: instancePath + "/x", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/0/properties/x/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors++;
            }
            var valid2 = _errs7 === errors;
          } else {
            var valid2 = true;
          }
          if (valid2) {
            if (data.y !== void 0) {
              const _errs9 = errors;
              if (typeof data.y !== "string") {
                const err4 = { instancePath: instancePath + "/y", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/0/properties/y/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
              var valid2 = _errs9 === errors;
            } else {
              var valid2 = true;
            }
            if (valid2) {
              if (data.d !== void 0) {
                const _errs11 = errors;
                if (typeof data.d !== "string") {
                  const err5 = { instancePath: instancePath + "/d", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/0/properties/d/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                }
                var valid2 = _errs11 === errors;
              } else {
                var valid2 = true;
              }
            }
          }
        }
      }
    }
  }
  var _valid0 = _errs3 === errors;
  if (_valid0) {
    valid1 = true;
    passing0 = 0;
  }
  const _errs13 = errors;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    let missing1;
    if (data.crv === void 0 && (missing1 = "crv") || data.x === void 0 && (missing1 = "x")) {
      const err6 = { instancePath, schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    } else {
      if (data.kty !== void 0) {
        const _errs14 = errors;
        if ("OKP" !== data.kty) {
          const err7 = { instancePath: instancePath + "/kty", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/1/properties/kty/const", keyword: "const", params: { allowedValue: "OKP" }, message: "must be equal to constant" };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors++;
        }
        var valid3 = _errs14 === errors;
      } else {
        var valid3 = true;
      }
      if (valid3) {
        if (data.crv !== void 0) {
          const _errs15 = errors;
          if (typeof data.crv !== "string") {
            const err8 = { instancePath: instancePath + "/crv", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/1/properties/crv/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
          var valid3 = _errs15 === errors;
        } else {
          var valid3 = true;
        }
        if (valid3) {
          if (data.x !== void 0) {
            const _errs17 = errors;
            if (typeof data.x !== "string") {
              const err9 = { instancePath: instancePath + "/x", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/1/properties/x/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
            var valid3 = _errs17 === errors;
          } else {
            var valid3 = true;
          }
          if (valid3) {
            if (data.d !== void 0) {
              const _errs19 = errors;
              if (typeof data.d !== "string") {
                const err10 = { instancePath: instancePath + "/d", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/1/properties/d/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors++;
              }
              var valid3 = _errs19 === errors;
            } else {
              var valid3 = true;
            }
          }
        }
      }
    }
  }
  var _valid0 = _errs13 === errors;
  if (_valid0 && valid1) {
    valid1 = false;
    passing0 = [passing0, 1];
  } else {
    if (_valid0) {
      valid1 = true;
      passing0 = 1;
    }
    const _errs21 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing2;
      if (data.n === void 0 && (missing2 = "n") || data.e === void 0 && (missing2 = "e")) {
        const err11 = { instancePath, schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
        if (vErrors === null) {
          vErrors = [err11];
        } else {
          vErrors.push(err11);
        }
        errors++;
      } else {
        if (data.kty !== void 0) {
          const _errs22 = errors;
          if ("RSA" !== data.kty) {
            const err12 = { instancePath: instancePath + "/kty", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/kty/const", keyword: "const", params: { allowedValue: "RSA" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors++;
          }
          var valid4 = _errs22 === errors;
        } else {
          var valid4 = true;
        }
        if (valid4) {
          if (data.n !== void 0) {
            const _errs23 = errors;
            if (typeof data.n !== "string") {
              const err13 = { instancePath: instancePath + "/n", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/n/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
            var valid4 = _errs23 === errors;
          } else {
            var valid4 = true;
          }
          if (valid4) {
            if (data.e !== void 0) {
              const _errs25 = errors;
              if (typeof data.e !== "string") {
                const err14 = { instancePath: instancePath + "/e", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/e/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors++;
              }
              var valid4 = _errs25 === errors;
            } else {
              var valid4 = true;
            }
            if (valid4) {
              if (data.d !== void 0) {
                const _errs27 = errors;
                if (typeof data.d !== "string") {
                  const err15 = { instancePath: instancePath + "/d", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/d/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err15];
                  } else {
                    vErrors.push(err15);
                  }
                  errors++;
                }
                var valid4 = _errs27 === errors;
              } else {
                var valid4 = true;
              }
              if (valid4) {
                if (data.p !== void 0) {
                  const _errs29 = errors;
                  if (typeof data.p !== "string") {
                    const err16 = { instancePath: instancePath + "/p", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/p/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err16];
                    } else {
                      vErrors.push(err16);
                    }
                    errors++;
                  }
                  var valid4 = _errs29 === errors;
                } else {
                  var valid4 = true;
                }
                if (valid4) {
                  if (data.q !== void 0) {
                    const _errs31 = errors;
                    if (typeof data.q !== "string") {
                      const err17 = { instancePath: instancePath + "/q", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/q/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err17];
                      } else {
                        vErrors.push(err17);
                      }
                      errors++;
                    }
                    var valid4 = _errs31 === errors;
                  } else {
                    var valid4 = true;
                  }
                  if (valid4) {
                    if (data.dp !== void 0) {
                      const _errs33 = errors;
                      if (typeof data.dp !== "string") {
                        const err18 = { instancePath: instancePath + "/dp", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/dp/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err18];
                        } else {
                          vErrors.push(err18);
                        }
                        errors++;
                      }
                      var valid4 = _errs33 === errors;
                    } else {
                      var valid4 = true;
                    }
                    if (valid4) {
                      if (data.dq !== void 0) {
                        const _errs35 = errors;
                        if (typeof data.dq !== "string") {
                          const err19 = { instancePath: instancePath + "/dq", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/dq/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err19];
                          } else {
                            vErrors.push(err19);
                          }
                          errors++;
                        }
                        var valid4 = _errs35 === errors;
                      } else {
                        var valid4 = true;
                      }
                      if (valid4) {
                        if (data.qi !== void 0) {
                          const _errs37 = errors;
                          if (typeof data.qi !== "string") {
                            const err20 = { instancePath: instancePath + "/qi", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/qi/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err20];
                            } else {
                              vErrors.push(err20);
                            }
                            errors++;
                          }
                          var valid4 = _errs37 === errors;
                        } else {
                          var valid4 = true;
                        }
                        if (valid4) {
                          if (data.oth !== void 0) {
                            let data18 = data.oth;
                            const _errs39 = errors;
                            if (!(data18 && typeof data18 == "object" && !Array.isArray(data18))) {
                              const err21 = { instancePath: instancePath + "/oth", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/2/properties/oth/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                              if (vErrors === null) {
                                vErrors = [err21];
                              } else {
                                vErrors.push(err21);
                              }
                              errors++;
                            }
                            var valid4 = _errs39 === errors;
                          } else {
                            var valid4 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    var _valid0 = _errs21 === errors;
    if (_valid0 && valid1) {
      valid1 = false;
      passing0 = [passing0, 2];
    } else {
      if (_valid0) {
        valid1 = true;
        passing0 = 2;
      }
      const _errs41 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing3;
        if (data.k === void 0 && (missing3 = "k")) {
          const err22 = { instancePath, schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/3/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
          if (vErrors === null) {
            vErrors = [err22];
          } else {
            vErrors.push(err22);
          }
          errors++;
        } else {
          if (data.kty !== void 0) {
            const _errs42 = errors;
            if ("oct" !== data.kty) {
              const err23 = { instancePath: instancePath + "/kty", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/3/properties/kty/const", keyword: "const", params: { allowedValue: "oct" }, message: "must be equal to constant" };
              if (vErrors === null) {
                vErrors = [err23];
              } else {
                vErrors.push(err23);
              }
              errors++;
            }
            var valid5 = _errs42 === errors;
          } else {
            var valid5 = true;
          }
          if (valid5) {
            if (data.k !== void 0) {
              const _errs43 = errors;
              if (typeof data.k !== "string") {
                const err24 = { instancePath: instancePath + "/k", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf/3/properties/k/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err24];
                } else {
                  vErrors.push(err24);
                }
                errors++;
              }
              var valid5 = _errs43 === errors;
            } else {
              var valid5 = true;
            }
          }
        }
      }
      var _valid0 = _errs41 === errors;
      if (_valid0 && valid1) {
        valid1 = false;
        passing0 = [passing0, 3];
      } else {
        if (_valid0) {
          valid1 = true;
          passing0 = 3;
        }
      }
    }
  }
  if (!valid1) {
    const err25 = { instancePath, schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
    if (vErrors === null) {
      vErrors = [err25];
    } else {
      vErrors.push(err25);
    }
    errors++;
    validate19.errors = vErrors;
    return false;
  } else {
    errors = _errs2;
    if (vErrors !== null) {
      if (_errs2) {
        vErrors.length = _errs2;
      } else {
        vErrors = null;
      }
    }
  }
  if (errors === _errs0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing4;
      if (data.kty === void 0 && (missing4 = "kty")) {
        validate19.errors = [{ instancePath, schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/required", keyword: "required", params: { missingProperty: missing4 }, message: "must have required property '" + missing4 + "'" }];
        return false;
      } else {
        if (data.alg !== void 0) {
          const _errs45 = errors;
          if (typeof data.alg !== "string") {
            validate19.errors = [{ instancePath: instancePath + "/alg", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/alg/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
            return false;
          }
          var valid6 = _errs45 === errors;
        } else {
          var valid6 = true;
        }
        if (valid6) {
          if (data.kid !== void 0) {
            const _errs47 = errors;
            if (typeof data.kid !== "string") {
              validate19.errors = [{ instancePath: instancePath + "/kid", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/kid/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid6 = _errs47 === errors;
          } else {
            var valid6 = true;
          }
          if (valid6) {
            if (data.kty !== void 0) {
              let data23 = data.kty;
              const _errs49 = errors;
              if (!(data23 === "EC" || data23 === "RSA" || data23 === "oct" || data23 === "OKP")) {
                validate19.errors = [{ instancePath: instancePath + "/kty", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/kty/enum", keyword: "enum", params: { allowedValues: schema25.properties.kty.enum }, message: "must be equal to one of the allowed values" }];
                return false;
              }
              var valid6 = _errs49 === errors;
            } else {
              var valid6 = true;
            }
            if (valid6) {
              if (data.crv !== void 0) {
                const _errs50 = errors;
                if (typeof data.crv !== "string") {
                  validate19.errors = [{ instancePath: instancePath + "/crv", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/crv/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid6 = _errs50 === errors;
              } else {
                var valid6 = true;
              }
              if (valid6) {
                if (data.use !== void 0) {
                  const _errs52 = errors;
                  if (typeof data.use !== "string") {
                    validate19.errors = [{ instancePath: instancePath + "/use", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/use/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid6 = _errs52 === errors;
                } else {
                  var valid6 = true;
                }
                if (valid6) {
                  if (data.key_ops !== void 0) {
                    const _errs54 = errors;
                    if (typeof data.key_ops !== "string") {
                      validate19.errors = [{ instancePath: instancePath + "/key_ops", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/key_ops/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid6 = _errs54 === errors;
                  } else {
                    var valid6 = true;
                  }
                  if (valid6) {
                    if (data.x5u !== void 0) {
                      const _errs56 = errors;
                      if (typeof data.x5u !== "string") {
                        validate19.errors = [{ instancePath: instancePath + "/x5u", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/x5u/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                      var valid6 = _errs56 === errors;
                    } else {
                      var valid6 = true;
                    }
                    if (valid6) {
                      if (data.x5c !== void 0) {
                        const _errs58 = errors;
                        if (typeof data.x5c !== "string") {
                          validate19.errors = [{ instancePath: instancePath + "/x5c", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/x5c/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        var valid6 = _errs58 === errors;
                      } else {
                        var valid6 = true;
                      }
                      if (valid6) {
                        if (data.x5t !== void 0) {
                          const _errs60 = errors;
                          if (typeof data.x5t !== "string") {
                            validate19.errors = [{ instancePath: instancePath + "/x5t", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/x5t/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid6 = _errs60 === errors;
                        } else {
                          var valid6 = true;
                        }
                        if (valid6) {
                          if (data["x5t#S256"] !== void 0) {
                            const _errs62 = errors;
                            if (typeof data["x5t#S256"] !== "string") {
                              validate19.errors = [{ instancePath: instancePath + "/x5t#S256", schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/properties/x5t%23S256/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid6 = _errs62 === errors;
                          } else {
                            var valid6 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate19.errors = [{ instancePath, schemaPath: "https://identity.foundation/dwn/json-schemas/general-jwk.json/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  var valid0 = _errs0 === errors;
  if (valid0) {
    const _errs64 = errors;
    const _errs65 = errors;
    const _errs66 = errors;
    let valid8 = false;
    const _errs67 = errors;
    const _errs69 = errors;
    let valid9 = false;
    const _errs70 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing5;
      if (data.d === void 0 && (missing5 = "d")) {
        const err26 = {};
        if (vErrors === null) {
          vErrors = [err26];
        } else {
          vErrors.push(err26);
        }
        errors++;
      }
    }
    var _valid2 = _errs70 === errors;
    valid9 = valid9 || _valid2;
    if (!valid9) {
      const err27 = {};
      if (vErrors === null) {
        vErrors = [err27];
      } else {
        vErrors.push(err27);
      }
      errors++;
    } else {
      errors = _errs69;
      if (vErrors !== null) {
        if (_errs69) {
          vErrors.length = _errs69;
        } else {
          vErrors = null;
        }
      }
    }
    if (errors === _errs67) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.kty !== void 0) {
          if ("EC" !== data.kty) {
            const err28 = {};
            if (vErrors === null) {
              vErrors = [err28];
            } else {
              vErrors.push(err28);
            }
            errors++;
          }
        }
      } else {
        const err29 = {};
        if (vErrors === null) {
          vErrors = [err29];
        } else {
          vErrors.push(err29);
        }
        errors++;
      }
    }
    var _valid1 = _errs67 === errors;
    valid8 = valid8 || _valid1;
    if (!valid8) {
      const _errs72 = errors;
      const _errs74 = errors;
      let valid11 = false;
      const _errs75 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing6;
        if (data.d === void 0 && (missing6 = "d")) {
          const err30 = {};
          if (vErrors === null) {
            vErrors = [err30];
          } else {
            vErrors.push(err30);
          }
          errors++;
        }
      }
      var _valid3 = _errs75 === errors;
      valid11 = valid11 || _valid3;
      if (!valid11) {
        const err31 = {};
        if (vErrors === null) {
          vErrors = [err31];
        } else {
          vErrors.push(err31);
        }
        errors++;
      } else {
        errors = _errs74;
        if (vErrors !== null) {
          if (_errs74) {
            vErrors.length = _errs74;
          } else {
            vErrors = null;
          }
        }
      }
      if (errors === _errs72) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.kty !== void 0) {
            if ("OKP" !== data.kty) {
              const err32 = {};
              if (vErrors === null) {
                vErrors = [err32];
              } else {
                vErrors.push(err32);
              }
              errors++;
            }
          }
        } else {
          const err33 = {};
          if (vErrors === null) {
            vErrors = [err33];
          } else {
            vErrors.push(err33);
          }
          errors++;
        }
      }
      var _valid1 = _errs72 === errors;
      valid8 = valid8 || _valid1;
      if (!valid8) {
        const _errs77 = errors;
        const _errs79 = errors;
        let valid13 = false;
        const _errs80 = errors;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          let missing7;
          if (data.d === void 0 && (missing7 = "d")) {
            const err34 = {};
            if (vErrors === null) {
              vErrors = [err34];
            } else {
              vErrors.push(err34);
            }
            errors++;
          }
        }
        var _valid4 = _errs80 === errors;
        valid13 = valid13 || _valid4;
        if (!valid13) {
          const _errs81 = errors;
          if (data && typeof data == "object" && !Array.isArray(data)) {
            let missing8;
            if (data.p === void 0 && (missing8 = "p")) {
              const err35 = {};
              if (vErrors === null) {
                vErrors = [err35];
              } else {
                vErrors.push(err35);
              }
              errors++;
            }
          }
          var _valid4 = _errs81 === errors;
          valid13 = valid13 || _valid4;
          if (!valid13) {
            const _errs82 = errors;
            if (data && typeof data == "object" && !Array.isArray(data)) {
              let missing9;
              if (data.q === void 0 && (missing9 = "q")) {
                const err36 = {};
                if (vErrors === null) {
                  vErrors = [err36];
                } else {
                  vErrors.push(err36);
                }
                errors++;
              }
            }
            var _valid4 = _errs82 === errors;
            valid13 = valid13 || _valid4;
            if (!valid13) {
              const _errs83 = errors;
              if (data && typeof data == "object" && !Array.isArray(data)) {
                let missing10;
                if (data.dp === void 0 && (missing10 = "dp")) {
                  const err37 = {};
                  if (vErrors === null) {
                    vErrors = [err37];
                  } else {
                    vErrors.push(err37);
                  }
                  errors++;
                }
              }
              var _valid4 = _errs83 === errors;
              valid13 = valid13 || _valid4;
              if (!valid13) {
                const _errs84 = errors;
                if (data && typeof data == "object" && !Array.isArray(data)) {
                  let missing11;
                  if (data.dq === void 0 && (missing11 = "dq")) {
                    const err38 = {};
                    if (vErrors === null) {
                      vErrors = [err38];
                    } else {
                      vErrors.push(err38);
                    }
                    errors++;
                  }
                }
                var _valid4 = _errs84 === errors;
                valid13 = valid13 || _valid4;
                if (!valid13) {
                  const _errs85 = errors;
                  if (data && typeof data == "object" && !Array.isArray(data)) {
                    let missing12;
                    if (data.qi === void 0 && (missing12 = "qi")) {
                      const err39 = {};
                      if (vErrors === null) {
                        vErrors = [err39];
                      } else {
                        vErrors.push(err39);
                      }
                      errors++;
                    }
                  }
                  var _valid4 = _errs85 === errors;
                  valid13 = valid13 || _valid4;
                  if (!valid13) {
                    const _errs86 = errors;
                    if (data && typeof data == "object" && !Array.isArray(data)) {
                      let missing13;
                      if (data.oth === void 0 && (missing13 = "oth")) {
                        const err40 = {};
                        if (vErrors === null) {
                          vErrors = [err40];
                        } else {
                          vErrors.push(err40);
                        }
                        errors++;
                      }
                    }
                    var _valid4 = _errs86 === errors;
                    valid13 = valid13 || _valid4;
                  }
                }
              }
            }
          }
        }
        if (!valid13) {
          const err41 = {};
          if (vErrors === null) {
            vErrors = [err41];
          } else {
            vErrors.push(err41);
          }
          errors++;
        } else {
          errors = _errs79;
          if (vErrors !== null) {
            if (_errs79) {
              vErrors.length = _errs79;
            } else {
              vErrors = null;
            }
          }
        }
        if (errors === _errs77) {
          if (data && typeof data == "object" && !Array.isArray(data)) {
            if (data.kty !== void 0) {
              const _errs87 = errors;
              if ("RSA" !== data.kty) {
                const err42 = {};
                if (vErrors === null) {
                  vErrors = [err42];
                } else {
                  vErrors.push(err42);
                }
                errors++;
              }
              var valid14 = _errs87 === errors;
            } else {
              var valid14 = true;
            }
            if (valid14) {
              if (data.oth !== void 0) {
                let data34 = data.oth;
                const _errs88 = errors;
                if (!(data34 && typeof data34 == "object" && !Array.isArray(data34))) {
                  const err43 = {};
                  if (vErrors === null) {
                    vErrors = [err43];
                  } else {
                    vErrors.push(err43);
                  }
                  errors++;
                }
                var valid14 = _errs88 === errors;
              } else {
                var valid14 = true;
              }
            }
          } else {
            const err44 = {};
            if (vErrors === null) {
              vErrors = [err44];
            } else {
              vErrors.push(err44);
            }
            errors++;
          }
        }
        var _valid1 = _errs77 === errors;
        valid8 = valid8 || _valid1;
      }
    }
    if (!valid8) {
      const err45 = {};
      if (vErrors === null) {
        vErrors = [err45];
      } else {
        vErrors.push(err45);
      }
      errors++;
    } else {
      errors = _errs66;
      if (vErrors !== null) {
        if (_errs66) {
          vErrors.length = _errs66;
        } else {
          vErrors = null;
        }
      }
    }
    var valid7 = _errs65 === errors;
    if (valid7) {
      validate19.errors = [{ instancePath, schemaPath: "#/not", keyword: "not", params: {}, message: "must NOT be valid" }];
      return false;
    } else {
      errors = _errs64;
      if (vErrors !== null) {
        if (_errs64) {
          vErrors.length = _errs64;
        } else {
          vErrors = null;
        }
      }
    }
  }
  validate19.errors = vErrors;
  return errors === 0;
}
function validate16(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  const _errs2 = errors;
  let valid0 = false;
  const _errs3 = errors;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    let missing0;
    if (data.contextId === void 0 && (missing0 = "contextId")) {
      const err0 = { instancePath, schemaPath: "#/anyOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    } else {
      if (data.descriptor !== void 0) {
        let data0 = data.descriptor;
        const _errs4 = errors;
        if (errors === _errs4) {
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            let missing1;
            if (data0.protocol === void 0 && (missing1 = "protocol")) {
              const err1 = { instancePath: instancePath + "/descriptor", schemaPath: "#/anyOf/0/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
              if (vErrors === null) {
                vErrors = [err1];
              } else {
                vErrors.push(err1);
              }
              errors++;
            }
          } else {
            const err2 = { instancePath: instancePath + "/descriptor", schemaPath: "#/anyOf/0/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
        }
      }
    }
  }
  var _valid0 = _errs3 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    const _errs6 = errors;
    const _errs7 = errors;
    const _errs8 = errors;
    const _errs9 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing2;
      if (data.contextId === void 0 && (missing2 = "contextId")) {
        const err3 = {};
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors++;
      }
    }
    var valid3 = _errs9 === errors;
    if (valid3) {
      const err4 = { instancePath, schemaPath: "#/anyOf/1/allOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
      if (vErrors === null) {
        vErrors = [err4];
      } else {
        vErrors.push(err4);
      }
      errors++;
    } else {
      errors = _errs8;
      if (vErrors !== null) {
        if (_errs8) {
          vErrors.length = _errs8;
        } else {
          vErrors = null;
        }
      }
    }
    var valid2 = _errs7 === errors;
    if (valid2) {
      const _errs10 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.descriptor !== void 0) {
          let data1 = data.descriptor;
          if (!(data1 && typeof data1 == "object" && !Array.isArray(data1))) {
            const err5 = { instancePath: instancePath + "/descriptor", schemaPath: "#/anyOf/1/allOf/1/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
          }
          const _errs13 = errors;
          const _errs14 = errors;
          if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
            let missing3;
            if (data1.protocol === void 0 && (missing3 = "protocol")) {
              const err6 = {};
              if (vErrors === null) {
                vErrors = [err6];
              } else {
                vErrors.push(err6);
              }
              errors++;
            }
          }
          var valid5 = _errs14 === errors;
          if (valid5) {
            const err7 = { instancePath: instancePath + "/descriptor", schemaPath: "#/anyOf/1/allOf/1/properties/descriptor/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          } else {
            errors = _errs13;
            if (vErrors !== null) {
              if (_errs13) {
                vErrors.length = _errs13;
              } else {
                vErrors = null;
              }
            }
          }
        }
      }
      var valid2 = _errs10 === errors;
    }
    var _valid0 = _errs6 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    const err8 = { instancePath, schemaPath: "#/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
    if (vErrors === null) {
      vErrors = [err8];
    } else {
      vErrors.push(err8);
    }
    errors++;
    validate16.errors = vErrors;
    return false;
  } else {
    errors = _errs2;
    if (vErrors !== null) {
      if (_errs2) {
        vErrors.length = _errs2;
      } else {
        vErrors = null;
      }
    }
  }
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing4;
      if (data.authorization === void 0 && (missing4 = "authorization") || data.descriptor === void 0 && (missing4 = "descriptor") || data.recordId === void 0 && (missing4 = "recordId")) {
        validate16.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing4 }, message: "must have required property '" + missing4 + "'" }];
        return false;
      } else {
        const _errs15 = errors;
        for (const key0 in data) {
          if (!(key0 === "recordId" || key0 === "contextId" || key0 === "attestation" || key0 === "authorization" || key0 === "encryption" || key0 === "descriptor")) {
            validate16.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs15 === errors) {
          if (data.recordId !== void 0) {
            const _errs16 = errors;
            if (typeof data.recordId !== "string") {
              validate16.errors = [{ instancePath: instancePath + "/recordId", schemaPath: "#/properties/recordId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid6 = _errs16 === errors;
          } else {
            var valid6 = true;
          }
          if (valid6) {
            if (data.contextId !== void 0) {
              const _errs18 = errors;
              if (typeof data.contextId !== "string") {
                validate16.errors = [{ instancePath: instancePath + "/contextId", schemaPath: "#/properties/contextId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
              var valid6 = _errs18 === errors;
            } else {
              var valid6 = true;
            }
            if (valid6) {
              if (data.attestation !== void 0) {
                const _errs20 = errors;
                if (!validate11(data.attestation, { instancePath: instancePath + "/attestation", parentData: data, parentDataProperty: "attestation", rootData })) {
                  vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                  errors = vErrors.length;
                }
                var valid6 = _errs20 === errors;
              } else {
                var valid6 = true;
              }
              if (valid6) {
                if (data.authorization !== void 0) {
                  const _errs21 = errors;
                  if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
                    vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                    errors = vErrors.length;
                  }
                  var valid6 = _errs21 === errors;
                } else {
                  var valid6 = true;
                }
                if (valid6) {
                  if (data.encryption !== void 0) {
                    let data6 = data.encryption;
                    const _errs22 = errors;
                    if (errors === _errs22) {
                      if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
                        let missing5;
                        if (data6.algorithm === void 0 && (missing5 = "algorithm") || data6.initializationVector === void 0 && (missing5 = "initializationVector") || data6.keyEncryption === void 0 && (missing5 = "keyEncryption")) {
                          validate16.errors = [{ instancePath: instancePath + "/encryption", schemaPath: "#/properties/encryption/required", keyword: "required", params: { missingProperty: missing5 }, message: "must have required property '" + missing5 + "'" }];
                          return false;
                        } else {
                          const _errs24 = errors;
                          for (const key1 in data6) {
                            if (!(key1 === "algorithm" || key1 === "initializationVector" || key1 === "keyEncryption")) {
                              validate16.errors = [{ instancePath: instancePath + "/encryption", schemaPath: "#/properties/encryption/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                              return false;
                              break;
                            }
                          }
                          if (_errs24 === errors) {
                            if (data6.algorithm !== void 0) {
                              let data7 = data6.algorithm;
                              const _errs25 = errors;
                              if (typeof data7 !== "string") {
                                validate16.errors = [{ instancePath: instancePath + "/encryption/algorithm", schemaPath: "#/properties/encryption/properties/algorithm/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                              if (!(data7 === "A256CTR")) {
                                validate16.errors = [{ instancePath: instancePath + "/encryption/algorithm", schemaPath: "#/properties/encryption/properties/algorithm/enum", keyword: "enum", params: { allowedValues: schema20.properties.encryption.properties.algorithm.enum }, message: "must be equal to one of the allowed values" }];
                                return false;
                              }
                              var valid7 = _errs25 === errors;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data6.initializationVector !== void 0) {
                                let data8 = data6.initializationVector;
                                const _errs27 = errors;
                                const _errs28 = errors;
                                if (errors === _errs28) {
                                  if (typeof data8 === "string") {
                                    if (!pattern0.test(data8)) {
                                      validate16.errors = [{ instancePath: instancePath + "/encryption/initializationVector", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_-]+$" }, message: 'must match pattern "^[A-Za-z0-9_-]+$"' }];
                                      return false;
                                    }
                                  } else {
                                    validate16.errors = [{ instancePath: instancePath + "/encryption/initializationVector", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                    return false;
                                  }
                                }
                                var valid7 = _errs27 === errors;
                              } else {
                                var valid7 = true;
                              }
                              if (valid7) {
                                if (data6.keyEncryption !== void 0) {
                                  let data9 = data6.keyEncryption;
                                  const _errs30 = errors;
                                  if (errors === _errs30) {
                                    if (Array.isArray(data9)) {
                                      if (data9.length < 1) {
                                        validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption", schemaPath: "#/properties/encryption/properties/keyEncryption/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                        return false;
                                      } else {
                                        var valid9 = true;
                                        const len0 = data9.length;
                                        for (let i0 = 0; i0 < len0; i0++) {
                                          let data10 = data9[i0];
                                          const _errs32 = errors;
                                          if (errors === _errs32) {
                                            if (data10 && typeof data10 == "object" && !Array.isArray(data10)) {
                                              let missing6;
                                              if (data10.derivationScheme === void 0 && (missing6 = "derivationScheme") || data10.algorithm === void 0 && (missing6 = "algorithm") || data10.encryptedKey === void 0 && (missing6 = "encryptedKey") || data10.initializationVector === void 0 && (missing6 = "initializationVector") || data10.ephemeralPublicKey === void 0 && (missing6 = "ephemeralPublicKey") || data10.messageAuthenticationCode === void 0 && (missing6 = "messageAuthenticationCode")) {
                                                validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0, schemaPath: "#/properties/encryption/properties/keyEncryption/items/required", keyword: "required", params: { missingProperty: missing6 }, message: "must have required property '" + missing6 + "'" }];
                                                return false;
                                              } else {
                                                const _errs34 = errors;
                                                for (const key2 in data10) {
                                                  if (!(key2 === "derivationScheme" || key2 === "algorithm" || key2 === "encryptedKey" || key2 === "initializationVector" || key2 === "ephemeralPublicKey" || key2 === "messageAuthenticationCode")) {
                                                    validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0, schemaPath: "#/properties/encryption/properties/keyEncryption/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                                                    return false;
                                                    break;
                                                  }
                                                }
                                                if (_errs34 === errors) {
                                                  if (data10.derivationScheme !== void 0) {
                                                    let data11 = data10.derivationScheme;
                                                    const _errs35 = errors;
                                                    if (typeof data11 !== "string") {
                                                      validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/derivationScheme", schemaPath: "#/properties/encryption/properties/keyEncryption/items/properties/derivationScheme/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                    if (!(data11 === "protocol-context")) {
                                                      validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/derivationScheme", schemaPath: "#/properties/encryption/properties/keyEncryption/items/properties/derivationScheme/enum", keyword: "enum", params: { allowedValues: schema20.properties.encryption.properties.keyEncryption.items.properties.derivationScheme.enum }, message: "must be equal to one of the allowed values" }];
                                                      return false;
                                                    }
                                                    var valid10 = _errs35 === errors;
                                                  } else {
                                                    var valid10 = true;
                                                  }
                                                  if (valid10) {
                                                    if (data10.algorithm !== void 0) {
                                                      let data12 = data10.algorithm;
                                                      const _errs37 = errors;
                                                      if (typeof data12 !== "string") {
                                                        validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/algorithm", schemaPath: "#/properties/encryption/properties/keyEncryption/items/properties/algorithm/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                        return false;
                                                      }
                                                      if (!(data12 === "ECIES-ES256K")) {
                                                        validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/algorithm", schemaPath: "#/properties/encryption/properties/keyEncryption/items/properties/algorithm/enum", keyword: "enum", params: { allowedValues: schema20.properties.encryption.properties.keyEncryption.items.properties.algorithm.enum }, message: "must be equal to one of the allowed values" }];
                                                        return false;
                                                      }
                                                      var valid10 = _errs37 === errors;
                                                    } else {
                                                      var valid10 = true;
                                                    }
                                                    if (valid10) {
                                                      if (data10.encryptedKey !== void 0) {
                                                        let data13 = data10.encryptedKey;
                                                        const _errs39 = errors;
                                                        const _errs40 = errors;
                                                        if (errors === _errs40) {
                                                          if (typeof data13 === "string") {
                                                            if (!pattern0.test(data13)) {
                                                              validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/encryptedKey", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_-]+$" }, message: 'must match pattern "^[A-Za-z0-9_-]+$"' }];
                                                              return false;
                                                            }
                                                          } else {
                                                            validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/encryptedKey", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                            return false;
                                                          }
                                                        }
                                                        var valid10 = _errs39 === errors;
                                                      } else {
                                                        var valid10 = true;
                                                      }
                                                      if (valid10) {
                                                        if (data10.initializationVector !== void 0) {
                                                          let data14 = data10.initializationVector;
                                                          const _errs42 = errors;
                                                          const _errs43 = errors;
                                                          if (errors === _errs43) {
                                                            if (typeof data14 === "string") {
                                                              if (!pattern0.test(data14)) {
                                                                validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/initializationVector", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_-]+$" }, message: 'must match pattern "^[A-Za-z0-9_-]+$"' }];
                                                                return false;
                                                              }
                                                            } else {
                                                              validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/initializationVector", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid10 = _errs42 === errors;
                                                        } else {
                                                          var valid10 = true;
                                                        }
                                                        if (valid10) {
                                                          if (data10.ephemeralPublicKey !== void 0) {
                                                            const _errs45 = errors;
                                                            if (!validate19(data10.ephemeralPublicKey, { instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/ephemeralPublicKey", parentData: data10, parentDataProperty: "ephemeralPublicKey", rootData })) {
                                                              vErrors = vErrors === null ? validate19.errors : vErrors.concat(validate19.errors);
                                                              errors = vErrors.length;
                                                            }
                                                            var valid10 = _errs45 === errors;
                                                          } else {
                                                            var valid10 = true;
                                                          }
                                                          if (valid10) {
                                                            if (data10.messageAuthenticationCode !== void 0) {
                                                              let data16 = data10.messageAuthenticationCode;
                                                              const _errs46 = errors;
                                                              const _errs47 = errors;
                                                              if (errors === _errs47) {
                                                                if (typeof data16 === "string") {
                                                                  if (!pattern0.test(data16)) {
                                                                    validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/messageAuthenticationCode", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/pattern", keyword: "pattern", params: { pattern: "^[A-Za-z0-9_-]+$" }, message: 'must match pattern "^[A-Za-z0-9_-]+$"' }];
                                                                    return false;
                                                                  }
                                                                } else {
                                                                  validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0 + "/messageAuthenticationCode", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/base64url/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid10 = _errs46 === errors;
                                                            } else {
                                                              var valid10 = true;
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            } else {
                                              validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption/" + i0, schemaPath: "#/properties/encryption/properties/keyEncryption/items/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                              return false;
                                            }
                                          }
                                          var valid9 = _errs32 === errors;
                                          if (!valid9) {
                                            break;
                                          }
                                        }
                                      }
                                    } else {
                                      validate16.errors = [{ instancePath: instancePath + "/encryption/keyEncryption", schemaPath: "#/properties/encryption/properties/keyEncryption/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                      return false;
                                    }
                                  }
                                  var valid7 = _errs30 === errors;
                                } else {
                                  var valid7 = true;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        validate16.errors = [{ instancePath: instancePath + "/encryption", schemaPath: "#/properties/encryption/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid6 = _errs22 === errors;
                  } else {
                    var valid6 = true;
                  }
                  if (valid6) {
                    if (data.descriptor !== void 0) {
                      let data17 = data.descriptor;
                      const _errs49 = errors;
                      const _errs53 = errors;
                      let valid15 = false;
                      const _errs54 = errors;
                      if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
                        let missing7;
                        if (data17.published === void 0 && (missing7 = "published") || data17.datePublished === void 0 && (missing7 = "datePublished")) {
                          const err9 = { instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/allOf/0/anyOf/0/required", keyword: "required", params: { missingProperty: missing7 }, message: "must have required property '" + missing7 + "'" };
                          if (vErrors === null) {
                            vErrors = [err9];
                          } else {
                            vErrors.push(err9);
                          }
                          errors++;
                        } else {
                          if (data17.published !== void 0) {
                            let data18 = data17.published;
                            if (typeof data18 !== "boolean") {
                              const err10 = { instancePath: instancePath + "/descriptor/published", schemaPath: "#/properties/descriptor/allOf/0/anyOf/0/properties/published/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                              if (vErrors === null) {
                                vErrors = [err10];
                              } else {
                                vErrors.push(err10);
                              }
                              errors++;
                            }
                            if (!(data18 === true)) {
                              const err11 = { instancePath: instancePath + "/descriptor/published", schemaPath: "#/properties/descriptor/allOf/0/anyOf/0/properties/published/enum", keyword: "enum", params: { allowedValues: schema20.properties.descriptor.allOf[0].anyOf[0].properties.published.enum }, message: "must be equal to one of the allowed values" };
                              if (vErrors === null) {
                                vErrors = [err11];
                              } else {
                                vErrors.push(err11);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                      var _valid1 = _errs54 === errors;
                      valid15 = valid15 || _valid1;
                      if (!valid15) {
                        const _errs57 = errors;
                        const _errs58 = errors;
                        const _errs59 = errors;
                        if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
                          let missing8;
                          if (data17.datePublished === void 0 && (missing8 = "datePublished")) {
                            const err12 = {};
                            if (vErrors === null) {
                              vErrors = [err12];
                            } else {
                              vErrors.push(err12);
                            }
                            errors++;
                          }
                        }
                        var valid17 = _errs59 === errors;
                        if (valid17) {
                          const err13 = { instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/allOf/0/anyOf/1/not", keyword: "not", params: {}, message: "must NOT be valid" };
                          if (vErrors === null) {
                            vErrors = [err13];
                          } else {
                            vErrors.push(err13);
                          }
                          errors++;
                        } else {
                          errors = _errs58;
                          if (vErrors !== null) {
                            if (_errs58) {
                              vErrors.length = _errs58;
                            } else {
                              vErrors = null;
                            }
                          }
                        }
                        if (errors === _errs57) {
                          if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
                            if (data17.published !== void 0) {
                              let data19 = data17.published;
                              if (typeof data19 !== "boolean") {
                                const err14 = { instancePath: instancePath + "/descriptor/published", schemaPath: "#/properties/descriptor/allOf/0/anyOf/1/properties/published/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                if (vErrors === null) {
                                  vErrors = [err14];
                                } else {
                                  vErrors.push(err14);
                                }
                                errors++;
                              }
                              if (!(data19 === false)) {
                                const err15 = { instancePath: instancePath + "/descriptor/published", schemaPath: "#/properties/descriptor/allOf/0/anyOf/1/properties/published/enum", keyword: "enum", params: { allowedValues: schema20.properties.descriptor.allOf[0].anyOf[1].properties.published.enum }, message: "must be equal to one of the allowed values" };
                                if (vErrors === null) {
                                  vErrors = [err15];
                                } else {
                                  vErrors.push(err15);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                        var _valid1 = _errs57 === errors;
                        valid15 = valid15 || _valid1;
                        if (!valid15) {
                          const _errs62 = errors;
                          const _errs63 = errors;
                          const _errs64 = errors;
                          const _errs65 = errors;
                          if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
                            let missing9;
                            if (data17.published === void 0 && (missing9 = "published")) {
                              const err16 = {};
                              if (vErrors === null) {
                                vErrors = [err16];
                              } else {
                                vErrors.push(err16);
                              }
                              errors++;
                            }
                          }
                          var valid20 = _errs65 === errors;
                          if (valid20) {
                            const err17 = { instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/allOf/0/anyOf/2/allOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
                            if (vErrors === null) {
                              vErrors = [err17];
                            } else {
                              vErrors.push(err17);
                            }
                            errors++;
                          } else {
                            errors = _errs64;
                            if (vErrors !== null) {
                              if (_errs64) {
                                vErrors.length = _errs64;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          var valid19 = _errs63 === errors;
                          if (valid19) {
                            const _errs66 = errors;
                            const _errs67 = errors;
                            const _errs68 = errors;
                            if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
                              let missing10;
                              if (data17.datePublished === void 0 && (missing10 = "datePublished")) {
                                const err18 = {};
                                if (vErrors === null) {
                                  vErrors = [err18];
                                } else {
                                  vErrors.push(err18);
                                }
                                errors++;
                              }
                            }
                            var valid21 = _errs68 === errors;
                            if (valid21) {
                              const err19 = { instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/allOf/0/anyOf/2/allOf/1/not", keyword: "not", params: {}, message: "must NOT be valid" };
                              if (vErrors === null) {
                                vErrors = [err19];
                              } else {
                                vErrors.push(err19);
                              }
                              errors++;
                            } else {
                              errors = _errs67;
                              if (vErrors !== null) {
                                if (_errs67) {
                                  vErrors.length = _errs67;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            var valid19 = _errs66 === errors;
                          }
                          var _valid1 = _errs62 === errors;
                          valid15 = valid15 || _valid1;
                        }
                      }
                      if (!valid15) {
                        const err20 = { instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/allOf/0/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                        if (vErrors === null) {
                          vErrors = [err20];
                        } else {
                          vErrors.push(err20);
                        }
                        errors++;
                        validate16.errors = vErrors;
                        return false;
                      } else {
                        errors = _errs53;
                        if (vErrors !== null) {
                          if (_errs53) {
                            vErrors.length = _errs53;
                          } else {
                            vErrors = null;
                          }
                        }
                      }
                      if (errors === _errs49) {
                        if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
                          let missing11;
                          if (data17.interface === void 0 && (missing11 = "interface") || data17.method === void 0 && (missing11 = "method") || data17.dataCid === void 0 && (missing11 = "dataCid") || data17.dataSize === void 0 && (missing11 = "dataSize") || data17.dateCreated === void 0 && (missing11 = "dateCreated") || data17.dateModified === void 0 && (missing11 = "dateModified") || data17.dataFormat === void 0 && (missing11 = "dataFormat")) {
                            validate16.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing11 }, message: "must have required property '" + missing11 + "'" }];
                            return false;
                          } else {
                            const _errs69 = errors;
                            for (const key3 in data17) {
                              if (!func2.call(schema20.properties.descriptor.properties, key3)) {
                                validate16.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" }];
                                return false;
                                break;
                              }
                            }
                            if (_errs69 === errors) {
                              if (data17.interface !== void 0) {
                                let data20 = data17.interface;
                                const _errs70 = errors;
                                if (typeof data20 !== "string") {
                                  validate16.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                                if (!(data20 === "Records")) {
                                  validate16.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema20.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                                  return false;
                                }
                                var valid22 = _errs70 === errors;
                              } else {
                                var valid22 = true;
                              }
                              if (valid22) {
                                if (data17.method !== void 0) {
                                  let data21 = data17.method;
                                  const _errs72 = errors;
                                  if (typeof data21 !== "string") {
                                    validate16.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                    return false;
                                  }
                                  if (!(data21 === "Write")) {
                                    validate16.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema20.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                                    return false;
                                  }
                                  var valid22 = _errs72 === errors;
                                } else {
                                  var valid22 = true;
                                }
                                if (valid22) {
                                  if (data17.recipient !== void 0) {
                                    let data22 = data17.recipient;
                                    const _errs74 = errors;
                                    const _errs75 = errors;
                                    if (errors === _errs75) {
                                      if (typeof data22 === "string") {
                                        if (!pattern3.test(data22)) {
                                          validate16.errors = [{ instancePath: instancePath + "/descriptor/recipient", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                          return false;
                                        }
                                      } else {
                                        validate16.errors = [{ instancePath: instancePath + "/descriptor/recipient", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                        return false;
                                      }
                                    }
                                    var valid22 = _errs74 === errors;
                                  } else {
                                    var valid22 = true;
                                  }
                                  if (valid22) {
                                    if (data17.protocol !== void 0) {
                                      const _errs77 = errors;
                                      if (typeof data17.protocol !== "string") {
                                        validate16.errors = [{ instancePath: instancePath + "/descriptor/protocol", schemaPath: "#/properties/descriptor/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                        return false;
                                      }
                                      var valid22 = _errs77 === errors;
                                    } else {
                                      var valid22 = true;
                                    }
                                    if (valid22) {
                                      if (data17.schema !== void 0) {
                                        const _errs79 = errors;
                                        if (typeof data17.schema !== "string") {
                                          validate16.errors = [{ instancePath: instancePath + "/descriptor/schema", schemaPath: "#/properties/descriptor/properties/schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                          return false;
                                        }
                                        var valid22 = _errs79 === errors;
                                      } else {
                                        var valid22 = true;
                                      }
                                      if (valid22) {
                                        if (data17.parentId !== void 0) {
                                          const _errs81 = errors;
                                          if (typeof data17.parentId !== "string") {
                                            validate16.errors = [{ instancePath: instancePath + "/descriptor/parentId", schemaPath: "#/properties/descriptor/properties/parentId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                          var valid22 = _errs81 === errors;
                                        } else {
                                          var valid22 = true;
                                        }
                                        if (valid22) {
                                          if (data17.dataCid !== void 0) {
                                            const _errs83 = errors;
                                            if (typeof data17.dataCid !== "string") {
                                              validate16.errors = [{ instancePath: instancePath + "/descriptor/dataCid", schemaPath: "#/properties/descriptor/properties/dataCid/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                            var valid22 = _errs83 === errors;
                                          } else {
                                            var valid22 = true;
                                          }
                                          if (valid22) {
                                            if (data17.dataSize !== void 0) {
                                              let data27 = data17.dataSize;
                                              const _errs85 = errors;
                                              if (!(typeof data27 == "number" && isFinite(data27))) {
                                                validate16.errors = [{ instancePath: instancePath + "/descriptor/dataSize", schemaPath: "#/properties/descriptor/properties/dataSize/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                                return false;
                                              }
                                              var valid22 = _errs85 === errors;
                                            } else {
                                              var valid22 = true;
                                            }
                                            if (valid22) {
                                              if (data17.dateCreated !== void 0) {
                                                const _errs87 = errors;
                                                if (typeof data17.dateCreated !== "string") {
                                                  validate16.errors = [{ instancePath: instancePath + "/descriptor/dateCreated", schemaPath: "#/properties/descriptor/properties/dateCreated/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                  return false;
                                                }
                                                var valid22 = _errs87 === errors;
                                              } else {
                                                var valid22 = true;
                                              }
                                              if (valid22) {
                                                if (data17.dateModified !== void 0) {
                                                  const _errs89 = errors;
                                                  if (typeof data17.dateModified !== "string") {
                                                    validate16.errors = [{ instancePath: instancePath + "/descriptor/dateModified", schemaPath: "#/properties/descriptor/properties/dateModified/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                    return false;
                                                  }
                                                  var valid22 = _errs89 === errors;
                                                } else {
                                                  var valid22 = true;
                                                }
                                                if (valid22) {
                                                  if (data17.published !== void 0) {
                                                    const _errs91 = errors;
                                                    if (typeof data17.published !== "boolean") {
                                                      validate16.errors = [{ instancePath: instancePath + "/descriptor/published", schemaPath: "#/properties/descriptor/properties/published/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                      return false;
                                                    }
                                                    var valid22 = _errs91 === errors;
                                                  } else {
                                                    var valid22 = true;
                                                  }
                                                  if (valid22) {
                                                    if (data17.datePublished !== void 0) {
                                                      const _errs93 = errors;
                                                      if (typeof data17.datePublished !== "string") {
                                                        validate16.errors = [{ instancePath: instancePath + "/descriptor/datePublished", schemaPath: "#/properties/descriptor/properties/datePublished/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                        return false;
                                                      }
                                                      var valid22 = _errs93 === errors;
                                                    } else {
                                                      var valid22 = true;
                                                    }
                                                    if (valid22) {
                                                      if (data17.dataFormat !== void 0) {
                                                        const _errs95 = errors;
                                                        if (typeof data17.dataFormat !== "string") {
                                                          validate16.errors = [{ instancePath: instancePath + "/descriptor/dataFormat", schemaPath: "#/properties/descriptor/properties/dataFormat/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                          return false;
                                                        }
                                                        var valid22 = _errs95 === errors;
                                                      } else {
                                                        var valid22 = true;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          validate16.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                          return false;
                        }
                      }
                      var valid6 = _errs49 === errors;
                    } else {
                      var valid6 = true;
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate16.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate16.errors = vErrors;
  return errors === 0;
}
var EventsGet = validate21;
var schema28 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/events-get.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method"], "properties": { "interface": { "enum": ["Events"], "type": "string" }, "method": { "enum": ["Get"], "type": "string" }, "watermark": { "type": "string" } } } } };
function validate21(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate21.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate21.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method")) {
                    validate21.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "watermark")) {
                        validate21.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate21.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Events")) {
                          validate21.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema28.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate21.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Get")) {
                            validate21.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema28.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.watermark !== void 0) {
                            const _errs10 = errors;
                            if (typeof data1.watermark !== "string") {
                              validate21.errors = [{ instancePath: instancePath + "/descriptor/watermark", schemaPath: "#/properties/descriptor/properties/watermark/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate21.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate21.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
var Definitions = validate12;
function validate12(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (!(data && typeof data == "object" && !Array.isArray(data))) {
    validate12.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
    return false;
  }
  validate12.errors = vErrors;
  return errors === 0;
}
var GeneralJwk = validate23;
function validate23(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  const _errs1 = errors;
  let valid0 = false;
  let passing0 = null;
  const _errs2 = errors;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    let missing0;
    if (data.crv === void 0 && (missing0 = "crv") || data.x === void 0 && (missing0 = "x")) {
      const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    } else {
      if (data.kty !== void 0) {
        const _errs3 = errors;
        if ("EC" !== data.kty) {
          const err1 = { instancePath: instancePath + "/kty", schemaPath: "#/oneOf/0/properties/kty/const", keyword: "const", params: { allowedValue: "EC" }, message: "must be equal to constant" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
        var valid1 = _errs3 === errors;
      } else {
        var valid1 = true;
      }
      if (valid1) {
        if (data.crv !== void 0) {
          const _errs4 = errors;
          if (typeof data.crv !== "string") {
            const err2 = { instancePath: instancePath + "/crv", schemaPath: "#/oneOf/0/properties/crv/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err2];
            } else {
              vErrors.push(err2);
            }
            errors++;
          }
          var valid1 = _errs4 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.x !== void 0) {
            const _errs6 = errors;
            if (typeof data.x !== "string") {
              const err3 = { instancePath: instancePath + "/x", schemaPath: "#/oneOf/0/properties/x/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err3];
              } else {
                vErrors.push(err3);
              }
              errors++;
            }
            var valid1 = _errs6 === errors;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.y !== void 0) {
              const _errs8 = errors;
              if (typeof data.y !== "string") {
                const err4 = { instancePath: instancePath + "/y", schemaPath: "#/oneOf/0/properties/y/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
              var valid1 = _errs8 === errors;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data.d !== void 0) {
                const _errs10 = errors;
                if (typeof data.d !== "string") {
                  const err5 = { instancePath: instancePath + "/d", schemaPath: "#/oneOf/0/properties/d/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                }
                var valid1 = _errs10 === errors;
              } else {
                var valid1 = true;
              }
            }
          }
        }
      }
    }
  }
  var _valid0 = _errs2 === errors;
  if (_valid0) {
    valid0 = true;
    passing0 = 0;
  }
  const _errs12 = errors;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    let missing1;
    if (data.crv === void 0 && (missing1 = "crv") || data.x === void 0 && (missing1 = "x")) {
      const err6 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    } else {
      if (data.kty !== void 0) {
        const _errs13 = errors;
        if ("OKP" !== data.kty) {
          const err7 = { instancePath: instancePath + "/kty", schemaPath: "#/oneOf/1/properties/kty/const", keyword: "const", params: { allowedValue: "OKP" }, message: "must be equal to constant" };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors++;
        }
        var valid2 = _errs13 === errors;
      } else {
        var valid2 = true;
      }
      if (valid2) {
        if (data.crv !== void 0) {
          const _errs14 = errors;
          if (typeof data.crv !== "string") {
            const err8 = { instancePath: instancePath + "/crv", schemaPath: "#/oneOf/1/properties/crv/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
              vErrors = [err8];
            } else {
              vErrors.push(err8);
            }
            errors++;
          }
          var valid2 = _errs14 === errors;
        } else {
          var valid2 = true;
        }
        if (valid2) {
          if (data.x !== void 0) {
            const _errs16 = errors;
            if (typeof data.x !== "string") {
              const err9 = { instancePath: instancePath + "/x", schemaPath: "#/oneOf/1/properties/x/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
            var valid2 = _errs16 === errors;
          } else {
            var valid2 = true;
          }
          if (valid2) {
            if (data.d !== void 0) {
              const _errs18 = errors;
              if (typeof data.d !== "string") {
                const err10 = { instancePath: instancePath + "/d", schemaPath: "#/oneOf/1/properties/d/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors++;
              }
              var valid2 = _errs18 === errors;
            } else {
              var valid2 = true;
            }
          }
        }
      }
    }
  }
  var _valid0 = _errs12 === errors;
  if (_valid0 && valid0) {
    valid0 = false;
    passing0 = [passing0, 1];
  } else {
    if (_valid0) {
      valid0 = true;
      passing0 = 1;
    }
    const _errs20 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing2;
      if (data.n === void 0 && (missing2 = "n") || data.e === void 0 && (missing2 = "e")) {
        const err11 = { instancePath, schemaPath: "#/oneOf/2/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
        if (vErrors === null) {
          vErrors = [err11];
        } else {
          vErrors.push(err11);
        }
        errors++;
      } else {
        if (data.kty !== void 0) {
          const _errs21 = errors;
          if ("RSA" !== data.kty) {
            const err12 = { instancePath: instancePath + "/kty", schemaPath: "#/oneOf/2/properties/kty/const", keyword: "const", params: { allowedValue: "RSA" }, message: "must be equal to constant" };
            if (vErrors === null) {
              vErrors = [err12];
            } else {
              vErrors.push(err12);
            }
            errors++;
          }
          var valid3 = _errs21 === errors;
        } else {
          var valid3 = true;
        }
        if (valid3) {
          if (data.n !== void 0) {
            const _errs22 = errors;
            if (typeof data.n !== "string") {
              const err13 = { instancePath: instancePath + "/n", schemaPath: "#/oneOf/2/properties/n/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
            var valid3 = _errs22 === errors;
          } else {
            var valid3 = true;
          }
          if (valid3) {
            if (data.e !== void 0) {
              const _errs24 = errors;
              if (typeof data.e !== "string") {
                const err14 = { instancePath: instancePath + "/e", schemaPath: "#/oneOf/2/properties/e/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err14];
                } else {
                  vErrors.push(err14);
                }
                errors++;
              }
              var valid3 = _errs24 === errors;
            } else {
              var valid3 = true;
            }
            if (valid3) {
              if (data.d !== void 0) {
                const _errs26 = errors;
                if (typeof data.d !== "string") {
                  const err15 = { instancePath: instancePath + "/d", schemaPath: "#/oneOf/2/properties/d/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err15];
                  } else {
                    vErrors.push(err15);
                  }
                  errors++;
                }
                var valid3 = _errs26 === errors;
              } else {
                var valid3 = true;
              }
              if (valid3) {
                if (data.p !== void 0) {
                  const _errs28 = errors;
                  if (typeof data.p !== "string") {
                    const err16 = { instancePath: instancePath + "/p", schemaPath: "#/oneOf/2/properties/p/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err16];
                    } else {
                      vErrors.push(err16);
                    }
                    errors++;
                  }
                  var valid3 = _errs28 === errors;
                } else {
                  var valid3 = true;
                }
                if (valid3) {
                  if (data.q !== void 0) {
                    const _errs30 = errors;
                    if (typeof data.q !== "string") {
                      const err17 = { instancePath: instancePath + "/q", schemaPath: "#/oneOf/2/properties/q/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err17];
                      } else {
                        vErrors.push(err17);
                      }
                      errors++;
                    }
                    var valid3 = _errs30 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data.dp !== void 0) {
                      const _errs32 = errors;
                      if (typeof data.dp !== "string") {
                        const err18 = { instancePath: instancePath + "/dp", schemaPath: "#/oneOf/2/properties/dp/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err18];
                        } else {
                          vErrors.push(err18);
                        }
                        errors++;
                      }
                      var valid3 = _errs32 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data.dq !== void 0) {
                        const _errs34 = errors;
                        if (typeof data.dq !== "string") {
                          const err19 = { instancePath: instancePath + "/dq", schemaPath: "#/oneOf/2/properties/dq/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err19];
                          } else {
                            vErrors.push(err19);
                          }
                          errors++;
                        }
                        var valid3 = _errs34 === errors;
                      } else {
                        var valid3 = true;
                      }
                      if (valid3) {
                        if (data.qi !== void 0) {
                          const _errs36 = errors;
                          if (typeof data.qi !== "string") {
                            const err20 = { instancePath: instancePath + "/qi", schemaPath: "#/oneOf/2/properties/qi/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err20];
                            } else {
                              vErrors.push(err20);
                            }
                            errors++;
                          }
                          var valid3 = _errs36 === errors;
                        } else {
                          var valid3 = true;
                        }
                        if (valid3) {
                          if (data.oth !== void 0) {
                            let data18 = data.oth;
                            const _errs38 = errors;
                            if (!(data18 && typeof data18 == "object" && !Array.isArray(data18))) {
                              const err21 = { instancePath: instancePath + "/oth", schemaPath: "#/oneOf/2/properties/oth/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                              if (vErrors === null) {
                                vErrors = [err21];
                              } else {
                                vErrors.push(err21);
                              }
                              errors++;
                            }
                            var valid3 = _errs38 === errors;
                          } else {
                            var valid3 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    var _valid0 = _errs20 === errors;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 2];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 2;
      }
      const _errs40 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing3;
        if (data.k === void 0 && (missing3 = "k")) {
          const err22 = { instancePath, schemaPath: "#/oneOf/3/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
          if (vErrors === null) {
            vErrors = [err22];
          } else {
            vErrors.push(err22);
          }
          errors++;
        } else {
          if (data.kty !== void 0) {
            const _errs41 = errors;
            if ("oct" !== data.kty) {
              const err23 = { instancePath: instancePath + "/kty", schemaPath: "#/oneOf/3/properties/kty/const", keyword: "const", params: { allowedValue: "oct" }, message: "must be equal to constant" };
              if (vErrors === null) {
                vErrors = [err23];
              } else {
                vErrors.push(err23);
              }
              errors++;
            }
            var valid4 = _errs41 === errors;
          } else {
            var valid4 = true;
          }
          if (valid4) {
            if (data.k !== void 0) {
              const _errs42 = errors;
              if (typeof data.k !== "string") {
                const err24 = { instancePath: instancePath + "/k", schemaPath: "#/oneOf/3/properties/k/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err24];
                } else {
                  vErrors.push(err24);
                }
                errors++;
              }
              var valid4 = _errs42 === errors;
            } else {
              var valid4 = true;
            }
          }
        }
      }
      var _valid0 = _errs40 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 3];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 3;
        }
      }
    }
  }
  if (!valid0) {
    const err25 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
    if (vErrors === null) {
      vErrors = [err25];
    } else {
      vErrors.push(err25);
    }
    errors++;
    validate23.errors = vErrors;
    return false;
  } else {
    errors = _errs1;
    if (vErrors !== null) {
      if (_errs1) {
        vErrors.length = _errs1;
      } else {
        vErrors = null;
      }
    }
  }
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing4;
      if (data.kty === void 0 && (missing4 = "kty")) {
        validate23.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing4 }, message: "must have required property '" + missing4 + "'" }];
        return false;
      } else {
        if (data.alg !== void 0) {
          const _errs44 = errors;
          if (typeof data.alg !== "string") {
            validate23.errors = [{ instancePath: instancePath + "/alg", schemaPath: "#/properties/alg/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
            return false;
          }
          var valid5 = _errs44 === errors;
        } else {
          var valid5 = true;
        }
        if (valid5) {
          if (data.kid !== void 0) {
            const _errs46 = errors;
            if (typeof data.kid !== "string") {
              validate23.errors = [{ instancePath: instancePath + "/kid", schemaPath: "#/properties/kid/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid5 = _errs46 === errors;
          } else {
            var valid5 = true;
          }
          if (valid5) {
            if (data.kty !== void 0) {
              let data23 = data.kty;
              const _errs48 = errors;
              if (!(data23 === "EC" || data23 === "RSA" || data23 === "oct" || data23 === "OKP")) {
                validate23.errors = [{ instancePath: instancePath + "/kty", schemaPath: "#/properties/kty/enum", keyword: "enum", params: { allowedValues: schema25.properties.kty.enum }, message: "must be equal to one of the allowed values" }];
                return false;
              }
              var valid5 = _errs48 === errors;
            } else {
              var valid5 = true;
            }
            if (valid5) {
              if (data.crv !== void 0) {
                const _errs49 = errors;
                if (typeof data.crv !== "string") {
                  validate23.errors = [{ instancePath: instancePath + "/crv", schemaPath: "#/properties/crv/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid5 = _errs49 === errors;
              } else {
                var valid5 = true;
              }
              if (valid5) {
                if (data.use !== void 0) {
                  const _errs51 = errors;
                  if (typeof data.use !== "string") {
                    validate23.errors = [{ instancePath: instancePath + "/use", schemaPath: "#/properties/use/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid5 = _errs51 === errors;
                } else {
                  var valid5 = true;
                }
                if (valid5) {
                  if (data.key_ops !== void 0) {
                    const _errs53 = errors;
                    if (typeof data.key_ops !== "string") {
                      validate23.errors = [{ instancePath: instancePath + "/key_ops", schemaPath: "#/properties/key_ops/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid5 = _errs53 === errors;
                  } else {
                    var valid5 = true;
                  }
                  if (valid5) {
                    if (data.x5u !== void 0) {
                      const _errs55 = errors;
                      if (typeof data.x5u !== "string") {
                        validate23.errors = [{ instancePath: instancePath + "/x5u", schemaPath: "#/properties/x5u/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                      var valid5 = _errs55 === errors;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data.x5c !== void 0) {
                        const _errs57 = errors;
                        if (typeof data.x5c !== "string") {
                          validate23.errors = [{ instancePath: instancePath + "/x5c", schemaPath: "#/properties/x5c/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        var valid5 = _errs57 === errors;
                      } else {
                        var valid5 = true;
                      }
                      if (valid5) {
                        if (data.x5t !== void 0) {
                          const _errs59 = errors;
                          if (typeof data.x5t !== "string") {
                            validate23.errors = [{ instancePath: instancePath + "/x5t", schemaPath: "#/properties/x5t/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid5 = _errs59 === errors;
                        } else {
                          var valid5 = true;
                        }
                        if (valid5) {
                          if (data["x5t#S256"] !== void 0) {
                            const _errs61 = errors;
                            if (typeof data["x5t#S256"] !== "string") {
                              validate23.errors = [{ instancePath: instancePath + "/x5t#S256", schemaPath: "#/properties/x5t%23S256/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid5 = _errs61 === errors;
                          } else {
                            var valid5 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate23.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
var GeneralJws = validate11;
var HooksWrite = validate24;
var schema30 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/hooks-write.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "dateCreated", "uri", "filter"], "properties": { "interface": { "enum": ["Hooks"], "type": "string" }, "method": { "enum": ["Write"], "type": "string" }, "dateCreated": { "type": "string" }, "schema": { "type": "string" }, "filter": { "type": "object", "minProperties": 1, "additionalProperties": false, "properties": { "method": { "type": "string" } } } } } } };
function validate24(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate24.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate24.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method") || data1.dateCreated === void 0 && (missing1 = "dateCreated") || data1.uri === void 0 && (missing1 = "uri") || data1.filter === void 0 && (missing1 = "filter")) {
                    validate24.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "dateCreated" || key1 === "schema" || key1 === "filter")) {
                        validate24.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate24.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Hooks")) {
                          validate24.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema30.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate24.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Write")) {
                            validate24.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema30.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.dateCreated !== void 0) {
                            const _errs10 = errors;
                            if (typeof data1.dateCreated !== "string") {
                              validate24.errors = [{ instancePath: instancePath + "/descriptor/dateCreated", schemaPath: "#/properties/descriptor/properties/dateCreated/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data1.schema !== void 0) {
                              const _errs12 = errors;
                              if (typeof data1.schema !== "string") {
                                validate24.errors = [{ instancePath: instancePath + "/descriptor/schema", schemaPath: "#/properties/descriptor/properties/schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                              var valid1 = _errs12 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data1.filter !== void 0) {
                                let data6 = data1.filter;
                                const _errs14 = errors;
                                if (errors === _errs14) {
                                  if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
                                    if (Object.keys(data6).length < 1) {
                                      validate24.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/minProperties", keyword: "minProperties", params: { limit: 1 }, message: "must NOT have fewer than 1 properties" }];
                                      return false;
                                    } else {
                                      const _errs16 = errors;
                                      for (const key2 in data6) {
                                        if (!(key2 === "method")) {
                                          validate24.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                                          return false;
                                          break;
                                        }
                                      }
                                      if (_errs16 === errors) {
                                        if (data6.method !== void 0) {
                                          if (typeof data6.method !== "string") {
                                            validate24.errors = [{ instancePath: instancePath + "/descriptor/filter/method", schemaPath: "#/properties/descriptor/properties/filter/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    validate24.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                    return false;
                                  }
                                }
                                var valid1 = _errs14 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate24.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate24.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate24.errors = vErrors;
  return errors === 0;
}
var JwkVerificationMethod = validate26;
function validate26(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.id === void 0 && (missing0 = "id") || data.type === void 0 && (missing0 = "type") || data.controller === void 0 && (missing0 = "controller") || data.publicKeyJwk === void 0 && (missing0 = "publicKeyJwk")) {
        validate26.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "id" || key0 === "type" || key0 === "controller" || key0 === "publicKeyJwk")) {
            validate26.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.id !== void 0) {
            const _errs2 = errors;
            if (typeof data.id !== "string") {
              validate26.errors = [{ instancePath: instancePath + "/id", schemaPath: "#/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
              return false;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.type !== void 0) {
              const _errs4 = errors;
              if ("JsonWebKey2020" !== data.type) {
                validate26.errors = [{ instancePath: instancePath + "/type", schemaPath: "#/properties/type/const", keyword: "const", params: { allowedValue: "JsonWebKey2020" }, message: "must be equal to constant" }];
                return false;
              }
              var valid0 = _errs4 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.controller !== void 0) {
                let data2 = data.controller;
                const _errs5 = errors;
                const _errs6 = errors;
                if (errors === _errs6) {
                  if (typeof data2 === "string") {
                    if (!pattern3.test(data2)) {
                      validate26.errors = [{ instancePath: instancePath + "/controller", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                      return false;
                    }
                  } else {
                    validate26.errors = [{ instancePath: instancePath + "/controller", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
                var valid0 = _errs5 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.publicKeyJwk !== void 0) {
                  const _errs8 = errors;
                  if (!validate19(data.publicKeyJwk, { instancePath: instancePath + "/publicKeyJwk", parentData: data, parentDataProperty: "publicKeyJwk", rootData })) {
                    vErrors = vErrors === null ? validate19.errors : vErrors.concat(validate19.errors);
                    errors = vErrors.length;
                  }
                  var valid0 = _errs8 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate26.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
var MessagesGet = validate28;
var schema33 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/messages-get.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method"], "properties": { "interface": { "enum": ["Messages"], "type": "string" }, "method": { "enum": ["Get"], "type": "string" }, "messageCids": { "type": "array", "items": { "type": "string" }, "minItems": 1 } } } } };
function validate28(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate28.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate28.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method")) {
                    validate28.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "messageCids")) {
                        validate28.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate28.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Messages")) {
                          validate28.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema33.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate28.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Get")) {
                            validate28.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema33.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.messageCids !== void 0) {
                            let data4 = data1.messageCids;
                            const _errs10 = errors;
                            if (errors === _errs10) {
                              if (Array.isArray(data4)) {
                                if (data4.length < 1) {
                                  validate28.errors = [{ instancePath: instancePath + "/descriptor/messageCids", schemaPath: "#/properties/descriptor/properties/messageCids/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                  return false;
                                } else {
                                  var valid2 = true;
                                  const len0 = data4.length;
                                  for (let i0 = 0; i0 < len0; i0++) {
                                    const _errs12 = errors;
                                    if (typeof data4[i0] !== "string") {
                                      validate28.errors = [{ instancePath: instancePath + "/descriptor/messageCids/" + i0, schemaPath: "#/properties/descriptor/properties/messageCids/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                      return false;
                                    }
                                    var valid2 = _errs12 === errors;
                                    if (!valid2) {
                                      break;
                                    }
                                  }
                                }
                              } else {
                                validate28.errors = [{ instancePath: instancePath + "/descriptor/messageCids", schemaPath: "#/properties/descriptor/properties/messageCids/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                return false;
                              }
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate28.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate28.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate28.errors = vErrors;
  return errors === 0;
}
var PermissionsDefinitions = validate30;
function validate30(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (!(data && typeof data == "object" && !Array.isArray(data))) {
    validate30.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
    return false;
  }
  validate30.errors = vErrors;
  return errors === 0;
}
var PermissionsGrant = validate31;
var schema35 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/permissions-grant.json", "type": "object", "required": ["authorization", "descriptor"], "additionalProperties": false, "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "delegationChain": { "description": "the parent grant", "$ref": "#" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "dateCreated"], "properties": { "dateCreated": { "type": "string" }, "conditions": { "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions" }, "delegatedFrom": { "description": "CID of the parent grant", "type": "string" }, "description": { "type": "string" }, "grantedTo": { "description": "DID of the grantee", "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedTo" }, "grantedBy": { "description": "DID of the grantor", "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedBy" }, "interface": { "enum": ["Permissions"], "type": "string" }, "method": { "enum": ["Grant"], "type": "string" }, "scope": { "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope" }, "objectId": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/uuid" } } } } };
var schema36 = { "type": "object", "additionalProperties": false, "properties": { "attestation": { "enum": ["optional", "required"], "type": "string" }, "delegation": { "type": "boolean" }, "encryption": { "enum": ["optional", "required"], "type": "string" }, "publication": { "type": "boolean" }, "sharedAccess": { "type": "boolean" } } };
var pattern13 = new RegExp("^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$", "u");
function validate31(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate31.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "delegationChain" || key0 === "descriptor")) {
            validate31.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.delegationChain !== void 0) {
              const _errs3 = errors;
              if (!validate31(data.delegationChain, { instancePath: instancePath + "/delegationChain", parentData: data, parentDataProperty: "delegationChain", rootData })) {
                vErrors = vErrors === null ? validate31.errors : vErrors.concat(validate31.errors);
                errors = vErrors.length;
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.descriptor !== void 0) {
                let data2 = data.descriptor;
                const _errs4 = errors;
                if (errors === _errs4) {
                  if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                    let missing1;
                    if (data2.interface === void 0 && (missing1 = "interface") || data2.method === void 0 && (missing1 = "method") || data2.dateCreated === void 0 && (missing1 = "dateCreated")) {
                      validate31.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                      return false;
                    } else {
                      const _errs6 = errors;
                      for (const key1 in data2) {
                        if (!func2.call(schema35.properties.descriptor.properties, key1)) {
                          validate31.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                          return false;
                          break;
                        }
                      }
                      if (_errs6 === errors) {
                        if (data2.dateCreated !== void 0) {
                          const _errs7 = errors;
                          if (typeof data2.dateCreated !== "string") {
                            validate31.errors = [{ instancePath: instancePath + "/descriptor/dateCreated", schemaPath: "#/properties/descriptor/properties/dateCreated/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          var valid1 = _errs7 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data2.conditions !== void 0) {
                            let data4 = data2.conditions;
                            const _errs9 = errors;
                            const _errs10 = errors;
                            if (errors === _errs10) {
                              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                                const _errs12 = errors;
                                for (const key2 in data4) {
                                  if (!(key2 === "attestation" || key2 === "delegation" || key2 === "encryption" || key2 === "publication" || key2 === "sharedAccess")) {
                                    validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                                    return false;
                                    break;
                                  }
                                }
                                if (_errs12 === errors) {
                                  if (data4.attestation !== void 0) {
                                    let data5 = data4.attestation;
                                    const _errs13 = errors;
                                    if (typeof data5 !== "string") {
                                      validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions/attestation", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/attestation/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                      return false;
                                    }
                                    if (!(data5 === "optional" || data5 === "required")) {
                                      validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions/attestation", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/attestation/enum", keyword: "enum", params: { allowedValues: schema36.properties.attestation.enum }, message: "must be equal to one of the allowed values" }];
                                      return false;
                                    }
                                    var valid3 = _errs13 === errors;
                                  } else {
                                    var valid3 = true;
                                  }
                                  if (valid3) {
                                    if (data4.delegation !== void 0) {
                                      const _errs15 = errors;
                                      if (typeof data4.delegation !== "boolean") {
                                        validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions/delegation", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/delegation/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                      var valid3 = _errs15 === errors;
                                    } else {
                                      var valid3 = true;
                                    }
                                    if (valid3) {
                                      if (data4.encryption !== void 0) {
                                        let data7 = data4.encryption;
                                        const _errs17 = errors;
                                        if (typeof data7 !== "string") {
                                          validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions/encryption", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/encryption/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                          return false;
                                        }
                                        if (!(data7 === "optional" || data7 === "required")) {
                                          validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions/encryption", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/encryption/enum", keyword: "enum", params: { allowedValues: schema36.properties.encryption.enum }, message: "must be equal to one of the allowed values" }];
                                          return false;
                                        }
                                        var valid3 = _errs17 === errors;
                                      } else {
                                        var valid3 = true;
                                      }
                                      if (valid3) {
                                        if (data4.publication !== void 0) {
                                          const _errs19 = errors;
                                          if (typeof data4.publication !== "boolean") {
                                            validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions/publication", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/publication/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                            return false;
                                          }
                                          var valid3 = _errs19 === errors;
                                        } else {
                                          var valid3 = true;
                                        }
                                        if (valid3) {
                                          if (data4.sharedAccess !== void 0) {
                                            const _errs21 = errors;
                                            if (typeof data4.sharedAccess !== "boolean") {
                                              validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions/sharedAccess", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/sharedAccess/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                              return false;
                                            }
                                            var valid3 = _errs21 === errors;
                                          } else {
                                            var valid3 = true;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              } else {
                                validate31.errors = [{ instancePath: instancePath + "/descriptor/conditions", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                return false;
                              }
                            }
                            var valid1 = _errs9 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data2.delegatedFrom !== void 0) {
                              const _errs23 = errors;
                              if (typeof data2.delegatedFrom !== "string") {
                                validate31.errors = [{ instancePath: instancePath + "/descriptor/delegatedFrom", schemaPath: "#/properties/descriptor/properties/delegatedFrom/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                              var valid1 = _errs23 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data2.description !== void 0) {
                                const _errs25 = errors;
                                if (typeof data2.description !== "string") {
                                  validate31.errors = [{ instancePath: instancePath + "/descriptor/description", schemaPath: "#/properties/descriptor/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                                var valid1 = _errs25 === errors;
                              } else {
                                var valid1 = true;
                              }
                              if (valid1) {
                                if (data2.grantedTo !== void 0) {
                                  let data12 = data2.grantedTo;
                                  const _errs27 = errors;
                                  const _errs28 = errors;
                                  if (errors === _errs28) {
                                    if (typeof data12 === "string") {
                                      if (!pattern3.test(data12)) {
                                        validate31.errors = [{ instancePath: instancePath + "/descriptor/grantedTo", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedTo/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                        return false;
                                      }
                                    } else {
                                      validate31.errors = [{ instancePath: instancePath + "/descriptor/grantedTo", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedTo/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                      return false;
                                    }
                                  }
                                  var valid1 = _errs27 === errors;
                                } else {
                                  var valid1 = true;
                                }
                                if (valid1) {
                                  if (data2.grantedBy !== void 0) {
                                    let data13 = data2.grantedBy;
                                    const _errs30 = errors;
                                    const _errs31 = errors;
                                    if (errors === _errs31) {
                                      if (typeof data13 === "string") {
                                        if (!pattern3.test(data13)) {
                                          validate31.errors = [{ instancePath: instancePath + "/descriptor/grantedBy", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedBy/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                          return false;
                                        }
                                      } else {
                                        validate31.errors = [{ instancePath: instancePath + "/descriptor/grantedBy", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedBy/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                        return false;
                                      }
                                    }
                                    var valid1 = _errs30 === errors;
                                  } else {
                                    var valid1 = true;
                                  }
                                  if (valid1) {
                                    if (data2.interface !== void 0) {
                                      let data14 = data2.interface;
                                      const _errs33 = errors;
                                      if (typeof data14 !== "string") {
                                        validate31.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                        return false;
                                      }
                                      if (!(data14 === "Permissions")) {
                                        validate31.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema35.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                                        return false;
                                      }
                                      var valid1 = _errs33 === errors;
                                    } else {
                                      var valid1 = true;
                                    }
                                    if (valid1) {
                                      if (data2.method !== void 0) {
                                        let data15 = data2.method;
                                        const _errs35 = errors;
                                        if (typeof data15 !== "string") {
                                          validate31.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                          return false;
                                        }
                                        if (!(data15 === "Grant")) {
                                          validate31.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema35.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                                          return false;
                                        }
                                        var valid1 = _errs35 === errors;
                                      } else {
                                        var valid1 = true;
                                      }
                                      if (valid1) {
                                        if (data2.scope !== void 0) {
                                          let data16 = data2.scope;
                                          const _errs37 = errors;
                                          const _errs38 = errors;
                                          if (errors === _errs38) {
                                            if (data16 && typeof data16 == "object" && !Array.isArray(data16)) {
                                              const _errs40 = errors;
                                              for (const key3 in data16) {
                                                if (!(key3 === "method" || key3 === "objectId" || key3 === "schema")) {
                                                  validate31.errors = [{ instancePath: instancePath + "/descriptor/scope", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" }];
                                                  return false;
                                                  break;
                                                }
                                              }
                                              if (_errs40 === errors) {
                                                if (data16.method !== void 0) {
                                                  const _errs41 = errors;
                                                  if (typeof data16.method !== "string") {
                                                    validate31.errors = [{ instancePath: instancePath + "/descriptor/scope/method", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                    return false;
                                                  }
                                                  var valid7 = _errs41 === errors;
                                                } else {
                                                  var valid7 = true;
                                                }
                                                if (valid7) {
                                                  if (data16.objectId !== void 0) {
                                                    const _errs43 = errors;
                                                    if (typeof data16.objectId !== "string") {
                                                      validate31.errors = [{ instancePath: instancePath + "/descriptor/scope/objectId", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/properties/objectId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                    var valid7 = _errs43 === errors;
                                                  } else {
                                                    var valid7 = true;
                                                  }
                                                  if (valid7) {
                                                    if (data16.schema !== void 0) {
                                                      const _errs45 = errors;
                                                      if (typeof data16.schema !== "string") {
                                                        validate31.errors = [{ instancePath: instancePath + "/descriptor/scope/schema", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/properties/schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                        return false;
                                                      }
                                                      var valid7 = _errs45 === errors;
                                                    } else {
                                                      var valid7 = true;
                                                    }
                                                  }
                                                }
                                              }
                                            } else {
                                              validate31.errors = [{ instancePath: instancePath + "/descriptor/scope", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                              return false;
                                            }
                                          }
                                          var valid1 = _errs37 === errors;
                                        } else {
                                          var valid1 = true;
                                        }
                                        if (valid1) {
                                          if (data2.objectId !== void 0) {
                                            let data20 = data2.objectId;
                                            const _errs47 = errors;
                                            const _errs48 = errors;
                                            if (errors === _errs48) {
                                              if (typeof data20 === "string") {
                                                if (!pattern13.test(data20)) {
                                                  validate31.errors = [{ instancePath: instancePath + "/descriptor/objectId", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/uuid/pattern", keyword: "pattern", params: { pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$" }, message: 'must match pattern "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"' }];
                                                  return false;
                                                }
                                              } else {
                                                validate31.errors = [{ instancePath: instancePath + "/descriptor/objectId", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/uuid/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                            var valid1 = _errs47 === errors;
                                          } else {
                                            var valid1 = true;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    validate31.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid0 = _errs4 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate31.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate31.errors = vErrors;
  return errors === 0;
}
var PermissionsRequest = validate33;
var schema41 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/permissions-request.json", "additionalProperties": false, "type": "object", "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "dateCreated"], "properties": { "dateCreated": { "type": "string" }, "conditions": { "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions" }, "description": { "type": "string" }, "grantedTo": { "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedTo" }, "grantedBy": { "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedBy" }, "interface": { "enum": ["Permissions"], "type": "string" }, "method": { "enum": ["Request"], "type": "string" }, "scope": { "$ref": "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope" }, "objectId": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/uuid" } } } } };
function validate33(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate33.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate33.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method") || data1.dateCreated === void 0 && (missing1 = "dateCreated")) {
                    validate33.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!func2.call(schema41.properties.descriptor.properties, key1)) {
                        validate33.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.dateCreated !== void 0) {
                        const _errs6 = errors;
                        if (typeof data1.dateCreated !== "string") {
                          validate33.errors = [{ instancePath: instancePath + "/descriptor/dateCreated", schemaPath: "#/properties/descriptor/properties/dateCreated/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.conditions !== void 0) {
                          let data3 = data1.conditions;
                          const _errs8 = errors;
                          const _errs9 = errors;
                          if (errors === _errs9) {
                            if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                              const _errs11 = errors;
                              for (const key2 in data3) {
                                if (!(key2 === "attestation" || key2 === "delegation" || key2 === "encryption" || key2 === "publication" || key2 === "sharedAccess")) {
                                  validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                                  return false;
                                  break;
                                }
                              }
                              if (_errs11 === errors) {
                                if (data3.attestation !== void 0) {
                                  let data4 = data3.attestation;
                                  const _errs12 = errors;
                                  if (typeof data4 !== "string") {
                                    validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions/attestation", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/attestation/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                    return false;
                                  }
                                  if (!(data4 === "optional" || data4 === "required")) {
                                    validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions/attestation", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/attestation/enum", keyword: "enum", params: { allowedValues: schema36.properties.attestation.enum }, message: "must be equal to one of the allowed values" }];
                                    return false;
                                  }
                                  var valid3 = _errs12 === errors;
                                } else {
                                  var valid3 = true;
                                }
                                if (valid3) {
                                  if (data3.delegation !== void 0) {
                                    const _errs14 = errors;
                                    if (typeof data3.delegation !== "boolean") {
                                      validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions/delegation", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/delegation/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                    var valid3 = _errs14 === errors;
                                  } else {
                                    var valid3 = true;
                                  }
                                  if (valid3) {
                                    if (data3.encryption !== void 0) {
                                      let data6 = data3.encryption;
                                      const _errs16 = errors;
                                      if (typeof data6 !== "string") {
                                        validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions/encryption", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/encryption/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                        return false;
                                      }
                                      if (!(data6 === "optional" || data6 === "required")) {
                                        validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions/encryption", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/encryption/enum", keyword: "enum", params: { allowedValues: schema36.properties.encryption.enum }, message: "must be equal to one of the allowed values" }];
                                        return false;
                                      }
                                      var valid3 = _errs16 === errors;
                                    } else {
                                      var valid3 = true;
                                    }
                                    if (valid3) {
                                      if (data3.publication !== void 0) {
                                        const _errs18 = errors;
                                        if (typeof data3.publication !== "boolean") {
                                          validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions/publication", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/publication/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                          return false;
                                        }
                                        var valid3 = _errs18 === errors;
                                      } else {
                                        var valid3 = true;
                                      }
                                      if (valid3) {
                                        if (data3.sharedAccess !== void 0) {
                                          const _errs20 = errors;
                                          if (typeof data3.sharedAccess !== "boolean") {
                                            validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions/sharedAccess", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/properties/sharedAccess/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                            return false;
                                          }
                                          var valid3 = _errs20 === errors;
                                        } else {
                                          var valid3 = true;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            } else {
                              validate33.errors = [{ instancePath: instancePath + "/descriptor/conditions", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/conditions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                              return false;
                            }
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.description !== void 0) {
                            const _errs22 = errors;
                            if (typeof data1.description !== "string") {
                              validate33.errors = [{ instancePath: instancePath + "/descriptor/description", schemaPath: "#/properties/descriptor/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs22 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data1.grantedTo !== void 0) {
                              let data10 = data1.grantedTo;
                              const _errs24 = errors;
                              const _errs25 = errors;
                              if (errors === _errs25) {
                                if (typeof data10 === "string") {
                                  if (!pattern3.test(data10)) {
                                    validate33.errors = [{ instancePath: instancePath + "/descriptor/grantedTo", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedTo/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                    return false;
                                  }
                                } else {
                                  validate33.errors = [{ instancePath: instancePath + "/descriptor/grantedTo", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedTo/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                              }
                              var valid1 = _errs24 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data1.grantedBy !== void 0) {
                                let data11 = data1.grantedBy;
                                const _errs27 = errors;
                                const _errs28 = errors;
                                if (errors === _errs28) {
                                  if (typeof data11 === "string") {
                                    if (!pattern3.test(data11)) {
                                      validate33.errors = [{ instancePath: instancePath + "/descriptor/grantedBy", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedBy/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                      return false;
                                    }
                                  } else {
                                    validate33.errors = [{ instancePath: instancePath + "/descriptor/grantedBy", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/grantedBy/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                    return false;
                                  }
                                }
                                var valid1 = _errs27 === errors;
                              } else {
                                var valid1 = true;
                              }
                              if (valid1) {
                                if (data1.interface !== void 0) {
                                  let data12 = data1.interface;
                                  const _errs30 = errors;
                                  if (typeof data12 !== "string") {
                                    validate33.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                    return false;
                                  }
                                  if (!(data12 === "Permissions")) {
                                    validate33.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema41.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                                    return false;
                                  }
                                  var valid1 = _errs30 === errors;
                                } else {
                                  var valid1 = true;
                                }
                                if (valid1) {
                                  if (data1.method !== void 0) {
                                    let data13 = data1.method;
                                    const _errs32 = errors;
                                    if (typeof data13 !== "string") {
                                      validate33.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                      return false;
                                    }
                                    if (!(data13 === "Request")) {
                                      validate33.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema41.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                                      return false;
                                    }
                                    var valid1 = _errs32 === errors;
                                  } else {
                                    var valid1 = true;
                                  }
                                  if (valid1) {
                                    if (data1.scope !== void 0) {
                                      let data14 = data1.scope;
                                      const _errs34 = errors;
                                      const _errs35 = errors;
                                      if (errors === _errs35) {
                                        if (data14 && typeof data14 == "object" && !Array.isArray(data14)) {
                                          const _errs37 = errors;
                                          for (const key3 in data14) {
                                            if (!(key3 === "method" || key3 === "objectId" || key3 === "schema")) {
                                              validate33.errors = [{ instancePath: instancePath + "/descriptor/scope", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" }];
                                              return false;
                                              break;
                                            }
                                          }
                                          if (_errs37 === errors) {
                                            if (data14.method !== void 0) {
                                              const _errs38 = errors;
                                              if (typeof data14.method !== "string") {
                                                validate33.errors = [{ instancePath: instancePath + "/descriptor/scope/method", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                              var valid7 = _errs38 === errors;
                                            } else {
                                              var valid7 = true;
                                            }
                                            if (valid7) {
                                              if (data14.objectId !== void 0) {
                                                const _errs40 = errors;
                                                if (typeof data14.objectId !== "string") {
                                                  validate33.errors = [{ instancePath: instancePath + "/descriptor/scope/objectId", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/properties/objectId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                  return false;
                                                }
                                                var valid7 = _errs40 === errors;
                                              } else {
                                                var valid7 = true;
                                              }
                                              if (valid7) {
                                                if (data14.schema !== void 0) {
                                                  const _errs42 = errors;
                                                  if (typeof data14.schema !== "string") {
                                                    validate33.errors = [{ instancePath: instancePath + "/descriptor/scope/schema", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/properties/schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                    return false;
                                                  }
                                                  var valid7 = _errs42 === errors;
                                                } else {
                                                  var valid7 = true;
                                                }
                                              }
                                            }
                                          }
                                        } else {
                                          validate33.errors = [{ instancePath: instancePath + "/descriptor/scope", schemaPath: "https://identity.foundation/dwn/json-schemas/permissions/defs.json#/definitions/scope/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                          return false;
                                        }
                                      }
                                      var valid1 = _errs34 === errors;
                                    } else {
                                      var valid1 = true;
                                    }
                                    if (valid1) {
                                      if (data1.objectId !== void 0) {
                                        let data18 = data1.objectId;
                                        const _errs44 = errors;
                                        const _errs45 = errors;
                                        if (errors === _errs45) {
                                          if (typeof data18 === "string") {
                                            if (!pattern13.test(data18)) {
                                              validate33.errors = [{ instancePath: instancePath + "/descriptor/objectId", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/uuid/pattern", keyword: "pattern", params: { pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$" }, message: 'must match pattern "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"' }];
                                              return false;
                                            }
                                          } else {
                                            validate33.errors = [{ instancePath: instancePath + "/descriptor/objectId", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/uuid/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                        }
                                        var valid1 = _errs44 === errors;
                                      } else {
                                        var valid1 = true;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate33.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate33.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate33.errors = vErrors;
  return errors === 0;
}
var ProtocolDefinition = validate35;
var pattern17 = new RegExp(".*", "u");
var schema48 = { "$id": "https://identity.foundation/dwn/json-schemas/protocol-rule-set.json", "$schema": "http://json-schema.org/draft-07/schema#", "type": "object", "additionalProperties": false, "properties": { "allow": { "type": "object", "minProperties": 1, "additionalProperties": false, "properties": { "anyone": { "type": "object", "additionalProperties": false, "properties": { "to": { "type": "array", "minItems": 1, "items": { "type": "string", "enum": ["read", "write"] } } }, "required": ["to"] }, "author": { "type": "object", "additionalProperties": false, "properties": { "of": { "type": "string" }, "to": { "type": "array", "minItems": 1, "items": { "type": "string", "enum": ["read", "write"] } } }, "required": ["of", "to"] }, "recipient": { "type": "object", "additionalProperties": false, "properties": { "of": { "type": "string" }, "to": { "type": "array", "minItems": 1, "items": { "type": "string", "enum": ["read", "write"] } } }, "required": ["of", "to"] } } }, "records": { "type": "object", "patternProperties": { ".*": { "$ref": "https://identity.foundation/dwn/json-schemas/protocol-rule-set.json" } } } } };
var wrapper0 = { validate: validate36 };
function validate36(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      const _errs1 = errors;
      for (const key0 in data) {
        if (!(key0 === "allow" || key0 === "records")) {
          validate36.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
          return false;
          break;
        }
      }
      if (_errs1 === errors) {
        if (data.allow !== void 0) {
          let data0 = data.allow;
          const _errs2 = errors;
          if (errors === _errs2) {
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              if (Object.keys(data0).length < 1) {
                validate36.errors = [{ instancePath: instancePath + "/allow", schemaPath: "#/properties/allow/minProperties", keyword: "minProperties", params: { limit: 1 }, message: "must NOT have fewer than 1 properties" }];
                return false;
              } else {
                const _errs4 = errors;
                for (const key1 in data0) {
                  if (!(key1 === "anyone" || key1 === "author" || key1 === "recipient")) {
                    validate36.errors = [{ instancePath: instancePath + "/allow", schemaPath: "#/properties/allow/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                    return false;
                    break;
                  }
                }
                if (_errs4 === errors) {
                  if (data0.anyone !== void 0) {
                    let data1 = data0.anyone;
                    const _errs5 = errors;
                    if (errors === _errs5) {
                      if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                        let missing0;
                        if (data1.to === void 0 && (missing0 = "to")) {
                          validate36.errors = [{ instancePath: instancePath + "/allow/anyone", schemaPath: "#/properties/allow/properties/anyone/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
                          return false;
                        } else {
                          const _errs7 = errors;
                          for (const key2 in data1) {
                            if (!(key2 === "to")) {
                              validate36.errors = [{ instancePath: instancePath + "/allow/anyone", schemaPath: "#/properties/allow/properties/anyone/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                              return false;
                              break;
                            }
                          }
                          if (_errs7 === errors) {
                            if (data1.to !== void 0) {
                              let data2 = data1.to;
                              const _errs8 = errors;
                              if (errors === _errs8) {
                                if (Array.isArray(data2)) {
                                  if (data2.length < 1) {
                                    validate36.errors = [{ instancePath: instancePath + "/allow/anyone/to", schemaPath: "#/properties/allow/properties/anyone/properties/to/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                    return false;
                                  } else {
                                    var valid3 = true;
                                    const len0 = data2.length;
                                    for (let i0 = 0; i0 < len0; i0++) {
                                      let data3 = data2[i0];
                                      const _errs10 = errors;
                                      if (typeof data3 !== "string") {
                                        validate36.errors = [{ instancePath: instancePath + "/allow/anyone/to/" + i0, schemaPath: "#/properties/allow/properties/anyone/properties/to/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                        return false;
                                      }
                                      if (!(data3 === "read" || data3 === "write")) {
                                        validate36.errors = [{ instancePath: instancePath + "/allow/anyone/to/" + i0, schemaPath: "#/properties/allow/properties/anyone/properties/to/items/enum", keyword: "enum", params: { allowedValues: schema48.properties.allow.properties.anyone.properties.to.items.enum }, message: "must be equal to one of the allowed values" }];
                                        return false;
                                      }
                                      var valid3 = _errs10 === errors;
                                      if (!valid3) {
                                        break;
                                      }
                                    }
                                  }
                                } else {
                                  validate36.errors = [{ instancePath: instancePath + "/allow/anyone/to", schemaPath: "#/properties/allow/properties/anyone/properties/to/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                  return false;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        validate36.errors = [{ instancePath: instancePath + "/allow/anyone", schemaPath: "#/properties/allow/properties/anyone/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid1 = _errs5 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data0.author !== void 0) {
                      let data4 = data0.author;
                      const _errs12 = errors;
                      if (errors === _errs12) {
                        if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                          let missing1;
                          if (data4.of === void 0 && (missing1 = "of") || data4.to === void 0 && (missing1 = "to")) {
                            validate36.errors = [{ instancePath: instancePath + "/allow/author", schemaPath: "#/properties/allow/properties/author/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                            return false;
                          } else {
                            const _errs14 = errors;
                            for (const key3 in data4) {
                              if (!(key3 === "of" || key3 === "to")) {
                                validate36.errors = [{ instancePath: instancePath + "/allow/author", schemaPath: "#/properties/allow/properties/author/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" }];
                                return false;
                                break;
                              }
                            }
                            if (_errs14 === errors) {
                              if (data4.of !== void 0) {
                                const _errs15 = errors;
                                if (typeof data4.of !== "string") {
                                  validate36.errors = [{ instancePath: instancePath + "/allow/author/of", schemaPath: "#/properties/allow/properties/author/properties/of/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                                var valid4 = _errs15 === errors;
                              } else {
                                var valid4 = true;
                              }
                              if (valid4) {
                                if (data4.to !== void 0) {
                                  let data6 = data4.to;
                                  const _errs17 = errors;
                                  if (errors === _errs17) {
                                    if (Array.isArray(data6)) {
                                      if (data6.length < 1) {
                                        validate36.errors = [{ instancePath: instancePath + "/allow/author/to", schemaPath: "#/properties/allow/properties/author/properties/to/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                        return false;
                                      } else {
                                        var valid5 = true;
                                        const len1 = data6.length;
                                        for (let i1 = 0; i1 < len1; i1++) {
                                          let data7 = data6[i1];
                                          const _errs19 = errors;
                                          if (typeof data7 !== "string") {
                                            validate36.errors = [{ instancePath: instancePath + "/allow/author/to/" + i1, schemaPath: "#/properties/allow/properties/author/properties/to/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                          if (!(data7 === "read" || data7 === "write")) {
                                            validate36.errors = [{ instancePath: instancePath + "/allow/author/to/" + i1, schemaPath: "#/properties/allow/properties/author/properties/to/items/enum", keyword: "enum", params: { allowedValues: schema48.properties.allow.properties.author.properties.to.items.enum }, message: "must be equal to one of the allowed values" }];
                                            return false;
                                          }
                                          var valid5 = _errs19 === errors;
                                          if (!valid5) {
                                            break;
                                          }
                                        }
                                      }
                                    } else {
                                      validate36.errors = [{ instancePath: instancePath + "/allow/author/to", schemaPath: "#/properties/allow/properties/author/properties/to/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                      return false;
                                    }
                                  }
                                  var valid4 = _errs17 === errors;
                                } else {
                                  var valid4 = true;
                                }
                              }
                            }
                          }
                        } else {
                          validate36.errors = [{ instancePath: instancePath + "/allow/author", schemaPath: "#/properties/allow/properties/author/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                          return false;
                        }
                      }
                      var valid1 = _errs12 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data0.recipient !== void 0) {
                        let data8 = data0.recipient;
                        const _errs21 = errors;
                        if (errors === _errs21) {
                          if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
                            let missing2;
                            if (data8.of === void 0 && (missing2 = "of") || data8.to === void 0 && (missing2 = "to")) {
                              validate36.errors = [{ instancePath: instancePath + "/allow/recipient", schemaPath: "#/properties/allow/properties/recipient/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" }];
                              return false;
                            } else {
                              const _errs23 = errors;
                              for (const key4 in data8) {
                                if (!(key4 === "of" || key4 === "to")) {
                                  validate36.errors = [{ instancePath: instancePath + "/allow/recipient", schemaPath: "#/properties/allow/properties/recipient/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key4 }, message: "must NOT have additional properties" }];
                                  return false;
                                  break;
                                }
                              }
                              if (_errs23 === errors) {
                                if (data8.of !== void 0) {
                                  const _errs24 = errors;
                                  if (typeof data8.of !== "string") {
                                    validate36.errors = [{ instancePath: instancePath + "/allow/recipient/of", schemaPath: "#/properties/allow/properties/recipient/properties/of/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                    return false;
                                  }
                                  var valid6 = _errs24 === errors;
                                } else {
                                  var valid6 = true;
                                }
                                if (valid6) {
                                  if (data8.to !== void 0) {
                                    let data10 = data8.to;
                                    const _errs26 = errors;
                                    if (errors === _errs26) {
                                      if (Array.isArray(data10)) {
                                        if (data10.length < 1) {
                                          validate36.errors = [{ instancePath: instancePath + "/allow/recipient/to", schemaPath: "#/properties/allow/properties/recipient/properties/to/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                          return false;
                                        } else {
                                          var valid7 = true;
                                          const len2 = data10.length;
                                          for (let i2 = 0; i2 < len2; i2++) {
                                            let data11 = data10[i2];
                                            const _errs28 = errors;
                                            if (typeof data11 !== "string") {
                                              validate36.errors = [{ instancePath: instancePath + "/allow/recipient/to/" + i2, schemaPath: "#/properties/allow/properties/recipient/properties/to/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                            if (!(data11 === "read" || data11 === "write")) {
                                              validate36.errors = [{ instancePath: instancePath + "/allow/recipient/to/" + i2, schemaPath: "#/properties/allow/properties/recipient/properties/to/items/enum", keyword: "enum", params: { allowedValues: schema48.properties.allow.properties.recipient.properties.to.items.enum }, message: "must be equal to one of the allowed values" }];
                                              return false;
                                            }
                                            var valid7 = _errs28 === errors;
                                            if (!valid7) {
                                              break;
                                            }
                                          }
                                        }
                                      } else {
                                        validate36.errors = [{ instancePath: instancePath + "/allow/recipient/to", schemaPath: "#/properties/allow/properties/recipient/properties/to/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                        return false;
                                      }
                                    }
                                    var valid6 = _errs26 === errors;
                                  } else {
                                    var valid6 = true;
                                  }
                                }
                              }
                            }
                          } else {
                            validate36.errors = [{ instancePath: instancePath + "/allow/recipient", schemaPath: "#/properties/allow/properties/recipient/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                            return false;
                          }
                        }
                        var valid1 = _errs21 === errors;
                      } else {
                        var valid1 = true;
                      }
                    }
                  }
                }
              }
            } else {
              validate36.errors = [{ instancePath: instancePath + "/allow", schemaPath: "#/properties/allow/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
              return false;
            }
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.records !== void 0) {
            let data12 = data.records;
            const _errs30 = errors;
            if (errors === _errs30) {
              if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
                var valid8 = true;
                for (const key5 in data12) {
                  if (pattern17.test(key5)) {
                    const _errs32 = errors;
                    if (!wrapper0.validate(data12[key5], { instancePath: instancePath + "/records/" + key5.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data12, parentDataProperty: key5, rootData })) {
                      vErrors = vErrors === null ? wrapper0.validate.errors : vErrors.concat(wrapper0.validate.errors);
                      errors = vErrors.length;
                    }
                    var valid8 = _errs32 === errors;
                    if (!valid8) {
                      break;
                    }
                  }
                }
              } else {
                validate36.errors = [{ instancePath: instancePath + "/records", schemaPath: "#/properties/records/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                return false;
              }
            }
            var valid0 = _errs30 === errors;
          } else {
            var valid0 = true;
          }
        }
      }
    } else {
      validate36.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate36.errors = vErrors;
  return errors === 0;
}
function validate35(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.labels === void 0 && (missing0 = "labels") || data.records === void 0 && (missing0 = "records")) {
        validate35.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "labels" || key0 === "records")) {
            validate35.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.labels !== void 0) {
            let data0 = data.labels;
            const _errs2 = errors;
            if (errors === _errs2) {
              if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
                var valid1 = true;
                for (const key1 in data0) {
                  if (pattern17.test(key1)) {
                    let data1 = data0[key1];
                    const _errs4 = errors;
                    if (errors === _errs4) {
                      if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                        const _errs6 = errors;
                        for (const key2 in data1) {
                          if (!(key2 === "schema")) {
                            validate35.errors = [{ instancePath: instancePath + "/labels/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/labels/patternProperties/.*/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                            return false;
                            break;
                          }
                        }
                        if (_errs6 === errors) {
                          if (data1.schema !== void 0) {
                            if (typeof data1.schema !== "string") {
                              validate35.errors = [{ instancePath: instancePath + "/labels/" + key1.replace(/~/g, "~0").replace(/\//g, "~1") + "/schema", schemaPath: "#/properties/labels/patternProperties/.*/properties/schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                        }
                      } else {
                        validate35.errors = [{ instancePath: instancePath + "/labels/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/labels/patternProperties/.*/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid1 = _errs4 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                }
              } else {
                validate35.errors = [{ instancePath: instancePath + "/labels", schemaPath: "#/properties/labels/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                return false;
              }
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.records !== void 0) {
              let data3 = data.records;
              const _errs9 = errors;
              if (errors === _errs9) {
                if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
                  var valid3 = true;
                  for (const key3 in data3) {
                    if (pattern17.test(key3)) {
                      const _errs11 = errors;
                      if (!validate36(data3[key3], { instancePath: instancePath + "/records/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data3, parentDataProperty: key3, rootData })) {
                        vErrors = vErrors === null ? validate36.errors : vErrors.concat(validate36.errors);
                        errors = vErrors.length;
                      }
                      var valid3 = _errs11 === errors;
                      if (!valid3) {
                        break;
                      }
                    }
                  }
                } else {
                  validate35.errors = [{ instancePath: instancePath + "/records", schemaPath: "#/properties/records/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs9 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate35.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate35.errors = vErrors;
  return errors === 0;
}
var ProtocolRuleSet = validate36;
var ProtocolsConfigure = validate38;
var schema49 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/protocols-configure.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "protocol", "dateCreated", "definition"], "properties": { "interface": { "enum": ["Protocols"], "type": "string" }, "method": { "enum": ["Configure"], "type": "string" }, "protocol": { "type": "string" }, "dateCreated": { "type": "string" }, "definition": { "$ref": "https://identity.foundation/dwn/json-schemas/protocol-definition.json" } } } } };
function validate38(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate38.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate38.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method") || data1.protocol === void 0 && (missing1 = "protocol") || data1.dateCreated === void 0 && (missing1 = "dateCreated") || data1.definition === void 0 && (missing1 = "definition")) {
                    validate38.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "protocol" || key1 === "dateCreated" || key1 === "definition")) {
                        validate38.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate38.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Protocols")) {
                          validate38.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema49.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate38.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Configure")) {
                            validate38.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema49.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.protocol !== void 0) {
                            const _errs10 = errors;
                            if (typeof data1.protocol !== "string") {
                              validate38.errors = [{ instancePath: instancePath + "/descriptor/protocol", schemaPath: "#/properties/descriptor/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data1.dateCreated !== void 0) {
                              const _errs12 = errors;
                              if (typeof data1.dateCreated !== "string") {
                                validate38.errors = [{ instancePath: instancePath + "/descriptor/dateCreated", schemaPath: "#/properties/descriptor/properties/dateCreated/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                              var valid1 = _errs12 === errors;
                            } else {
                              var valid1 = true;
                            }
                            if (valid1) {
                              if (data1.definition !== void 0) {
                                const _errs14 = errors;
                                if (!validate35(data1.definition, { instancePath: instancePath + "/descriptor/definition", parentData: data1, parentDataProperty: "definition", rootData })) {
                                  vErrors = vErrors === null ? validate35.errors : vErrors.concat(validate35.errors);
                                  errors = vErrors.length;
                                }
                                var valid1 = _errs14 === errors;
                              } else {
                                var valid1 = true;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate38.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate38.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate38.errors = vErrors;
  return errors === 0;
}
var ProtocolsQuery = validate41;
var schema50 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/protocols-query.json", "type": "object", "additionalProperties": false, "required": ["authorization", "descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "dateCreated"], "properties": { "interface": { "enum": ["Protocols"], "type": "string" }, "method": { "enum": ["Query"], "type": "string" }, "dateCreated": { "type": "string" }, "filter": { "type": "object", "minProperties": 1, "additionalProperties": false, "properties": { "protocol": { "type": "string" }, "recipient": { "$ref": "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did" } } } } } } };
function validate41(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.authorization === void 0 && (missing0 = "authorization") || data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate41.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate41.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method") || data1.dateCreated === void 0 && (missing1 = "dateCreated")) {
                    validate41.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "dateCreated" || key1 === "filter")) {
                        validate41.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate41.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Protocols")) {
                          validate41.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema50.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate41.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Query")) {
                            validate41.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema50.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.dateCreated !== void 0) {
                            const _errs10 = errors;
                            if (typeof data1.dateCreated !== "string") {
                              validate41.errors = [{ instancePath: instancePath + "/descriptor/dateCreated", schemaPath: "#/properties/descriptor/properties/dateCreated/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data1.filter !== void 0) {
                              let data5 = data1.filter;
                              const _errs12 = errors;
                              if (errors === _errs12) {
                                if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                                  if (Object.keys(data5).length < 1) {
                                    validate41.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/minProperties", keyword: "minProperties", params: { limit: 1 }, message: "must NOT have fewer than 1 properties" }];
                                    return false;
                                  } else {
                                    const _errs14 = errors;
                                    for (const key2 in data5) {
                                      if (!(key2 === "protocol" || key2 === "recipient")) {
                                        validate41.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" }];
                                        return false;
                                        break;
                                      }
                                    }
                                    if (_errs14 === errors) {
                                      if (data5.protocol !== void 0) {
                                        const _errs15 = errors;
                                        if (typeof data5.protocol !== "string") {
                                          validate41.errors = [{ instancePath: instancePath + "/descriptor/filter/protocol", schemaPath: "#/properties/descriptor/properties/filter/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                          return false;
                                        }
                                        var valid2 = _errs15 === errors;
                                      } else {
                                        var valid2 = true;
                                      }
                                      if (valid2) {
                                        if (data5.recipient !== void 0) {
                                          let data7 = data5.recipient;
                                          const _errs17 = errors;
                                          const _errs18 = errors;
                                          if (errors === _errs18) {
                                            if (typeof data7 === "string") {
                                              if (!pattern3.test(data7)) {
                                                validate41.errors = [{ instancePath: instancePath + "/descriptor/filter/recipient", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/pattern", keyword: "pattern", params: { pattern: "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$" }, message: 'must match pattern "^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$"' }];
                                                return false;
                                              }
                                            } else {
                                              validate41.errors = [{ instancePath: instancePath + "/descriptor/filter/recipient", schemaPath: "https://identity.foundation/dwn/json-schemas/defs.json#/definitions/did/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                          var valid2 = _errs17 === errors;
                                        } else {
                                          var valid2 = true;
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  validate41.errors = [{ instancePath: instancePath + "/descriptor/filter", schemaPath: "#/properties/descriptor/properties/filter/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                  return false;
                                }
                              }
                              var valid1 = _errs12 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate41.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate41.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate41.errors = vErrors;
  return errors === 0;
}
var RecordsRead = validate43;
var schema52 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "https://identity.foundation/dwn/json-schemas/records-read.json", "type": "object", "additionalProperties": false, "required": ["descriptor"], "properties": { "authorization": { "$ref": "https://identity.foundation/dwn/json-schemas/general-jws.json" }, "descriptor": { "type": "object", "additionalProperties": false, "required": ["interface", "method", "date", "recordId"], "properties": { "interface": { "enum": ["Records"], "type": "string" }, "method": { "enum": ["Read"], "type": "string" }, "date": { "type": "string" }, "recordId": { "type": "string" } } } } };
function validate43(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
  ;
  let vErrors = null;
  let errors = 0;
  if (errors === 0) {
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.descriptor === void 0 && (missing0 = "descriptor")) {
        validate43.errors = [{ instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" }];
        return false;
      } else {
        const _errs1 = errors;
        for (const key0 in data) {
          if (!(key0 === "authorization" || key0 === "descriptor")) {
            validate43.errors = [{ instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" }];
            return false;
            break;
          }
        }
        if (_errs1 === errors) {
          if (data.authorization !== void 0) {
            const _errs2 = errors;
            if (!validate11(data.authorization, { instancePath: instancePath + "/authorization", parentData: data, parentDataProperty: "authorization", rootData })) {
              vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.descriptor !== void 0) {
              let data1 = data.descriptor;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
                  let missing1;
                  if (data1.interface === void 0 && (missing1 = "interface") || data1.method === void 0 && (missing1 = "method") || data1.date === void 0 && (missing1 = "date") || data1.recordId === void 0 && (missing1 = "recordId")) {
                    validate43.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                    return false;
                  } else {
                    const _errs5 = errors;
                    for (const key1 in data1) {
                      if (!(key1 === "interface" || key1 === "method" || key1 === "date" || key1 === "recordId")) {
                        validate43.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" }];
                        return false;
                        break;
                      }
                    }
                    if (_errs5 === errors) {
                      if (data1.interface !== void 0) {
                        let data2 = data1.interface;
                        const _errs6 = errors;
                        if (typeof data2 !== "string") {
                          validate43.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                          return false;
                        }
                        if (!(data2 === "Records")) {
                          validate43.errors = [{ instancePath: instancePath + "/descriptor/interface", schemaPath: "#/properties/descriptor/properties/interface/enum", keyword: "enum", params: { allowedValues: schema52.properties.descriptor.properties.interface.enum }, message: "must be equal to one of the allowed values" }];
                          return false;
                        }
                        var valid1 = _errs6 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data1.method !== void 0) {
                          let data3 = data1.method;
                          const _errs8 = errors;
                          if (typeof data3 !== "string") {
                            validate43.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                          if (!(data3 === "Read")) {
                            validate43.errors = [{ instancePath: instancePath + "/descriptor/method", schemaPath: "#/properties/descriptor/properties/method/enum", keyword: "enum", params: { allowedValues: schema52.properties.descriptor.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs8 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data1.date !== void 0) {
                            const _errs10 = errors;
                            if (typeof data1.date !== "string") {
                              validate43.errors = [{ instancePath: instancePath + "/descriptor/date", schemaPath: "#/properties/descriptor/properties/date/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                            var valid1 = _errs10 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data1.recordId !== void 0) {
                              const _errs12 = errors;
                              if (typeof data1.recordId !== "string") {
                                validate43.errors = [{ instancePath: instancePath + "/descriptor/recordId", schemaPath: "#/properties/descriptor/properties/recordId/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                              var valid1 = _errs12 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  validate43.errors = [{ instancePath: instancePath + "/descriptor", schemaPath: "#/properties/descriptor/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate43.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
      return false;
    }
  }
  validate43.errors = vErrors;
  return errors === 0;
}
var PublicJwk = validate19;

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/schema-validator.js
function validateJsonSchema(schemaName, payload) {
  const validateFn = precompiled_validators_exports[schemaName];
  if (!validateFn) {
    throw new Error(`schema for ${schemaName} not found.`);
  }
  validateFn(payload);
  if (!validateFn.errors) {
    return;
  }
  const [errorObj] = validateFn.errors;
  let { instancePath, message: message2 } = errorObj;
  if (!instancePath) {
    instancePath = schemaName;
  }
  throw new Error(`${instancePath}: ${message2}`);
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/core/message.js
var __awaiter11 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DwnInterfaceName;
(function(DwnInterfaceName2) {
  DwnInterfaceName2["Events"] = "Events";
  DwnInterfaceName2["Hooks"] = "Hooks";
  DwnInterfaceName2["Messages"] = "Messages";
  DwnInterfaceName2["Permissions"] = "Permissions";
  DwnInterfaceName2["Protocols"] = "Protocols";
  DwnInterfaceName2["Records"] = "Records";
})(DwnInterfaceName || (DwnInterfaceName = {}));
var DwnMethodName;
(function(DwnMethodName2) {
  DwnMethodName2["Configure"] = "Configure";
  DwnMethodName2["Get"] = "Get";
  DwnMethodName2["Grant"] = "Grant";
  DwnMethodName2["Query"] = "Query";
  DwnMethodName2["Read"] = "Read";
  DwnMethodName2["Request"] = "Request";
  DwnMethodName2["Write"] = "Write";
  DwnMethodName2["Delete"] = "Delete";
})(DwnMethodName || (DwnMethodName = {}));
var Message = class {
  constructor(message2) {
    this.message = message2;
    if (message2.authorization !== void 0) {
      this.authorizationPayload = Jws.decodePlainObjectPayload(message2.authorization);
      this.author = Message.getAuthor(message2);
    }
  }
  /**
   * Called by `JSON.stringify(...)` automatically.
   */
  toJSON() {
    return this.message;
  }
  /**
   * Validates the given message against the corresponding JSON schema.
   * @throws {Error} if fails validation.
   */
  static validateJsonSchema(rawMessage) {
    const dwnInterface = rawMessage.descriptor.interface;
    const dwnMethod = rawMessage.descriptor.method;
    const schemaLookupKey = dwnInterface + dwnMethod;
    validateJsonSchema(schemaLookupKey, rawMessage);
  }
  /**
   * Gets the DID of the author of the given message, returned `undefined` if message is not signed.
   */
  static getAuthor(message2) {
    if (message2.authorization === void 0) {
      return void 0;
    }
    const author = Jws.getSignerDid(message2.authorization.signatures[0]);
    return author;
  }
  /**
   * Gets the CID of the given message.
   */
  static getCid(message2) {
    return __awaiter11(this, void 0, void 0, function* () {
      const cid = yield computeCid(message2);
      return cid;
    });
  }
  /**
   * Compares message CID in lexicographical order according to the spec.
   * @returns 1 if `a` is larger than `b`; -1 if `a` is smaller/older than `b`; 0 otherwise (same message)
   */
  static compareCid(a2, b2) {
    return __awaiter11(this, void 0, void 0, function* () {
      const cidA = yield Message.getCid(a2);
      const cidB = yield Message.getCid(b2);
      return lexicographicalCompare(cidA, cidB);
    });
  }
  /**
   * Compares the CID of two messages.
   * @returns `true` if `a` is newer than `b`; `false` otherwise
   */
  static isCidLarger(a2, b2) {
    return __awaiter11(this, void 0, void 0, function* () {
      const aIsLarger = (yield Message.compareCid(a2, b2)) > 0;
      return aIsLarger;
    });
  }
  /**
   * @returns message with the largest CID in the array using lexicographical compare. `undefined` if given array is empty.
   */
  static getMessageWithLargestCid(messages) {
    return __awaiter11(this, void 0, void 0, function* () {
      let currentNewestMessage = void 0;
      for (const message2 of messages) {
        if (currentNewestMessage === void 0 || (yield Message.isCidLarger(message2, currentNewestMessage))) {
          currentNewestMessage = message2;
        }
      }
      return currentNewestMessage;
    });
  }
  /**
   * Signs the provided message to be used an `authorization` property. Signed payload includes the CID of the message's descriptor by default
   * along with any additional payload properties provided
   * @param descriptor - the message to sign
   * @param signatureInput - the signature material to use (e.g. key and header data)
   * @returns General JWS signature used as an `authorization` property.
   */
  static signAsAuthorization(descriptor2, signatureInput) {
    return __awaiter11(this, void 0, void 0, function* () {
      const descriptorCid = yield computeCid(descriptor2);
      const authPayload = { descriptorCid };
      const authPayloadStr = JSON.stringify(authPayload);
      const authPayloadBytes = new TextEncoder().encode(authPayloadStr);
      const signer = yield GeneralJwsSigner.create(authPayloadBytes, [signatureInput]);
      return signer.getJws();
    });
  }
  /**
   * @returns newest message in the array. `undefined` if given array is empty.
   */
  static getNewestMessage(messages) {
    return __awaiter11(this, void 0, void 0, function* () {
      let currentNewestMessage = void 0;
      for (const message2 of messages) {
        if (currentNewestMessage === void 0 || (yield Message.isNewer(message2, currentNewestMessage))) {
          currentNewestMessage = message2;
        }
      }
      return currentNewestMessage;
    });
  }
  /**
   * Checks if first message is newer than second message.
   * @returns `true` if `a` is newer than `b`; `false` otherwise
   */
  static isNewer(a2, b2) {
    return __awaiter11(this, void 0, void 0, function* () {
      const aIsNewer = (yield Message.compareModifiedTime(a2, b2)) > 0;
      return aIsNewer;
    });
  }
  /**
   * Checks if first message is older than second message.
   * @returns `true` if `a` is older than `b`; `false` otherwise
   */
  static isOlder(a2, b2) {
    return __awaiter11(this, void 0, void 0, function* () {
      const aIsNewer = (yield Message.compareModifiedTime(a2, b2)) < 0;
      return aIsNewer;
    });
  }
  /**
   * Compares the `dateModified` of the given messages with a fallback to message CID according to the spec.
   * @returns 1 if `a` is larger/newer than `b`; -1 if `a` is smaller/older than `b`; 0 otherwise (same age)
   */
  static compareModifiedTime(a2, b2) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (a2.descriptor.dateModified > b2.descriptor.dateModified) {
        return 1;
      } else if (a2.descriptor.dateModified < b2.descriptor.dateModified) {
        return -1;
      }
      return Message.compareCid(a2, b2);
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/object.js
var import_flat3 = __toESM(require_flat(), 1);
function flatten2(obj) {
  const flattened = import_flat3.default.flatten(obj);
  removeEmptyObjects(flattened);
  return flattened;
}
function isEmptyObject(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  for (const _2 in obj) {
    return false;
  }
  return true;
}
function removeEmptyObjects(obj) {
  Object.keys(obj).forEach((key) => {
    if (isEmptyObject(obj[key])) {
      delete obj[key];
    } else if (typeof obj[key] === "object") {
      removeEmptyObjects(obj[key]);
    }
  });
}
function removeUndefinedProperties(obj) {
  Object.keys(obj).forEach((key) => {
    if (obj[key] === void 0) {
      delete obj[key];
    } else if (typeof obj[key] === "object") {
      removeUndefinedProperties(obj[key]);
    }
  });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/memory-cache.js
var import_lru_cache = __toESM(require_lru_cache(), 1);
var __awaiter12 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MemoryCache = class {
  /**
   * @param timeToLiveInSeconds time-to-live for every key-value pair set in the cache
   */
  constructor(timeToLiveInSeconds) {
    this.timeToLiveInSeconds = timeToLiveInSeconds;
    this.cache = new import_lru_cache.default({
      max: 1e5,
      ttl: timeToLiveInSeconds * 1e3
    });
  }
  set(key, value) {
    return __awaiter12(this, void 0, void 0, function* () {
      try {
        this.cache.set(key, value);
      } catch (_a2) {
      }
    });
  }
  get(key) {
    return __awaiter12(this, void 0, void 0, function* () {
      return this.cache.get(key);
    });
  }
  dump() {
    return __awaiter12(this, void 0, void 0, function* () {
      for (const [key, value] of this.cache) {
        console.debug(key, value);
      }
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/jose/jws/general/verifier.js
var __awaiter13 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var GeneralJwsVerifier = class {
  constructor(jws, cache2) {
    this.jws = jws;
    this.cache = cache2 || new MemoryCache(600);
  }
  verify(didResolver) {
    return __awaiter13(this, void 0, void 0, function* () {
      const signers2 = [];
      for (const signatureEntry of this.jws.signatures) {
        let isVerified;
        const cacheKey = `${signatureEntry.protected}.${this.jws.payload}.${signatureEntry.signature}`;
        const kid = Jws.getKid(signatureEntry);
        const publicJwk = yield GeneralJwsVerifier.getPublicKey(kid, didResolver);
        const cachedValue = yield this.cache.get(cacheKey);
        if (cachedValue === void 0) {
          isVerified = yield Jws.verifySignature(this.jws.payload, signatureEntry, publicJwk);
          yield this.cache.set(cacheKey, isVerified);
        } else {
          isVerified = cachedValue;
        }
        const did = Jws.extractDid(kid);
        if (isVerified) {
          signers2.push(did);
        } else {
          throw new Error(`signature verification failed for ${did}`);
        }
      }
      return { signers: signers2 };
    });
  }
  /**
   * Gets the public key given a fully qualified key ID (`kid`).
   */
  static getPublicKey(kid, didResolver) {
    return __awaiter13(this, void 0, void 0, function* () {
      const did = Jws.extractDid(kid);
      const { didDocument } = yield didResolver.resolve(did);
      const { verificationMethod: verificationMethods = [] } = didDocument || {};
      let verificationMethod;
      for (const vm of verificationMethods) {
        if (kid.endsWith(vm.id)) {
          verificationMethod = vm;
          break;
        }
      }
      if (!verificationMethod) {
        throw new Error("public key needed to verify signature not found in DID Document");
      }
      validateJsonSchema("JwkVerificationMethod", verificationMethod);
      const { publicKeyJwk: publicJwk } = verificationMethod;
      return publicJwk;
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/core/auth.js
var __awaiter14 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function canonicalAuth(tenant, incomingMessage, didResolver) {
  return __awaiter14(this, void 0, void 0, function* () {
    yield authenticate(incomingMessage.message.authorization, didResolver);
    yield authorize(tenant, incomingMessage);
  });
}
function validateAuthorizationIntegrity(message2, authorizationPayloadConstraints) {
  var _a2;
  return __awaiter14(this, void 0, void 0, function* () {
    if (message2.authorization === void 0) {
      throw new DwnError(DwnErrorCode.AuthorizationMissing, "Property `authorization` is missing.");
    }
    if (message2.authorization.signatures.length !== 1) {
      throw new Error("expected no more than 1 signature for authorization");
    }
    const payloadJson = Jws.decodePlainObjectPayload(message2.authorization);
    const { descriptorCid } = payloadJson;
    const expectedDescriptorCid = yield computeCid(message2.descriptor);
    if (descriptorCid !== expectedDescriptorCid) {
      throw new Error(`provided descriptorCid ${descriptorCid} does not match expected CID ${expectedDescriptorCid}`);
    }
    const allowedProperties = (_a2 = authorizationPayloadConstraints === null || authorizationPayloadConstraints === void 0 ? void 0 : authorizationPayloadConstraints.allowedProperties) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Set();
    const customProperties = Object.assign({}, payloadJson);
    delete customProperties.descriptorCid;
    for (const propertyName in customProperties) {
      {
        if (!allowedProperties.has(propertyName)) {
          throw new Error(`${propertyName} not allowed in auth payload.`);
        }
      }
      try {
        parseCid(payloadJson[propertyName]);
      } catch (e2) {
        throw new Error(`${propertyName} must be a valid CID`);
      }
    }
    return payloadJson;
  });
}
function authenticate(jws, didResolver) {
  return __awaiter14(this, void 0, void 0, function* () {
    if (jws === void 0) {
      throw new DwnError(DwnErrorCode.AuthenticateJwsMissing, "Missing JWS.");
    }
    const verifier = new GeneralJwsVerifier(jws);
    yield verifier.verify(didResolver);
  });
}
function authorize(tenant, incomingMessage) {
  return __awaiter14(this, void 0, void 0, function* () {
    if (incomingMessage.author === tenant) {
      return;
    } else {
      throw new Error("message failed authorization, permission grant check not yet implemented");
    }
  });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/messages/records-query.js
var __awaiter15 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DateSort;
(function(DateSort2) {
  DateSort2["CreatedAscending"] = "createdAscending";
  DateSort2["CreatedDescending"] = "createdDescending";
  DateSort2["PublishedAscending"] = "publishedAscending";
  DateSort2["PublishedDescending"] = "publishedDescending";
})(DateSort || (DateSort = {}));
var RecordsQuery2 = class extends Message {
  static parse(message2) {
    return __awaiter15(this, void 0, void 0, function* () {
      yield validateAuthorizationIntegrity(message2);
      return new RecordsQuery2(message2);
    });
  }
  static create(options) {
    var _a2;
    return __awaiter15(this, void 0, void 0, function* () {
      const descriptor2 = {
        interface: DwnInterfaceName.Records,
        method: DwnMethodName.Query,
        dateCreated: (_a2 = options.dateCreated) !== null && _a2 !== void 0 ? _a2 : getCurrentTimeInHighPrecision(),
        filter: options.filter,
        dateSort: options.dateSort
      };
      removeUndefinedProperties(descriptor2);
      const authorization = yield Message.signAsAuthorization(descriptor2, options.authorizationSignatureInput);
      const message2 = { descriptor: descriptor2, authorization };
      Message.validateJsonSchema(message2);
      return new RecordsQuery2(message2);
    });
  }
  authorize(tenant) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (this.author === tenant) {
        return;
      }
      const recipientDid = this.message.descriptor.filter.recipient;
      if (recipientDid !== void 0) {
        if (recipientDid !== this.author) {
          throw new Error(`${this.author} is not allowed to query records intended for another recipient: ${recipientDid}`);
        }
      }
    });
  }
  static convertFilter(filter2) {
    const filterCopy = Object.assign({}, filter2);
    const { dateCreated } = filterCopy;
    let rangeFilter = void 0;
    if (dateCreated !== void 0) {
      if (dateCreated.to !== void 0 && dateCreated.from !== void 0) {
        rangeFilter = {
          gte: dateCreated.from,
          lt: dateCreated.to
        };
      } else if (dateCreated.to !== void 0) {
        rangeFilter = {
          lt: dateCreated.to
        };
      } else if (dateCreated.from !== void 0) {
        rangeFilter = {
          gte: dateCreated.from
        };
      }
    }
    if (rangeFilter) {
      filterCopy.dateCreated = rangeFilter;
    }
    return filterCopy;
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/data-stream.js
var import_readable_stream2 = __toESM(require_ours(), 1);
var __awaiter16 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DataStream = class {
  /**
   * Reads the entire readable stream given into array of bytes.
   */
  static toBytes(readableStream) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new Promise((resolve5, reject) => {
        const chunks = [];
        readableStream.on("data", (chunk) => {
          chunks.push(chunk);
        });
        readableStream.on("end", () => {
          const uint8Array = DataStream.concatenateArrayOfBytes(chunks);
          resolve5(uint8Array);
        });
        readableStream.on("error", reject);
      });
    });
  }
  /**
   * Concatenates the array of bytes given into one Uint8Array.
   */
  static concatenateArrayOfBytes(arrayOfBytes) {
    const totalLength = arrayOfBytes.reduce((accumulatedValue, currentValue) => accumulatedValue + currentValue.length, 0);
    const result = new Uint8Array(totalLength);
    let length5 = 0;
    for (const bytes of arrayOfBytes) {
      result.set(bytes, length5);
      length5 += bytes.length;
    }
    return result;
  }
  /**
   * Creates a readable stream from the bytes given.
   */
  static fromBytes(bytes) {
    const chunkLength = 1e5;
    let currentIndex = 0;
    const readableStream = new import_readable_stream2.Readable({
      read(_size) {
        if (currentIndex + chunkLength > bytes.length) {
          this.push(bytes.subarray(currentIndex));
          this.push(null);
        } else {
          this.push(bytes.subarray(currentIndex, currentIndex + chunkLength));
          currentIndex = currentIndex + chunkLength;
        }
      }
    });
    return readableStream;
  }
  /**
   * Creates a readable stream from the object given.
   */
  static fromObject(object) {
    const bytes = Encoder5.objectToBytes(object);
    return DataStream.fromBytes(bytes);
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/hd-key.js
var KeyDerivationScheme;
(function(KeyDerivationScheme2) {
  KeyDerivationScheme2["ProtocolContext"] = "protocol-context";
})(KeyDerivationScheme || (KeyDerivationScheme = {}));

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/did/did-key-resolver.js
var import_varint5 = __toESM(require_varint3(), 1);

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/did/did.js
var Did = class {
  /**
   * Gets the method specific ID segment of a DID. ie. did:<method-name>:<method-specific-id>
   */
  static getMethodSpecificId(did) {
    const secondColonIndex = did.indexOf(":", 4);
    const methodSpecificId = did.substring(secondColonIndex + 1);
    return methodSpecificId;
  }
  /**
   * @param did - the DID to validate
   */
  static validate(did) {
    if (typeof did !== "string") {
      throw new Error(`DID is not string: ${did}`);
    }
    const didRegex = /^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(\/[^#?]*)?([?][^#]*)?(#.*)?$/;
    if (!didRegex.test(did)) {
      throw new TypeError(`DID is not a valid DID: ${did}`);
    }
  }
  /**
   * Gets the method name from a DID. ie. did:<method-name>:<method-specific-id>
   */
  static getMethodName(did) {
    const secondColonIndex = did.indexOf(":", 4);
    const methodName = did.substring(4, secondColonIndex);
    return methodName;
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/did/did-key-resolver.js
var __awaiter17 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidKeyResolver = class {
  method() {
    return "key";
  }
  /**
   * Gets the number of bytes of the multicodec header in the `did:key` DID.
   * @param did - A `did:key` DID
   * @returns size of the multicodec head in number of bytes
   */
  static getMulticodecSize(did) {
    let multicodecHeaderSize = 0;
    while (true) {
      const currentByte = did[multicodecHeaderSize];
      multicodecHeaderSize++;
      if ((currentByte & 128) !== 128) {
        break;
      }
    }
    return multicodecHeaderSize;
  }
  resolve(did) {
    return __awaiter17(this, void 0, void 0, function* () {
      const [_scheme, _method, id] = did.split(":", 3);
      try {
        const idBytes = base58btc.decode(id);
        const multicodec = import_varint5.default.decode(idBytes);
        const multicodecSize = DidKeyResolver.getMulticodecSize(idBytes);
        const publicKeyBytes = idBytes.slice(multicodecSize);
        const keySpecificContext = [];
        let publicJwk;
        if (multicodec === 237) {
          keySpecificContext.push("https://w3id.org/security/suites/ed25519-2020/v1");
          publicJwk = yield ed25519.publicKeyToJwk(publicKeyBytes);
        } else if (multicodec === 231) {
          publicJwk = yield Secp256k1.publicKeyToJwk(publicKeyBytes);
        } else {
          throw Error(`key type of multicodec ${multicodec} is not supported`);
        }
        const keyId = `${did}#${id}`;
        const didDocument = {
          "@context": [
            "https://www.w3.org/ns/did/v1",
            "https://w3id.org/security/suites/jws-2020/v1",
            ...keySpecificContext
          ],
          "id": did,
          "verificationMethod": [{
            id: keyId,
            type: "JsonWebKey2020",
            controller: did,
            publicKeyJwk: publicJwk
          }],
          "authentication": [keyId],
          "assertionMethod": [keyId],
          "capabilityDelegation": [keyId],
          "capabilityInvocation": [keyId]
        };
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument,
          didDocumentMetadata: {},
          didResolutionMetadata: {}
        };
      } catch (_a2) {
        return {
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            error: "invalidDid"
          }
        };
      }
    });
  }
  /**
   * Generates a new ed25519 public/private key pair. Creates a DID using the private key.
   * @returns DID and its key material.
   */
  static generate() {
    return __awaiter17(this, void 0, void 0, function* () {
      const { publicJwk, privateJwk } = yield ed25519.generateKeyPair();
      const ed25519Multicodec = import_varint5.default.encode(237);
      const publicKeyBytes = Encoder5.base64UrlToBytes(publicJwk.x);
      const idBytes = new Uint8Array(ed25519Multicodec.length + publicKeyBytes.byteLength);
      idBytes.set(ed25519Multicodec, 0);
      idBytes.set(publicKeyBytes, ed25519Multicodec.length);
      const id = base58btc.encode(idBytes);
      const did = `did:key:${id}`;
      const keyId = DidKeyResolver.getKeyId(did);
      return { did, keyId, keyPair: { publicJwk, privateJwk } };
    });
  }
  /**
   * Gets the fully qualified key ID of a `did:key` DID. ie. '<did>#<method-specific-id>'
   */
  static getKeyId(did) {
    const methodSpecificId = Did.getMethodSpecificId(did);
    const keyId = `${did}#${methodSpecificId}`;
    return keyId;
  }
  dump() {
    return __awaiter17(this, void 0, void 0, function* () {
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/did/did-ion-resolver.js
var import_cross_fetch = __toESM(require_node_ponyfill(), 1);
var __awaiter18 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a;
var fetch = (_a = globalThis.fetch) !== null && _a !== void 0 ? _a : import_cross_fetch.default;
var DidIonResolver = class {
  /**
   * @param resolutionEndpoint optional custom URL to send DID resolution request to
   */
  constructor(resolutionEndpoint = "https://discover.did.msidentity.com/1.0/identifiers/") {
    this.resolutionEndpoint = resolutionEndpoint;
  }
  method() {
    return "ion";
  }
  resolve(did) {
    return __awaiter18(this, void 0, void 0, function* () {
      const resolutionUrl = new URL("./" + did, this.resolutionEndpoint).toString();
      const response = yield fetch(resolutionUrl);
      if (response.status !== 200) {
        throw new Error(`unable to resolve ${did}, got http status ${response.status}`);
      }
      const didResolutionResult = yield response.json();
      return didResolutionResult;
    });
  }
  dump() {
    return __awaiter18(this, void 0, void 0, function* () {
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/did/did-resolver.js
var __awaiter19 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidResolver = class {
  constructor(resolvers2, cache2) {
    this.cache = cache2 || new MemoryCache(600);
    if (resolvers2 === void 0 || resolvers2.length === 0) {
      resolvers2 = [
        new DidIonResolver(),
        new DidKeyResolver()
      ];
    }
    this.didResolvers = /* @__PURE__ */ new Map();
    for (const resolver of resolvers2) {
      this.didResolvers.set(resolver.method(), resolver);
    }
  }
  /**
   * attempt to resolve the DID provided
   * @throws {Error} if DID is invalid
   * @throws {Error} if DID method is not supported
   * @throws {Error} if resolving DID fails
   * @param did - the DID to resolve
   * @returns {DidResolutionResult}
   */
  resolve(did) {
    return __awaiter19(this, void 0, void 0, function* () {
      Did.validate(did);
      const splitDID = did.split(":", 3);
      const didMethod = splitDID[1];
      const didResolver = this.didResolvers.get(didMethod);
      if (!didResolver) {
        throw new Error(`${didMethod} DID method not supported`);
      }
      const cachedResolutionResult = yield this.cache.get(did);
      const resolutionResult = cachedResolutionResult !== null && cachedResolutionResult !== void 0 ? cachedResolutionResult : yield didResolver.resolve(did);
      if (cachedResolutionResult === void 0) {
        yield this.cache.set(did, resolutionResult);
      }
      const { didDocument, didResolutionMetadata } = resolutionResult;
      if (!didDocument || (didResolutionMetadata === null || didResolutionMetadata === void 0 ? void 0 : didResolutionMetadata.error)) {
        const { error } = didResolutionMetadata;
        let errMsg = `Failed to resolve DID ${did}.`;
        errMsg += error ? ` Error: ${error}` : "";
        throw new Error(errMsg);
      }
      return resolutionResult;
    });
  }
  dump() {
    var _a2, _b, _c;
    return __awaiter19(this, void 0, void 0, function* () {
      console.group("didResolvers");
      for (const [key, value] of this.didResolvers) {
        console.group(key);
        yield (_a2 = value["dump"]) === null || _a2 === void 0 ? void 0 : _a2.call(value);
        console.groupEnd();
      }
      console.groupEnd();
      console.group("didCache");
      yield (_c = (_b = this.cache)["dump"]) === null || _c === void 0 ? void 0 : _c.call(_b);
      console.groupEnd();
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/event-log/event-log-level.js
var import_ulid = __toESM(require_index_umd(), 1);
var __awaiter20 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues5 = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve5, reject) {
        v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve5, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve5({ value: v3, done: d2 });
    }, reject);
  }
};
var WATERMARKS_SUBLEVEL_NAME = "watermarks";
var CIDS_SUBLEVEL_NAME = "cids";
var EventLogLevel = class {
  constructor(config) {
    this.config = Object.assign({ location: "EVENTLOG", createLevelDatabase }, config);
    this.db = new LevelWrapper(Object.assign(Object.assign({}, this.config), { valueEncoding: "utf8" }));
    this.ulid = (0, import_ulid.monotonicFactory)();
  }
  open() {
    return __awaiter20(this, void 0, void 0, function* () {
      return this.db.open();
    });
  }
  close() {
    return __awaiter20(this, void 0, void 0, function* () {
      return this.db.close();
    });
  }
  clear() {
    return __awaiter20(this, void 0, void 0, function* () {
      return this.db.clear();
    });
  }
  append(tenant, messageCid) {
    return __awaiter20(this, void 0, void 0, function* () {
      const tenantEventLog = yield this.db.partition(tenant);
      const watermarkLog = yield tenantEventLog.partition(WATERMARKS_SUBLEVEL_NAME);
      const cidLog = yield tenantEventLog.partition(CIDS_SUBLEVEL_NAME);
      const watermark = this.ulid();
      yield watermarkLog.put(watermark, messageCid);
      yield cidLog.put(messageCid, watermark);
      return watermark;
    });
  }
  getEvents(tenant, options) {
    var e_1, _a2;
    return __awaiter20(this, void 0, void 0, function* () {
      const tenantEventLog = yield this.db.partition(tenant);
      const watermarkLog = yield tenantEventLog.partition(WATERMARKS_SUBLEVEL_NAME);
      const events = [];
      try {
        for (var _b = __asyncValues5(watermarkLog.iterator(options)), _c; _c = yield _b.next(), !_c.done; ) {
          const [key, value] = _c.value;
          const event = { watermark: key, messageCid: value };
          events.push(event);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return events;
    });
  }
  deleteEventsByCid(tenant, cids) {
    return __awaiter20(this, void 0, void 0, function* () {
      if (cids.length === 0) {
        return 0;
      }
      const tenantEventLog = yield this.db.partition(tenant);
      const cidLog = yield tenantEventLog.partition(CIDS_SUBLEVEL_NAME);
      let ops = [];
      const promises = [];
      for (const cid of cids) {
        ops.push({ type: "del", key: cid });
        const promise = cidLog.get(cid).catch((e2) => e2);
        promises.push(promise);
      }
      yield cidLog.batch(ops);
      ops = [];
      let numEventsDeleted = 0;
      const watermarks = yield Promise.all(promises);
      for (const watermark of watermarks) {
        if (watermark) {
          ops.push({ type: "del", key: watermark });
          numEventsDeleted += 1;
        }
      }
      const watermarkLog = yield tenantEventLog.partition("watermarks");
      yield watermarkLog.batch(ops);
      return numEventsDeleted;
    });
  }
  dump() {
    var _a2, _b;
    return __awaiter20(this, void 0, void 0, function* () {
      console.group("db");
      yield (_b = (_a2 = this.db)["dump"]) === null || _b === void 0 ? void 0 : _b.call(_a2);
      console.groupEnd();
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/events/messages/events-get.js
var __awaiter21 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EventsGet2 = class extends Message {
  static parse(message2) {
    return __awaiter21(this, void 0, void 0, function* () {
      Message.validateJsonSchema(message2);
      yield validateAuthorizationIntegrity(message2);
      return new EventsGet2(message2);
    });
  }
  static create(options) {
    return __awaiter21(this, void 0, void 0, function* () {
      const descriptor2 = {
        interface: DwnInterfaceName.Events,
        method: DwnMethodName.Get
      };
      if (options.watermark) {
        descriptor2.watermark = options.watermark;
      }
      const authorization = yield Message.signAsAuthorization(descriptor2, options.authorizationSignatureInput);
      const message2 = { descriptor: descriptor2, authorization };
      Message.validateJsonSchema(message2);
      return new EventsGet2(message2);
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/core/message-reply.js
var MessageReply = class {
  constructor(opts) {
    const { status, entries, data } = opts;
    this.status = status;
    this.entries = entries;
    this.data = data;
  }
  static fromError(e2, code9) {
    const detail = e2 instanceof Error ? e2.message : "Error";
    return new MessageReply({ status: { code: code9, detail } });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/events/handlers/events-get.js
var __awaiter22 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EventsGetHandler = class {
  constructor(didResolver, eventLog) {
    this.didResolver = didResolver;
    this.eventLog = eventLog;
  }
  handle({ tenant, message: message2 }) {
    return __awaiter22(this, void 0, void 0, function* () {
      let eventsGet;
      try {
        eventsGet = yield EventsGet2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        yield authenticate(message2.authorization, this.didResolver);
        yield authorize(tenant, eventsGet);
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      let options;
      if (message2.descriptor.watermark) {
        options = { gt: message2.descriptor.watermark };
      }
      const events = yield this.eventLog.getEvents(tenant, options);
      return {
        status: { code: 200, detail: "OK" },
        events
      };
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/core/dwn-constant.js
var DwnConstant = class {
};
DwnConstant.maxDataSizeAllowedToBeEncoded = 1e4;

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/messages/messages/messages-get.js
var __awaiter23 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MessagesGet2 = class extends Message {
  static parse(message2) {
    return __awaiter23(this, void 0, void 0, function* () {
      Message.validateJsonSchema(message2);
      this.validateMessageCids(message2.descriptor.messageCids);
      yield validateAuthorizationIntegrity(message2);
      return new MessagesGet2(message2);
    });
  }
  static create(options) {
    return __awaiter23(this, void 0, void 0, function* () {
      const descriptor2 = {
        interface: DwnInterfaceName.Messages,
        method: DwnMethodName.Get,
        messageCids: options.messageCids
      };
      const authorization = yield Message.signAsAuthorization(descriptor2, options.authorizationSignatureInput);
      const message2 = { descriptor: descriptor2, authorization };
      Message.validateJsonSchema(message2);
      MessagesGet2.validateMessageCids(options.messageCids);
      return new MessagesGet2(message2);
    });
  }
  /**
   * validates the provided cids
   * @param messageCids - the cids in question
   * @throws {Error} if an invalid cid is found.
   */
  static validateMessageCids(messageCids) {
    for (const cid of messageCids) {
      try {
        parseCid(cid);
      } catch (_2) {
        throw new Error(`${cid} is not a valid CID`);
      }
    }
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/messages/handlers/messages-get.js
var __awaiter24 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MessagesGetHandler = class {
  constructor(didResolver, messageStore, dataStore) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
  }
  handle({ tenant, message: message2 }) {
    return __awaiter24(this, void 0, void 0, function* () {
      let messagesGet;
      try {
        messagesGet = yield MessagesGet2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        yield authenticate(message2.authorization, this.didResolver);
        yield authorize(tenant, messagesGet);
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      const promises = [];
      const messageCids = new Set(message2.descriptor.messageCids);
      for (const messageCid of messageCids) {
        const promise = this.messageStore.get(tenant, messageCid).then((message3) => {
          return { messageCid, message: message3 };
        }).catch((_2) => {
          return { messageCid, message: void 0, error: `Failed to get message ${messageCid}` };
        });
        promises.push(promise);
      }
      const messages = yield Promise.all(promises);
      for (const entry of messages) {
        const { message: message3 } = entry;
        if (!message3) {
          continue;
        }
        const { interface: messageInterface, method } = message3.descriptor;
        if (messageInterface !== DwnInterfaceName.Records || method !== DwnMethodName.Write) {
          continue;
        }
        const dataCid = message3.descriptor.dataCid;
        const dataSize = message3.descriptor.dataSize;
        if (dataCid !== void 0 && dataSize <= DwnConstant.maxDataSizeAllowedToBeEncoded) {
          const messageCid = yield Message.getCid(message3);
          const result = yield this.dataStore.get(tenant, messageCid, dataCid);
          if (result) {
            const dataBytes = yield DataStream.toBytes(result.dataStream);
            entry.encodedData = Encoder5.bytesToBase64Url(dataBytes);
          }
        }
      }
      return {
        status: { code: 200, detail: "OK" },
        messages
      };
    });
  }
};

// ../../node_modules/multiformats/src/block.js
function readonly4({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path, value) {
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (const [index, element] of value.entries()) {
        const elementPath = [...path, index];
        const cid = CID.asCID(element);
        if (cid) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links(element, elementPath);
        }
      }
    } else {
      const cid = CID.asCID(value);
      if (cid) {
        yield [path.join("/"), cid];
      } else {
        yield* links(value, path);
      }
    }
  }
}
function* links(source, base6) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID.asCID(source);
  if (cid) {
    yield [base6.join("/"), cid];
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base6, key]
    );
    yield* linksWithin(path, value);
  }
}
function* treeWithin(path, value) {
  if (Array.isArray(value)) {
    for (const [index, element] of value.entries()) {
      const elementPath = [...path, index];
      yield elementPath.join("/");
      if (typeof element === "object" && !CID.asCID(element)) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value, path);
  }
}
function* tree(source, base6) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base6, key]
    );
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      yield* treeWithin(path, value);
    }
  }
}
function get(source, path) {
  let node = (
    /** @type {Record<string, any>} */
    source
  );
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return { value: cid, remaining: path.slice(index + 1).join("/") };
    }
  }
  return { value: node };
}
var Block = class {
  /**
   * @param {object} options
   * @param {CID<T, C, A, V>} options.cid
   * @param {API.ByteView<T>} options.bytes
   * @param {T} options.value
   */
  constructor({ cid, bytes, value }) {
    if (!cid || !bytes || typeof value === "undefined") {
      throw new Error("Missing required argument");
    }
    this.cid = cid;
    this.bytes = bytes;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly4(),
      bytes: readonly4(),
      value: readonly4(),
      asBlock: readonly4()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  /**
   *
   * @param {string} [path]
   * @returns {API.BlockCursorView<unknown>}
   */
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
};
async function encode16({ value, codec, hasher }) {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes = codec.encode(value);
  const hash = await hasher.digest(bytes);
  const cid = CID.create(
    1,
    codec.code,
    hash
  );
  return new Block({ value, bytes, cid });
}
async function decode24({ bytes, codec, hasher }) {
  if (!bytes)
    throw new Error('Missing required argument "bytes"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const value = codec.decode(bytes);
  const hash = await hasher.digest(bytes);
  const cid = CID.create(1, codec.code, hash);
  return new Block({ value, bytes, cid });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/store/index-level.js
var __awaiter25 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues6 = function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve5, reject) {
        v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve5, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve5({ value: v3, done: d2 });
    }, reject);
  }
};
var IndexLevel = class {
  constructor(config) {
    this.config = Object.assign({ createLevelDatabase }, config);
    this.db = new LevelWrapper(Object.assign(Object.assign({}, this.config), { valueEncoding: "utf8" }));
  }
  open() {
    return __awaiter25(this, void 0, void 0, function* () {
      return this.db.open();
    });
  }
  close() {
    return __awaiter25(this, void 0, void 0, function* () {
      return this.db.close();
    });
  }
  put(id, entry, options) {
    return __awaiter25(this, void 0, void 0, function* () {
      entry = flatten2(entry);
      const ops = [];
      const prefixes = [];
      for (const property in entry) {
        const value = entry[property];
        const prefix = this.join(property, this.encodeValue(value));
        ops.push({ type: "put", key: this.join(prefix, id), value: id });
        prefixes.push(prefix);
      }
      ops.push({ type: "put", key: `__${id}__prefixes`, value: JSON.stringify(prefixes) });
      return this.db.batch(ops, options);
    });
  }
  query(filter2, options) {
    return __awaiter25(this, void 0, void 0, function* () {
      const requiredProperties = /* @__PURE__ */ new Set();
      const missingPropertiesForID = {};
      const promises = [];
      const matchedIDs = [];
      function checkMatches(property, promise) {
        var _a2;
        return __awaiter25(this, void 0, void 0, function* () {
          promises.push(promise);
          for (const [_2, id] of yield promise) {
            (_a2 = missingPropertiesForID[id]) !== null && _a2 !== void 0 ? _a2 : missingPropertiesForID[id] = /* @__PURE__ */ new Set([...requiredProperties]);
            missingPropertiesForID[id].delete(property);
            if (missingPropertiesForID[id].size === 0) {
              matchedIDs.push(id);
            }
          }
        });
      }
      for (const propertyName in filter2) {
        const propertyFilter = filter2[propertyName];
        if (typeof propertyFilter === "object" && propertyFilter !== null) {
          if (Array.isArray(propertyFilter)) {
            for (const propertyValue of new Set(propertyFilter)) {
              checkMatches(propertyName, this.findExactMatches(propertyName, propertyValue, options));
            }
          } else {
            checkMatches(propertyName, this.findRangeMatches(propertyName, propertyFilter, options));
          }
        } else {
          checkMatches(propertyName, this.findExactMatches(propertyName, propertyFilter, options));
        }
        requiredProperties.add(propertyName);
      }
      yield Promise.all(promises);
      return matchedIDs;
    });
  }
  delete(id, options) {
    return __awaiter25(this, void 0, void 0, function* () {
      const prefixes = yield this.db.get(`__${id}__prefixes`, options);
      if (!prefixes) {
        return;
      }
      const ops = [];
      for (const prefix of JSON.parse(prefixes)) {
        ops.push({ type: "del", key: this.join(prefix, id) });
      }
      ops.push({ type: "del", key: `__${id}__prefixes` });
      return this.db.batch(ops, options);
    });
  }
  clear() {
    return __awaiter25(this, void 0, void 0, function* () {
      return this.db.clear();
    });
  }
  findExactMatches(propertyName, propertyValue, options) {
    return __awaiter25(this, void 0, void 0, function* () {
      const propertyKey = this.join(propertyName, this.encodeValue(propertyValue));
      const iteratorOptions = {
        gt: propertyKey
      };
      return this.findMatches(propertyKey, iteratorOptions, options);
    });
  }
  findRangeMatches(propertyName, range, options) {
    return __awaiter25(this, void 0, void 0, function* () {
      const propertyKey = this.join(propertyName);
      const iteratorOptions = {};
      for (const comparator in range) {
        iteratorOptions[comparator] = this.join(propertyName, this.encodeValue(range[comparator]));
      }
      const matches = yield this.findMatches(propertyKey, iteratorOptions, options);
      if ("lte" in range) {
        for (const [key, value] of yield this.findExactMatches(propertyName, range.lte, options)) {
          matches.set(key, value);
        }
      }
      return matches;
    });
  }
  findMatches(propertyName, iteratorOptions, options) {
    var e_1, _a2;
    return __awaiter25(this, void 0, void 0, function* () {
      if (("lt" in iteratorOptions || "lte" in iteratorOptions) && !("gt" in iteratorOptions || "gte" in iteratorOptions)) {
        iteratorOptions.reverse = true;
      }
      const matches = /* @__PURE__ */ new Map();
      try {
        for (var _b = __asyncValues6(this.db.iterator(iteratorOptions, options)), _c; _c = yield _b.next(), !_c.done; ) {
          const [key, value] = _c.value;
          if (!key.startsWith(propertyName)) {
            break;
          }
          matches.set(key, value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return matches;
    });
  }
  encodeValue(value) {
    if (typeof value === "string") {
      return `"${value}"`;
    }
    return String(value);
  }
  join(...values) {
    return values.join(`\0`);
  }
  dump() {
    var _a2, _b;
    return __awaiter25(this, void 0, void 0, function* () {
      console.group("db");
      yield (_b = (_a2 = this.db)["dump"]) === null || _b === void 0 ? void 0 : _b.call(_a2);
      console.groupEnd();
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/store/message-store-level.js
var __awaiter26 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MessageStoreLevel = class {
  /**
   * @param {MessageStoreLevelConfig} config
   * @param {string} config.blockstoreLocation - must be a directory path (relative or absolute) where
   *  LevelDB will store its files, or in browsers, the name of the
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase IDBDatabase} to be opened.
   * @param {string} config.indexLocation - same as config.blockstoreLocation
   */
  constructor(config = {}) {
    this.config = Object.assign({ blockstoreLocation: "MESSAGESTORE", indexLocation: "INDEX", createLevelDatabase }, config);
    this.blockstore = new BlockstoreLevel({
      location: this.config.blockstoreLocation,
      createLevelDatabase: this.config.createLevelDatabase
    });
    this.index = new IndexLevel({
      location: this.config.indexLocation,
      createLevelDatabase: this.config.createLevelDatabase
    });
  }
  open() {
    return __awaiter26(this, void 0, void 0, function* () {
      yield this.blockstore.open();
      yield this.index.open();
    });
  }
  close() {
    return __awaiter26(this, void 0, void 0, function* () {
      yield this.blockstore.close();
      yield this.index.close();
    });
  }
  get(tenant, cidString, options) {
    var _a2;
    return __awaiter26(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      const partition = yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.blockstore.partition(tenant));
      const cid = CID.parse(cidString);
      const bytes = yield partition.get(cid, options);
      if (!bytes) {
        return void 0;
      }
      const decodedBlock = yield abortOr(options === null || options === void 0 ? void 0 : options.signal, decode24({ bytes, codec: src_exports, hasher: sha256 }));
      const messageJson = decodedBlock.value;
      return messageJson;
    });
  }
  query(tenant, filter2, options) {
    var _a2;
    return __awaiter26(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      const messages = [];
      const resultIds = yield this.index.query(Object.assign(Object.assign({}, filter2), { tenant }), options);
      for (const id of resultIds) {
        const message2 = yield this.get(tenant, id, options);
        if (message2) {
          messages.push(message2);
        }
      }
      return messages;
    });
  }
  delete(tenant, cidString, options) {
    var _a2;
    return __awaiter26(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      const partition = yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.blockstore.partition(tenant));
      const cid = CID.parse(cidString);
      yield partition.delete(cid, options);
      yield this.index.delete(cidString, options);
    });
  }
  put(tenant, message2, indexes, options) {
    var _a2;
    return __awaiter26(this, void 0, void 0, function* () {
      (_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.throwIfAborted();
      const partition = yield abortOr(options === null || options === void 0 ? void 0 : options.signal, this.blockstore.partition(tenant));
      const encodedMessageBlock = yield abortOr(options === null || options === void 0 ? void 0 : options.signal, encode16({ value: message2, codec: src_exports, hasher: sha256 }));
      yield partition.put(encodedMessageBlock.cid, encodedMessageBlock.bytes, options);
      const encodedMessageBlockCid = encodedMessageBlock.cid.toString();
      const indexDocument = Object.assign(Object.assign({}, indexes), { tenant });
      yield this.index.put(encodedMessageBlockCid, indexDocument, options);
    });
  }
  /**
   * deletes everything in the underlying blockstore and indices.
   */
  clear() {
    return __awaiter26(this, void 0, void 0, function* () {
      yield this.blockstore.clear();
      yield this.index.clear();
    });
  }
  dump() {
    var _a2, _b, _c, _d;
    return __awaiter26(this, void 0, void 0, function* () {
      console.group("blockstore");
      yield (_b = (_a2 = this.blockstore)["dump"]) === null || _b === void 0 ? void 0 : _b.call(_a2);
      console.groupEnd();
      console.group("index");
      yield (_d = (_c = this.index)["dump"]) === null || _d === void 0 ? void 0 : _d.call(_c);
      console.groupEnd();
    });
  }
};

// ../../node_modules/uuid/dist/esm-node/rng.js
var import_crypto2 = __toESM(require("crypto"));
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto2.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../node_modules/uuid/dist/esm-node/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../../node_modules/uuid/dist/esm-node/validate.js
function validate3(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate3;

// ../../node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// ../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf2, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf2) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf2[offset + i2] = rnds[i2];
    }
    return buf2;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/permissions/messages/permissions-request.js
var __awaiter27 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PermissionsRequest2 = class extends Message {
  static parse(message2) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield validateAuthorizationIntegrity(message2);
      return new PermissionsRequest2(message2);
    });
  }
  static create(options) {
    var _a2;
    return __awaiter27(this, void 0, void 0, function* () {
      const { conditions } = options;
      const providedConditions = conditions ? conditions : {};
      const mergedConditions = Object.assign(Object.assign({}, DEFAULT_CONDITIONS), providedConditions);
      const descriptor2 = {
        interface: DwnInterfaceName.Permissions,
        method: DwnMethodName.Request,
        dateCreated: (_a2 = options.dateCreated) !== null && _a2 !== void 0 ? _a2 : getCurrentTimeInHighPrecision(),
        conditions: mergedConditions,
        description: options.description,
        grantedTo: options.grantedTo,
        grantedBy: options.grantedBy,
        objectId: options.objectId ? options.objectId : v4_default(),
        scope: options.scope
      };
      Message.validateJsonSchema({ descriptor: descriptor2, authorization: {} });
      const auth = yield Message.signAsAuthorization(descriptor2, options.authorizationSignatureInput);
      const message2 = { descriptor: descriptor2, authorization: auth };
      return new PermissionsRequest2(message2);
    });
  }
  get id() {
    return this.message.descriptor.objectId;
  }
  get conditions() {
    return this.message.descriptor.conditions;
  }
  get grantedBy() {
    return this.message.descriptor.grantedBy;
  }
  get grantedTo() {
    return this.message.descriptor.grantedTo;
  }
  get description() {
    return this.message.descriptor.description;
  }
  get scope() {
    return this.message.descriptor.scope;
  }
};
var DEFAULT_CONDITIONS = {
  attestation: "optional",
  delegation: false,
  encryption: "optional",
  publication: false,
  sharedAccess: false
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/permissions/handlers/permissions-request.js
var __awaiter28 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PermissionsRequestHandler = class {
  constructor(didResolver, messageStore, dataStore) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
  }
  handle({ tenant, message: message2 }) {
    return __awaiter28(this, void 0, void 0, function* () {
      const permissionRequest = yield PermissionsRequest2.parse(message2);
      const { author } = permissionRequest;
      if (tenant !== permissionRequest.grantedBy && tenant !== permissionRequest.grantedTo) {
        return new MessageReply({
          status: { code: 400, detail: "grantedBy or grantedTo must be the targeted message recipient" }
        });
      }
      yield canonicalAuth(tenant, permissionRequest, this.didResolver);
      if (author !== permissionRequest.grantedTo) {
        throw new Error("grantee must be signer");
      }
      const index = Object.assign({ author }, message2.descriptor);
      yield this.messageStore.put(tenant, message2, index);
      return new MessageReply({
        status: { code: 202, detail: "Accepted" }
      });
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/protocols/messages/protocols-configure.js
var __awaiter29 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProtocolsConfigure2 = class extends Message {
  static parse(message2) {
    return __awaiter29(this, void 0, void 0, function* () {
      yield validateAuthorizationIntegrity(message2);
      return new ProtocolsConfigure2(message2);
    });
  }
  static create(options) {
    var _a2;
    return __awaiter29(this, void 0, void 0, function* () {
      const descriptor2 = {
        interface: DwnInterfaceName.Protocols,
        method: DwnMethodName.Configure,
        dateCreated: (_a2 = options.dateCreated) !== null && _a2 !== void 0 ? _a2 : getCurrentTimeInHighPrecision(),
        protocol: options.protocol,
        definition: options.definition
        // TODO: #139 - move definition out of the descriptor - https://github.com/TBD54566975/dwn-sdk-js/issues/139
      };
      Message.validateJsonSchema({ descriptor: descriptor2, authorization: {} });
      const authorization = yield Message.signAsAuthorization(descriptor2, options.authorizationSignatureInput);
      const message2 = { descriptor: descriptor2, authorization };
      const protocolsConfigure = new ProtocolsConfigure2(message2);
      return protocolsConfigure;
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/store/storage-controller.js
var __awaiter30 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StorageController = class {
  /**
   * Puts the given message and data in storage.
   * @throws {DwnError} with `DwnErrorCode.MessageStoreDataCidMismatch`
   *                    if the data stream resulted in a data CID that mismatches with `dataCid` in the given message
   * @throws {DwnError} with `DwnErrorCode.MessageStoreDataNotFound`
   *                    if `dataCid` in `descriptor` is given, and `dataStream` is not given, and data for the message does not exist already
   * @throws {DwnError} with `DwnErrorCode.MessageStoreDataSizeMismatch`
   *                    if `dataSize` in `descriptor` given mismatches the actual data size
   */
  static put(messageStore, dataStore, eventLog, tenant, message2, indexes, dataStream) {
    return __awaiter30(this, void 0, void 0, function* () {
      const messageCid = yield Message.getCid(message2);
      if (message2.descriptor.dataCid !== void 0) {
        let result;
        if (dataStream === void 0) {
          result = yield dataStore.associate(tenant, messageCid, message2.descriptor.dataCid);
        } else {
          result = yield dataStore.put(tenant, messageCid, message2.descriptor.dataCid, dataStream);
        }
        if (!result) {
          throw new DwnError(DwnErrorCode.MessageStoreDataNotFound, `data with dataCid ${message2.descriptor.dataCid} not found in store`);
        }
        if (message2.descriptor.dataSize !== result.dataSize) {
          yield dataStore.delete(tenant, messageCid, message2.descriptor.dataCid);
          throw new DwnError(DwnErrorCode.MessageStoreDataSizeMismatch, `actual data size ${result.dataSize} bytes does not match dataSize in descriptor: ${message2.descriptor.dataSize}`);
        }
        if (message2.descriptor.dataCid !== result.dataCid) {
          yield dataStore.delete(tenant, messageCid, message2.descriptor.dataCid);
          throw new DwnError(DwnErrorCode.MessageStoreDataCidMismatch, `actual data CID ${result.dataCid} does not match dataCid in descriptor: ${message2.descriptor.dataCid}`);
        }
      }
      yield messageStore.put(tenant, message2, indexes);
      yield eventLog.append(tenant, messageCid);
    });
  }
  static query(messageStore, dataStore, tenant, filter2) {
    return __awaiter30(this, void 0, void 0, function* () {
      const messages = yield messageStore.query(tenant, filter2);
      for (const message2 of messages) {
        const dataCid = message2.descriptor.dataCid;
        const dataSize = message2.descriptor.dataSize;
        if (dataCid !== void 0 && dataSize <= DwnConstant.maxDataSizeAllowedToBeEncoded) {
          const messageCid = yield Message.getCid(message2);
          const result = yield dataStore.get(tenant, messageCid, dataCid);
          if (result) {
            const dataBytes = yield DataStream.toBytes(result.dataStream);
            message2.encodedData = Encoder5.bytesToBase64Url(dataBytes);
          }
        }
      }
      return messages;
    });
  }
  static delete(messageStore, dataStore, tenant, message2) {
    return __awaiter30(this, void 0, void 0, function* () {
      const messageCid = yield Message.getCid(message2);
      if (message2.descriptor.dataCid !== void 0) {
        yield dataStore.delete(tenant, messageCid, message2.descriptor.dataCid);
      }
      yield messageStore.delete(tenant, messageCid);
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/protocols/handlers/protocols-configure.js
var __awaiter31 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProtocolsConfigureHandler = class {
  constructor(didResolver, messageStore, dataStore, eventLog) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
    this.eventLog = eventLog;
  }
  handle({ tenant, message: message2, dataStream }) {
    return __awaiter31(this, void 0, void 0, function* () {
      let protocolsConfigure;
      try {
        protocolsConfigure = yield ProtocolsConfigure2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        yield canonicalAuth(tenant, protocolsConfigure, this.didResolver);
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      const query = {
        interface: DwnInterfaceName.Protocols,
        method: DwnMethodName.Configure,
        protocol: message2.descriptor.protocol
      };
      const existingMessages = yield this.messageStore.query(tenant, query);
      let newestMessage = yield Message.getMessageWithLargestCid(existingMessages);
      let incomingMessageIsNewest = false;
      if (newestMessage === void 0 || (yield Message.isCidLarger(message2, newestMessage))) {
        incomingMessageIsNewest = true;
        newestMessage = message2;
      }
      let messageReply;
      if (incomingMessageIsNewest) {
        const { author } = protocolsConfigure;
        const indexes = Object.assign({ author }, message2.descriptor);
        yield StorageController.put(this.messageStore, this.dataStore, this.eventLog, tenant, message2, indexes, dataStream);
        messageReply = new MessageReply({
          status: { code: 202, detail: "Accepted" }
        });
      } else {
        messageReply = new MessageReply({
          status: { code: 409, detail: "Conflict" }
        });
      }
      const deletedMessageCids = [];
      for (const message3 of existingMessages) {
        if (yield Message.isCidLarger(newestMessage, message3)) {
          const messageCid = yield Message.getCid(message3);
          deletedMessageCids.push(messageCid);
          yield StorageController.delete(this.messageStore, this.dataStore, tenant, message3);
        }
      }
      yield this.eventLog.deleteEventsByCid(tenant, deletedMessageCids);
      return messageReply;
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/protocols/messages/protocols-query.js
var __awaiter32 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProtocolsQuery2 = class extends Message {
  static parse(message2) {
    return __awaiter32(this, void 0, void 0, function* () {
      yield validateAuthorizationIntegrity(message2);
      return new ProtocolsQuery2(message2);
    });
  }
  static create(options) {
    var _a2;
    return __awaiter32(this, void 0, void 0, function* () {
      const descriptor2 = {
        interface: DwnInterfaceName.Protocols,
        method: DwnMethodName.Query,
        dateCreated: (_a2 = options.dateCreated) !== null && _a2 !== void 0 ? _a2 : getCurrentTimeInHighPrecision(),
        filter: options.filter
      };
      removeUndefinedProperties(descriptor2);
      Message.validateJsonSchema({ descriptor: descriptor2, authorization: {} });
      const authorization = yield Message.signAsAuthorization(descriptor2, options.authorizationSignatureInput);
      const message2 = { descriptor: descriptor2, authorization };
      const protocolsQuery = new ProtocolsQuery2(message2);
      return protocolsQuery;
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/protocols/handlers/protocols-query.js
var __awaiter33 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var ProtocolsQueryHandler = class {
  constructor(didResolver, messageStore, dataStore) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
  }
  handle({ tenant, message: message2 }) {
    return __awaiter33(this, void 0, void 0, function* () {
      let protocolsQuery;
      try {
        protocolsQuery = yield ProtocolsQuery2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        yield canonicalAuth(tenant, protocolsQuery, this.didResolver);
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      const query = Object.assign({ interface: DwnInterfaceName.Protocols, method: DwnMethodName.Configure }, message2.descriptor.filter);
      removeUndefinedProperties(query);
      const messages = yield this.messageStore.query(tenant, query);
      const entries = [];
      for (const message3 of messages) {
        const { authorization: _2 } = message3, objectWithRemainingProperties = __rest(message3, ["authorization"]);
        entries.push(objectWithRemainingProperties);
      }
      return new MessageReply({
        status: { code: 200, detail: "OK" },
        entries
      });
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/encryption.js
var crypto5 = __toESM(require("crypto"), 1);
var eccrypto = __toESM(require_eccrypto(), 1);
var import_readable_stream3 = __toESM(require_ours(), 1);
var __awaiter34 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Encryption = class {
  /**
   * Encrypts the given plaintext stream using AES-256-CTR algorithm.
   */
  static aes256CtrEncrypt(key, initializationVector, plaintextStream) {
    return __awaiter34(this, void 0, void 0, function* () {
      const cipher = crypto5.createCipheriv("aes-256-ctr", key, initializationVector);
      const cipherStream = new import_readable_stream3.Readable({
        read() {
        }
      });
      plaintextStream.on("data", (chunk) => {
        const encryptedChunk = cipher.update(chunk);
        cipherStream.push(encryptedChunk);
      });
      plaintextStream.on("end", () => {
        const finalChunk = cipher.final();
        cipherStream.push(finalChunk);
        cipherStream.push(null);
      });
      plaintextStream.on("error", (err) => {
        cipherStream.emit("error", err);
      });
      return cipherStream;
    });
  }
  /**
   * Decrypts the given cipher stream using AES-256-CTR algorithm.
   */
  static aes256CtrDecrypt(key, initializationVector, cipherStream) {
    return __awaiter34(this, void 0, void 0, function* () {
      const decipher = crypto5.createDecipheriv("aes-256-ctr", key, initializationVector);
      const plaintextStream = new import_readable_stream3.Readable({
        read() {
        }
      });
      cipherStream.on("data", (chunk) => {
        const decryptedChunk = decipher.update(chunk);
        plaintextStream.push(decryptedChunk);
      });
      cipherStream.on("end", () => {
        const finalChunk = decipher.final();
        plaintextStream.push(finalChunk);
        plaintextStream.push(null);
      });
      cipherStream.on("error", (err) => {
        plaintextStream.emit("error", err);
      });
      return plaintextStream;
    });
  }
  /**
   * Encrypts the given plaintext using ECIES (Elliptic Curve Integrated Encryption Scheme) with SECP256K1.
   */
  static eciesSecp256k1Encrypt(uncompressedPublicKey, plaintext) {
    return __awaiter34(this, void 0, void 0, function* () {
      const publicKey = Buffer.from(uncompressedPublicKey);
      const { ciphertext, ephemPublicKey, iv, mac } = yield eccrypto.encrypt(publicKey, plaintext);
      return {
        ciphertext,
        ephemeralPublicKey: ephemPublicKey,
        initializationVector: iv,
        messageAuthenticationCode: mac
      };
    });
  }
  /**
   * Decrypt the given plaintext using ECIES (Elliptic Curve Integrated Encryption Scheme) with SECP256K1.
   */
  static eciesSecp256k1Decrypt(input) {
    return __awaiter34(this, void 0, void 0, function* () {
      const privateKeyBuffer = Buffer.from(input.privateKey);
      const ephemPublicKey = Buffer.from(input.ephemeralPublicKey);
      const eciesEncryptionOutput = {
        ciphertext: input.ciphertext,
        ephemPublicKey,
        iv: input.initializationVector,
        mac: input.messageAuthenticationCode
      };
      const plaintext = yield eccrypto.decrypt(privateKeyBuffer, eciesEncryptionOutput);
      return plaintext;
    });
  }
};
var EncryptionAlgorithm;
(function(EncryptionAlgorithm2) {
  EncryptionAlgorithm2["Aes256Ctr"] = "A256CTR";
  EncryptionAlgorithm2["EciesSecp256k1"] = "ECIES-ES256K";
})(EncryptionAlgorithm || (EncryptionAlgorithm = {}));

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/core/protocol-authorization.js
var __awaiter35 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var methodToAllowedActionMap = {
  [DwnMethodName.Write]: "write",
  [DwnMethodName.Read]: "read"
};
var ProtocolAuthorization = class {
  /**
   * Performs protocol-based authorization against the given message.
   * @throws {Error} if authorization fails.
   */
  static authorize(tenant, incomingMessage, requesterDid, messageStore) {
    return __awaiter35(this, void 0, void 0, function* () {
      const ancestorMessageChain = yield ProtocolAuthorization.constructAncestorMessageChain(tenant, incomingMessage, messageStore);
      const protocolDefinition = yield ProtocolAuthorization.fetchProtocolDefinition(tenant, incomingMessage, ancestorMessageChain, messageStore);
      const recordSchemaToLabelMap = /* @__PURE__ */ new Map();
      for (const schemaLabel in protocolDefinition.labels) {
        const schema = protocolDefinition.labels[schemaLabel].schema;
        recordSchemaToLabelMap.set(schema, schemaLabel);
      }
      const inboundMessageRuleSet = ProtocolAuthorization.getRuleSet(incomingMessage.message, protocolDefinition, ancestorMessageChain, recordSchemaToLabelMap);
      ProtocolAuthorization.verifyAllowedActions(tenant, requesterDid, incomingMessage.message.descriptor.method, inboundMessageRuleSet, ancestorMessageChain, recordSchemaToLabelMap);
      yield ProtocolAuthorization.verifyActionCondition(tenant, incomingMessage, messageStore);
    });
  }
  /**
   * Fetches the protocol definition based on the protocol specified in the given message.
   */
  static fetchProtocolDefinition(tenant, incomingMessage, ancestorMessageChain, messageStore) {
    return __awaiter35(this, void 0, void 0, function* () {
      let protocolUri;
      if (incomingMessage.message.descriptor.method === DwnMethodName.Write) {
        protocolUri = incomingMessage.message.descriptor.protocol;
      } else {
        protocolUri = ancestorMessageChain[ancestorMessageChain.length - 1].descriptor.protocol;
      }
      const query = {
        interface: DwnInterfaceName.Protocols,
        method: DwnMethodName.Configure,
        protocol: protocolUri
      };
      const protocols = yield messageStore.query(tenant, query);
      if (protocols.length === 0) {
        throw new Error(`unable to find protocol definition for ${protocolUri}`);
      }
      const protocolMessage = protocols[0];
      return protocolMessage.descriptor.definition;
    });
  }
  /**
   * Constructs a chain of ancestor messages
   * @returns the ancestor chain of messages where the first element is the root of the chain; returns empty array if no parent is specified.
   */
  static constructAncestorMessageChain(tenant, incomingMessage, messageStore) {
    return __awaiter35(this, void 0, void 0, function* () {
      const ancestorMessageChain = [];
      let recordsWrite;
      if (incomingMessage.message.descriptor.method === DwnMethodName.Write) {
        recordsWrite = incomingMessage;
      } else {
        const recordsRead = incomingMessage;
        const query = {
          interface: DwnInterfaceName.Records,
          method: DwnMethodName.Write,
          recordId: recordsRead.message.descriptor.recordId
        };
        const existingMessages = yield messageStore.query(tenant, query);
        const recordsWriteMessage = yield RecordsWrite2.getNewestMessage(existingMessages);
        recordsWrite = yield RecordsWrite2.parse(recordsWriteMessage);
        ancestorMessageChain.push(recordsWrite.message);
      }
      const protocol = recordsWrite.message.descriptor.protocol;
      const contextId = recordsWrite.message.contextId;
      let currentParentId = recordsWrite.message.descriptor.parentId;
      while (currentParentId !== void 0) {
        const query = {
          interface: DwnInterfaceName.Records,
          method: DwnMethodName.Write,
          protocol,
          contextId,
          recordId: currentParentId
        };
        const parentMessages = yield messageStore.query(tenant, query);
        if (parentMessages.length === 0) {
          throw new Error(`no parent found with ID ${currentParentId}`);
        }
        const parent = parentMessages[0];
        ancestorMessageChain.push(parent);
        currentParentId = parent.descriptor.parentId;
      }
      return ancestorMessageChain.reverse();
    });
  }
  /**
   * Gets the rule set corresponding to the given message chain.
   */
  static getRuleSet(inboundMessage, protocolDefinition, ancestorMessageChain, recordSchemaToLabelMap) {
    const messageChain = [...ancestorMessageChain];
    if (inboundMessage.descriptor.method === DwnMethodName.Write) {
      messageChain.push(inboundMessage);
    }
    let allowedRecordsAtCurrentLevel = protocolDefinition.records;
    let currentMessageIndex = 0;
    while (true) {
      const currentRecordSchema = messageChain[currentMessageIndex].descriptor.schema;
      const currentRecordType = recordSchemaToLabelMap.get(currentRecordSchema);
      if (currentRecordType === void 0) {
        throw new Error(`record with schema '${currentRecordSchema}' not allowed in protocol`);
      }
      if (allowedRecordsAtCurrentLevel === void 0 || !(currentRecordType in allowedRecordsAtCurrentLevel)) {
        throw new Error(`record with schema: '${currentRecordSchema}' not allowed in structure level ${currentMessageIndex}`);
      }
      if (currentMessageIndex === messageChain.length - 1) {
        return allowedRecordsAtCurrentLevel[currentRecordType];
      }
      allowedRecordsAtCurrentLevel = allowedRecordsAtCurrentLevel[currentRecordType].records;
      currentMessageIndex++;
    }
  }
  /**
   * Verifies the actions specified in the given message matches the allowed actions in the rule set.
   * @throws {Error} if action not allowed.
   */
  static verifyAllowedActions(tenant, requesterDid, incomingMessageMethod, inboundMessageRuleSet, ancestorMessageChain, recordSchemaToLabelMap) {
    const allowRule = inboundMessageRuleSet.allow;
    if (allowRule === void 0) {
      if (requesterDid === tenant) {
        return;
      } else {
        throw new Error(`no allow rule defined for ${incomingMessageMethod}, ${requesterDid} is unauthorized`);
      }
    }
    const allowedActions = /* @__PURE__ */ new Set();
    if (allowRule.anyone !== void 0) {
      allowRule.anyone.to.forEach((action) => allowedActions.add(action));
    }
    if (allowRule.author !== void 0) {
      const messageForAuthorCheck = ProtocolAuthorization.getMessage(ancestorMessageChain, allowRule.author.of, recordSchemaToLabelMap);
      if (messageForAuthorCheck !== void 0) {
        const expectedRequesterDid = Message.getAuthor(messageForAuthorCheck);
        if (requesterDid === expectedRequesterDid) {
          allowRule.author.to.forEach((action) => allowedActions.add(action));
        }
      }
    }
    if (allowRule.recipient !== void 0) {
      const messageForRecipientCheck = ProtocolAuthorization.getMessage(ancestorMessageChain, allowRule.recipient.of, recordSchemaToLabelMap);
      if (messageForRecipientCheck !== void 0) {
        const expectedRequesterDid = messageForRecipientCheck.descriptor.recipient;
        if (requesterDid === expectedRequesterDid) {
          allowRule.recipient.to.forEach((action) => allowedActions.add(action));
        }
      }
    }
    const inboundMessageAction = methodToAllowedActionMap[incomingMessageMethod];
    if (!allowedActions.has(inboundMessageAction)) {
      throw new Error(`inbound message action '${inboundMessageAction}' not in list of allowed actions (${new Array(...allowedActions).join(",")})`);
    }
  }
  /**
   * Verifies if the desired action can be taken.
   * Currently the only check is: if the write is not the initial write, the author must be the same as the initial write
   * @throws {Error} if fails verification
   */
  static verifyActionCondition(tenant, incomingMessage, messageStore) {
    return __awaiter35(this, void 0, void 0, function* () {
      if (incomingMessage.message.descriptor.method === DwnMethodName.Read) {
      } else if (incomingMessage.message.descriptor.method === DwnMethodName.Write) {
        const recordsWrite = incomingMessage;
        const isInitialWrite = yield recordsWrite.isInitialWrite();
        if (!isInitialWrite) {
          const query = {
            entryId: recordsWrite.message.recordId
          };
          const result = yield messageStore.query(tenant, query);
          const initialWrite = result[0];
          const authorOfInitialWrite = Message.getAuthor(initialWrite);
          if (recordsWrite.author !== authorOfInitialWrite) {
            throw new Error(`author of incoming message '${recordsWrite.author}' must match to author of initial write '${authorOfInitialWrite}'`);
          }
        }
      }
    });
  }
  /**
   * Gets the message from the message chain based on the path specified.
   * Returns undefined if matching message does not existing in ancestor chain
   * @param messagePath `/` delimited path starting from the root ancestor.
   *                    Each path segment denotes the expected record type declared in protocol definition.
   *                    e.g. `A/B/C` means that the root ancestor must be of type A, its child must be of type B, followed by a child of type C.
   *                    NOTE: the path scheme use here may be temporary dependent on final protocol spec.
   */
  static getMessage(ancestorMessageChain, messagePath, recordSchemaToLabelMap) {
    const expectedAncestors = messagePath.split("/");
    if (expectedAncestors.length > ancestorMessageChain.length) {
      return void 0;
    }
    let i2 = 0;
    while (true) {
      const expectedAncestorType = expectedAncestors[i2];
      const ancestorMessage = ancestorMessageChain[i2];
      const actualAncestorType = recordSchemaToLabelMap.get(ancestorMessage.descriptor.schema);
      if (actualAncestorType !== expectedAncestorType) {
        throw new Error(`mismatching record schema: expecting ${expectedAncestorType} but actual ${actualAncestorType}`);
      }
      if (i2 + 1 === expectedAncestors.length) {
        return ancestorMessage;
      }
      i2++;
    }
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/utils/records.js
var __awaiter36 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Records = class {
  /**
   * Decrypts the encrypted data in a message reply using the given ancestor private key.
   */
  static decrypt(recordsWrite, ancestorPrivateKey, cipherStream) {
    return __awaiter36(this, void 0, void 0, function* () {
      const { encryption, contextId, descriptor: descriptor2 } = recordsWrite;
      const matchingEncryptedKey = encryption.keyEncryption.find((key) => key.derivationScheme === ancestorPrivateKey.derivationScheme);
      if (matchingEncryptedKey === void 0) {
        throw new DwnError(DwnErrorCode.RecordsDecryptNoMatchingKeyDerivationScheme, `Unable to find symmetric key encrypted using '${ancestorPrivateKey.derivationScheme}' derivation scheme.`);
      }
      const leafDerivationPath = [KeyDerivationScheme.ProtocolContext, descriptor2.protocol, contextId];
      const leafPrivateKey = yield Records.deriveLeafPrivateKey(ancestorPrivateKey, leafDerivationPath);
      const encryptedKeyBytes = Encoder5.base64UrlToBytes(matchingEncryptedKey.encryptedKey);
      const ephemeralPublicKey = Secp256k1.publicJwkToBytes(matchingEncryptedKey.ephemeralPublicKey);
      const keyEncryptionInitializationVector = Encoder5.base64UrlToBytes(matchingEncryptedKey.initializationVector);
      const messageAuthenticationCode = Encoder5.base64UrlToBytes(matchingEncryptedKey.messageAuthenticationCode);
      const dataEncryptionKey = yield Encryption.eciesSecp256k1Decrypt({
        ciphertext: encryptedKeyBytes,
        ephemeralPublicKey,
        initializationVector: keyEncryptionInitializationVector,
        messageAuthenticationCode,
        privateKey: leafPrivateKey
      });
      const dataEncryptionInitializationVector = Encoder5.base64UrlToBytes(encryption.initializationVector);
      const plaintextStream = yield Encryption.aes256CtrDecrypt(dataEncryptionKey, dataEncryptionInitializationVector, cipherStream);
      return plaintextStream;
    });
  }
  /**
   * Derives a descendant public key given an ancestor public key.
   * NOTE: right now only `ECIES-ES256K` algorithm is supported for asymmetric encryption,
   *       so we will assume that's the algorithm without additional switch/if statements
   */
  static deriveLeafPublicKey(ancestorPublicKey, fullDescendantDerivationPath) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (ancestorPublicKey.derivedPublicKey.crv !== "secp256k1") {
        throw new DwnError(DwnErrorCode.RecordsDeriveLeafPublicKeyUnSupportedCurve, `Curve ${ancestorPublicKey.derivedPublicKey.crv} is not supported.`);
      }
      Records.validateAncestorKeyAndDescentKeyDerivationPathsMatch(ancestorPublicKey.derivationPath, fullDescendantDerivationPath);
      const subDerivationPath = fullDescendantDerivationPath.slice(ancestorPublicKey.derivationPath.length);
      const ancestorPublicKeyBytes = Secp256k1.publicJwkToBytes(ancestorPublicKey.derivedPublicKey);
      const leafPublicKey = yield Secp256k1.derivePublicKey(ancestorPublicKeyBytes, subDerivationPath);
      return leafPublicKey;
    });
  }
  /**
   * Derives a descendant private key given an ancestor private key.
   * NOTE: right now only `ECIES-ES256K` algorithm is supported for asymmetric encryption,
   *       so we will assume that's the algorithm without additional switch/if statements
   */
  static deriveLeafPrivateKey(ancestorPrivateKey, fullDescendantDerivationPath) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (ancestorPrivateKey.derivedPrivateKey.crv !== "secp256k1") {
        throw new DwnError(DwnErrorCode.RecordsDeriveLeafPrivateKeyUnSupportedCurve, `Curve ${ancestorPrivateKey.derivedPrivateKey.crv} is not supported.`);
      }
      Records.validateAncestorKeyAndDescentKeyDerivationPathsMatch(ancestorPrivateKey.derivationPath, fullDescendantDerivationPath);
      const subDerivationPath = fullDescendantDerivationPath.slice(ancestorPrivateKey.derivationPath.length);
      const ancestorPrivateKeyBytes = Secp256k1.privateJwkToBytes(ancestorPrivateKey.derivedPrivateKey);
      const leafPrivateKey = yield Secp256k1.derivePrivateKey(ancestorPrivateKeyBytes, subDerivationPath);
      return leafPrivateKey;
    });
  }
  /**
   * Validates that ancestor derivation path matches the descendant derivation path completely.
   * @throws {DwnError} with `DwnErrorCode.RecordsInvalidAncestorKeyDerivationSegment` if fails validation.
   */
  static validateAncestorKeyAndDescentKeyDerivationPathsMatch(ancestorKeyDerivationPath, descendantKeyDerivationPath) {
    for (let i2 = 0; i2 < ancestorKeyDerivationPath.length; i2++) {
      const ancestorSegment = ancestorKeyDerivationPath[i2];
      const descendantSegment = descendantKeyDerivationPath[i2];
      if (ancestorSegment !== descendantSegment) {
        throw new DwnError(DwnErrorCode.RecordsInvalidAncestorKeyDerivationSegment, `Ancestor key derivation segment '${ancestorSegment}' mismatches against the descendant key derivation segment '${descendantSegment}'.`);
      }
    }
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/messages/records-write.js
var __awaiter37 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RecordsWrite2 = class extends Message {
  constructor(message2) {
    super(message2);
    this.attesters = RecordsWrite2.getAttesters(message2);
  }
  static parse(message2) {
    return __awaiter37(this, void 0, void 0, function* () {
      yield validateAuthorizationIntegrity(message2, { allowedProperties: /* @__PURE__ */ new Set(["recordId", "contextId", "attestationCid", "encryptionCid"]) });
      yield RecordsWrite2.validateAttestationIntegrity(message2);
      const recordsWrite = new RecordsWrite2(message2);
      yield recordsWrite.validateIntegrity();
      return recordsWrite;
    });
  }
  /**
   * Creates a RecordsWrite message.
   * @param options.recordId If `undefined`, will be auto-filled as a originating message as convenience for developer.
   * @param options.data Data used to compute the `dataCid`, must be the encrypted data bytes if `options.encryptionInput` is given.
   *                     Must specify `options.dataCid` if `undefined`.
   * @param options.dataCid CID of the data that is already stored in the DWN. Must specify `options.data` if `undefined`.
   * @param options.dataSize Size of data in number of bytes. Must be defined if `options.dataCid` is defined; must be `undefined` otherwise.
   * @param options.dateCreated If `undefined`, it will be auto-filled with current time.
   * @param options.dateModified If `undefined`, it will be auto-filled with current time.
   */
  static create(options) {
    var _a2, _b, _c, _d, _e2;
    return __awaiter37(this, void 0, void 0, function* () {
      const currentTime = getCurrentTimeInHighPrecision();
      if (options.data === void 0 && options.dataCid === void 0 || options.data !== void 0 && options.dataCid !== void 0) {
        throw new Error("one and only one parameter between `data` and `dataCid` is allowed");
      }
      if (options.dataCid === void 0 && options.dataSize !== void 0 || options.dataCid !== void 0 && options.dataSize === void 0) {
        throw new Error("`dataCid` and `dataSize` must both be defined or undefined at the same time");
      }
      const dataCid = (_a2 = options.dataCid) !== null && _a2 !== void 0 ? _a2 : yield Cid.computeDagPbCidFromBytes(options.data);
      const dataSize = (_b = options.dataSize) !== null && _b !== void 0 ? _b : options.data.length;
      const descriptor2 = {
        interface: DwnInterfaceName.Records,
        method: DwnMethodName.Write,
        protocol: options.protocol,
        recipient: options.recipient,
        schema: options.schema,
        parentId: options.parentId,
        dataCid,
        dataSize,
        dateCreated: (_c = options.dateCreated) !== null && _c !== void 0 ? _c : currentTime,
        dateModified: (_d = options.dateModified) !== null && _d !== void 0 ? _d : currentTime,
        published: options.published,
        datePublished: options.datePublished,
        dataFormat: options.dataFormat
      };
      if (options.published === true && options.datePublished === void 0) {
        descriptor2.datePublished = currentTime;
      }
      removeUndefinedProperties(descriptor2);
      const author = Jws.extractDid(options.authorizationSignatureInput.protectedHeader.kid);
      const recordId = (_e2 = options.recordId) !== null && _e2 !== void 0 ? _e2 : yield RecordsWrite2.getEntryId(author, descriptor2);
      let contextId;
      if (options.contextId !== void 0) {
        contextId = options.contextId;
      } else {
        if (descriptor2.protocol !== void 0) {
          contextId = yield RecordsWrite2.getEntryId(author, descriptor2);
        }
      }
      const descriptorCid = yield computeCid(descriptor2);
      const attestation = yield RecordsWrite2.createAttestation(descriptorCid, options.attestationSignatureInputs);
      const encryption = yield RecordsWrite2.createEncryptionProperty(options.encryptionInput, descriptor2, contextId);
      const authorization = yield RecordsWrite2.createAuthorization(recordId, contextId, descriptorCid, attestation, encryption, options.authorizationSignatureInput);
      const message2 = {
        recordId,
        descriptor: descriptor2,
        authorization
      };
      if (contextId !== void 0) {
        message2.contextId = contextId;
      }
      if (attestation !== void 0) {
        message2.attestation = attestation;
      }
      if (encryption !== void 0) {
        message2.encryption = encryption;
      }
      Message.validateJsonSchema(message2);
      return new RecordsWrite2(message2);
    });
  }
  /**
   * Convenience method that creates a message by:
   * 1. Copying over immutable properties from the given unsigned message
   * 2. Copying over mutable properties that are not overwritten from the given unsigned message
   * 3. Replace the mutable properties that are given new value
   * @param options.unsignedRecordsWriteMessage Unsigned message that the new RecordsWrite will be based from.
   * @param options.dateModified The new date the record is modified. If not given, current time will be used .
   * @param options.data The new data or the record. If not given, data from given message will be used.
   * @param options.published The new published state. If not given, then will be set to `true` if {options.dateModified} is given;
   * else the state from given message will be used.
   * @param options.publishedDate The new date the record is modified. If not given, then:
   * - will not be set if the record will be unpublished as the result of this RecordsWrite; else
   * - will be set to the same published date as the given message if it wss already published; else
   * - will be set to current time (because this is a toggle from unpublished to published)
   */
  static createFrom(options) {
    var _a2, _b;
    return __awaiter37(this, void 0, void 0, function* () {
      const unsignedMessage = options.unsignedRecordsWriteMessage;
      const currentTime = getCurrentTimeInHighPrecision();
      const published = (_a2 = options.published) !== null && _a2 !== void 0 ? _a2 : options.datePublished ? true : unsignedMessage.descriptor.published;
      let datePublished = void 0;
      if (options.datePublished) {
        datePublished = options.datePublished;
      } else {
        if (published) {
          if (unsignedMessage.descriptor.published) {
            datePublished = unsignedMessage.descriptor.datePublished;
          } else {
            datePublished = currentTime;
          }
        }
      }
      const createOptions = {
        // immutable properties below, just inherit from the message given
        recipient: unsignedMessage.descriptor.recipient,
        recordId: unsignedMessage.recordId,
        dateCreated: unsignedMessage.descriptor.dateCreated,
        contextId: unsignedMessage.contextId,
        protocol: unsignedMessage.descriptor.protocol,
        parentId: unsignedMessage.descriptor.parentId,
        schema: unsignedMessage.descriptor.schema,
        dataFormat: unsignedMessage.descriptor.dataFormat,
        // mutable properties below
        dateModified: (_b = options.dateModified) !== null && _b !== void 0 ? _b : currentTime,
        published,
        datePublished,
        data: options.data,
        dataCid: options.data ? void 0 : unsignedMessage.descriptor.dataCid,
        dataSize: options.data ? void 0 : unsignedMessage.descriptor.dataSize,
        // finally still need input for signing
        authorizationSignatureInput: options.authorizationSignatureInput,
        attestationSignatureInputs: options.attestationSignatureInputs
      };
      const recordsWrite = yield RecordsWrite2.create(createOptions);
      return recordsWrite;
    });
  }
  authorize(tenant, messageStore) {
    return __awaiter37(this, void 0, void 0, function* () {
      if (this.message.descriptor.protocol !== void 0) {
        yield ProtocolAuthorization.authorize(tenant, this, this.author, messageStore);
      } else {
        yield authorize(tenant, this);
      }
    });
  }
  /**
   * Validates the integrity of the RecordsWrite message assuming the message passed basic schema validation.
   * There is opportunity to integrate better with `validateSchema(...)`
   */
  validateIntegrity() {
    return __awaiter37(this, void 0, void 0, function* () {
      if (this.message.recordId !== this.authorizationPayload.recordId) {
        throw new Error(`recordId in message ${this.message.recordId} does not match recordId in authorization: ${this.authorizationPayload.recordId}`);
      }
      const isInitialWrite = yield this.isInitialWrite();
      if (isInitialWrite) {
        const dateCreated = this.message.descriptor.dateCreated;
        const dateModified = this.message.descriptor.dateModified;
        if (dateModified !== dateCreated) {
          throw new Error(`dateModified ${dateModified} must match dateCreated ${dateCreated} for the initial write`);
        }
        if (this.message.descriptor.protocol !== void 0 && this.message.descriptor.parentId === void 0) {
          const expectedContextId = yield this.getEntryId();
          if (this.message.contextId !== expectedContextId) {
            throw new Error(`contextId in message: ${this.message.contextId} does not match deterministic contextId: ${expectedContextId}`);
          }
        }
      }
      if (this.message.contextId !== this.authorizationPayload.contextId) {
        throw new Error(`contextId in message ${this.message.contextId} does not match contextId in authorization: ${this.authorizationPayload.contextId}`);
      }
      if (this.authorizationPayload.attestationCid !== void 0) {
        const expectedAttestationCid = yield computeCid(this.message.attestation);
        const actualAttestationCid = this.authorizationPayload.attestationCid;
        if (actualAttestationCid !== expectedAttestationCid) {
          throw new Error(`CID ${expectedAttestationCid} of attestation property in message does not match attestationCid in authorization: ${actualAttestationCid}`);
        }
      }
      if (this.authorizationPayload.encryptionCid !== void 0) {
        const expectedEncryptionCid = yield computeCid(this.message.encryption);
        const actualEncryptionCid = this.authorizationPayload.encryptionCid;
        if (actualEncryptionCid !== expectedEncryptionCid) {
          throw new DwnError(DwnErrorCode.RecordsWriteValidateIntegrityEncryptionCidMismatch, `CID ${expectedEncryptionCid} of encryption property in message does not match encryptionCid in authorization: ${actualEncryptionCid}`);
        }
      }
    });
  }
  /**
   * Validates the structural integrity of the `attestation` property.
   * NOTE: signature is not verified.
   */
  static validateAttestationIntegrity(message2) {
    return __awaiter37(this, void 0, void 0, function* () {
      if (message2.attestation === void 0) {
        return;
      }
      if (message2.attestation.signatures.length !== 1) {
        throw new Error(`Currently implementation only supports 1 attester, but got ${message2.attestation.signatures.length}`);
      }
      const payloadJson = Jws.decodePlainObjectPayload(message2.attestation);
      const { descriptorCid } = payloadJson;
      const expectedDescriptorCid = yield computeCid(message2.descriptor);
      if (descriptorCid !== expectedDescriptorCid) {
        throw new Error(`descriptorCid ${descriptorCid} does not match expected descriptorCid ${expectedDescriptorCid}`);
      }
      const propertyCount = Object.keys(payloadJson).length;
      if (propertyCount > 1) {
        throw new Error(`Only 'descriptorCid' is allowed in attestation payload, but got ${propertyCount} properties.`);
      }
    });
  }
  /**
   * Computes the deterministic Entry ID of this message.
   */
  getEntryId() {
    return __awaiter37(this, void 0, void 0, function* () {
      const entryId = yield RecordsWrite2.getEntryId(this.author, this.message.descriptor);
      return entryId;
    });
  }
  /**
   * Computes the deterministic Entry ID of this message.
   */
  static getEntryId(author, descriptor2) {
    return __awaiter37(this, void 0, void 0, function* () {
      if (author === void 0) {
        throw new DwnError(DwnErrorCode.RecordsWriteGetEntryIdUndefinedAuthor, "Property `author` is needed to compute entry ID.");
      }
      const entryIdInput = Object.assign({}, descriptor2);
      entryIdInput.author = author;
      const cid = yield computeCid(entryIdInput);
      return cid;
    });
  }
  /**
   * Checks if the given message is the initial entry of a record.
   */
  isInitialWrite() {
    return __awaiter37(this, void 0, void 0, function* () {
      const entryId = yield this.getEntryId();
      return entryId === this.message.recordId;
    });
  }
  /**
   * Checks if the given message is the initial entry of a record.
   */
  static isInitialWrite(message2) {
    return __awaiter37(this, void 0, void 0, function* () {
      if (message2.descriptor.interface !== DwnInterfaceName.Records || message2.descriptor.method !== DwnMethodName.Write) {
        return false;
      }
      const recordsWriteMessage = message2;
      const author = Message.getAuthor(message2);
      const entryId = yield RecordsWrite2.getEntryId(author, recordsWriteMessage.descriptor);
      return entryId === recordsWriteMessage.recordId;
    });
  }
  /**
   * Creates the `encryption` property if encryption input is given. Else `undefined` is returned.
   */
  static createEncryptionProperty(encryptionInput, descriptor2, contextId) {
    var _a2, _b;
    return __awaiter37(this, void 0, void 0, function* () {
      if (encryptionInput === void 0) {
        return void 0;
      }
      const keyEncryption = [];
      for (const keyEncryptionInput of encryptionInput.keyEncryptionInputs) {
        const leafDerivationPath = [KeyDerivationScheme.ProtocolContext, descriptor2.protocol, contextId];
        const leafPublicKey = yield Records.deriveLeafPublicKey(keyEncryptionInput.publicKey, leafDerivationPath);
        const keyEncryptionOutput = yield Encryption.eciesSecp256k1Encrypt(leafPublicKey, encryptionInput.key);
        const encryptedKey = Encoder5.bytesToBase64Url(keyEncryptionOutput.ciphertext);
        const ephemeralPublicKey = yield Secp256k1.publicKeyToJwk(keyEncryptionOutput.ephemeralPublicKey);
        const keyEncryptionInitializationVector = Encoder5.bytesToBase64Url(keyEncryptionOutput.initializationVector);
        const messageAuthenticationCode = Encoder5.bytesToBase64Url(keyEncryptionOutput.messageAuthenticationCode);
        const encryptedKeyData = {
          algorithm: (_a2 = keyEncryptionInput.algorithm) !== null && _a2 !== void 0 ? _a2 : EncryptionAlgorithm.EciesSecp256k1,
          derivationScheme: keyEncryptionInput.publicKey.derivationScheme,
          encryptedKey,
          ephemeralPublicKey,
          initializationVector: keyEncryptionInitializationVector,
          messageAuthenticationCode
        };
        keyEncryption.push(encryptedKeyData);
      }
      const encryption = {
        algorithm: (_b = encryptionInput.algorithm) !== null && _b !== void 0 ? _b : EncryptionAlgorithm.Aes256Ctr,
        initializationVector: Encoder5.bytesToBase64Url(encryptionInput.initializationVector),
        keyEncryption
      };
      return encryption;
    });
  }
  /**
   * Creates the `attestation` property of a RecordsWrite message if given signature inputs; returns `undefined` otherwise.
   */
  static createAttestation(descriptorCid, signatureInputs) {
    return __awaiter37(this, void 0, void 0, function* () {
      if (signatureInputs === void 0 || signatureInputs.length === 0) {
        return void 0;
      }
      const attestationPayload = { descriptorCid };
      const attestationPayloadBytes = Encoder5.objectToBytes(attestationPayload);
      const signer = yield GeneralJwsSigner.create(attestationPayloadBytes, signatureInputs);
      return signer.getJws();
    });
  }
  /**
   * Creates the `authorization` property of a RecordsWrite message.
   */
  static createAuthorization(recordId, contextId, descriptorCid, attestation, encryption, signatureInput) {
    return __awaiter37(this, void 0, void 0, function* () {
      const authorizationPayload = {
        recordId,
        descriptorCid
      };
      const attestationCid = attestation ? yield computeCid(attestation) : void 0;
      const encryptionCid = encryption ? yield computeCid(encryption) : void 0;
      if (contextId !== void 0) {
        authorizationPayload.contextId = contextId;
      }
      if (attestationCid !== void 0) {
        authorizationPayload.attestationCid = attestationCid;
      }
      if (encryptionCid !== void 0) {
        authorizationPayload.encryptionCid = encryptionCid;
      }
      const authorizationPayloadBytes = Encoder5.objectToBytes(authorizationPayload);
      const signer = yield GeneralJwsSigner.create(authorizationPayloadBytes, [signatureInput]);
      return signer.getJws();
    });
  }
  /**
   * Gets the initial write from the given list or record write.
   */
  static getInitialWrite(messages) {
    return __awaiter37(this, void 0, void 0, function* () {
      for (const message2 of messages) {
        if (yield RecordsWrite2.isInitialWrite(message2)) {
          return message2;
        }
      }
      throw new Error(`initial write is not found`);
    });
  }
  /**
   * Verifies that immutable properties of the two given messages are identical.
   * @throws {Error} if immutable properties between two RecordsWrite message
   */
  static verifyEqualityOfImmutableProperties(existingWriteMessage, newMessage) {
    const mutableDescriptorProperties = ["dataCid", "dataSize", "datePublished", "published", "dateModified"];
    let descriptorPropertyNames = [];
    descriptorPropertyNames.push(...Object.keys(existingWriteMessage.descriptor));
    descriptorPropertyNames.push(...Object.keys(newMessage.descriptor));
    descriptorPropertyNames = [...new Set(descriptorPropertyNames)];
    for (const descriptorPropertyName of descriptorPropertyNames) {
      if (mutableDescriptorProperties.indexOf(descriptorPropertyName) === -1) {
        const valueInExistingWrite = existingWriteMessage.descriptor[descriptorPropertyName];
        const valueInNewMessage = newMessage.descriptor[descriptorPropertyName];
        if (valueInNewMessage !== valueInExistingWrite) {
          throw new Error(`${descriptorPropertyName} is an immutable property: cannot change '${valueInExistingWrite}' to '${valueInNewMessage}'`);
        }
      }
    }
    return true;
  }
  /**
   * Gets the DID of the author of the given message.
   */
  static getAttesters(message2) {
    var _a2, _b;
    const attestationSignatures = (_b = (_a2 = message2.attestation) === null || _a2 === void 0 ? void 0 : _a2.signatures) !== null && _b !== void 0 ? _b : [];
    const attesters = attestationSignatures.map((signature) => Jws.getSignerDid(signature));
    return attesters;
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/handlers/records-write.js
var __awaiter38 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RecordsWriteHandler = class {
  constructor(didResolver, messageStore, dataStore, eventLog) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
    this.eventLog = eventLog;
  }
  handle({ tenant, message: message2, dataStream }) {
    return __awaiter38(this, void 0, void 0, function* () {
      let recordsWrite;
      try {
        recordsWrite = yield RecordsWrite2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        yield authenticate(message2.authorization, this.didResolver);
        yield recordsWrite.authorize(tenant, this.messageStore);
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      const query = {
        interface: DwnInterfaceName.Records,
        recordId: message2.recordId
      };
      const existingMessages = yield this.messageStore.query(tenant, query);
      const newMessageIsInitialWrite = yield recordsWrite.isInitialWrite();
      if (!newMessageIsInitialWrite) {
        try {
          const initialWrite = yield RecordsWrite2.getInitialWrite(existingMessages);
          RecordsWrite2.verifyEqualityOfImmutableProperties(initialWrite, message2);
        } catch (e2) {
          return MessageReply.fromError(e2, 400);
        }
      }
      const newestExistingMessage = yield RecordsWrite2.getNewestMessage(existingMessages);
      let incomingMessageIsNewest = false;
      let newestMessage;
      if (newestExistingMessage === void 0 || (yield RecordsWrite2.isNewer(message2, newestExistingMessage))) {
        incomingMessageIsNewest = true;
        newestMessage = message2;
      } else {
        newestMessage = newestExistingMessage;
      }
      let messageReply;
      if (incomingMessageIsNewest) {
        const isLatestBaseState = true;
        const indexes = yield constructRecordsWriteIndexes(recordsWrite, isLatestBaseState);
        try {
          yield StorageController.put(this.messageStore, this.dataStore, this.eventLog, tenant, message2, indexes, dataStream);
        } catch (error) {
          const e2 = error;
          if (e2.code === DwnErrorCode.MessageStoreDataCidMismatch || e2.code === DwnErrorCode.MessageStoreDataNotFound || e2.code === DwnErrorCode.MessageStoreDataSizeMismatch) {
            return MessageReply.fromError(error, 400);
          }
          throw error;
        }
        messageReply = new MessageReply({
          status: { code: 202, detail: "Accepted" }
        });
      } else {
        messageReply = new MessageReply({
          status: { code: 409, detail: "Conflict" }
        });
      }
      yield deleteAllOlderMessagesButKeepInitialWrite(tenant, existingMessages, newestMessage, this.messageStore, this.dataStore, this.eventLog);
      return messageReply;
    });
  }
};
function constructRecordsWriteIndexes(recordsWrite, isLatestBaseState) {
  return __awaiter38(this, void 0, void 0, function* () {
    const message2 = recordsWrite.message;
    const descriptor2 = Object.assign({}, message2.descriptor);
    delete descriptor2.published;
    const indexes = Object.assign(Object.assign({}, descriptor2), { isLatestBaseState, published: !!message2.descriptor.published, author: recordsWrite.author, recordId: message2.recordId, entryId: yield RecordsWrite2.getEntryId(recordsWrite.author, recordsWrite.message.descriptor) });
    if (recordsWrite.attesters.length > 0) {
      indexes.attester = recordsWrite.attesters[0];
    }
    if (message2.contextId !== void 0) {
      indexes.contextId = message2.contextId;
    }
    return indexes;
  });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/records-interface.js
var __awaiter39 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function deleteAllOlderMessagesButKeepInitialWrite(tenant, existingMessages, comparedToMessage, messageStore, dataStore, eventLog) {
  return __awaiter39(this, void 0, void 0, function* () {
    const deletedMessageCids = [];
    for (const message2 of existingMessages) {
      const messageIsOld = yield Message.isOlder(message2, comparedToMessage);
      if (messageIsOld) {
        yield StorageController.delete(messageStore, dataStore, tenant, message2);
        const existingMessageIsInitialWrite = yield RecordsWrite2.isInitialWrite(message2);
        if (existingMessageIsInitialWrite) {
          const existingRecordsWrite = yield RecordsWrite2.parse(message2);
          const isLatestBaseState = false;
          const indexes = yield constructRecordsWriteIndexes(existingRecordsWrite, isLatestBaseState);
          yield messageStore.put(tenant, message2, indexes);
        } else {
          const messageCid = yield Message.getCid(message2);
          deletedMessageCids.push(messageCid);
        }
      }
      yield eventLog.deleteEventsByCid(tenant, deletedMessageCids);
    }
  });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/messages/records-delete.js
var __awaiter40 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RecordsDelete2 = class extends Message {
  static parse(message2) {
    return __awaiter40(this, void 0, void 0, function* () {
      yield validateAuthorizationIntegrity(message2);
      const recordsDelete = new RecordsDelete2(message2);
      return recordsDelete;
    });
  }
  /**
   * Creates a RecordsDelete message.
   * @param options.recordId If `undefined`, will be auto-filled as a originating message as convenience for developer.
   * @param options.dateModified If `undefined`, it will be auto-filled with current time.
   */
  static create(options) {
    var _a2;
    return __awaiter40(this, void 0, void 0, function* () {
      const recordId = options.recordId;
      const currentTime = getCurrentTimeInHighPrecision();
      const descriptor2 = {
        interface: DwnInterfaceName.Records,
        method: DwnMethodName.Delete,
        recordId,
        dateModified: (_a2 = options.dateModified) !== null && _a2 !== void 0 ? _a2 : currentTime
      };
      const authorization = yield Message.signAsAuthorization(descriptor2, options.authorizationSignatureInput);
      const message2 = { descriptor: descriptor2, authorization };
      Message.validateJsonSchema(message2);
      return new RecordsDelete2(message2);
    });
  }
  authorize(tenant) {
    return __awaiter40(this, void 0, void 0, function* () {
      yield authorize(tenant, this);
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/handlers/records-delete.js
var __awaiter41 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RecordsDeleteHandler = class {
  constructor(didResolver, messageStore, dataStore, eventLog) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
    this.eventLog = eventLog;
  }
  handle({ tenant, message: message2 }) {
    return __awaiter41(this, void 0, void 0, function* () {
      let recordsDelete;
      try {
        recordsDelete = yield RecordsDelete2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        yield authenticate(message2.authorization, this.didResolver);
        yield recordsDelete.authorize(tenant);
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      const query = {
        interface: DwnInterfaceName.Records,
        recordId: message2.descriptor.recordId
      };
      const existingMessages = yield this.messageStore.query(tenant, query);
      const newestExistingMessage = yield RecordsWrite2.getNewestMessage(existingMessages);
      let incomingMessageIsNewest = false;
      let newestMessage;
      if (newestExistingMessage === void 0 || (yield RecordsWrite2.isNewer(message2, newestExistingMessage))) {
        incomingMessageIsNewest = true;
        newestMessage = message2;
      } else {
        newestMessage = newestExistingMessage;
      }
      let messageReply;
      if (incomingMessageIsNewest) {
        const indexes = yield constructIndexes(tenant, recordsDelete);
        yield this.messageStore.put(tenant, message2, indexes);
        const messageCid = yield computeCid(message2);
        yield this.eventLog.append(tenant, messageCid);
        messageReply = new MessageReply({
          status: { code: 202, detail: "Accepted" }
        });
      } else {
        messageReply = new MessageReply({
          status: { code: 409, detail: "Conflict" }
        });
      }
      yield deleteAllOlderMessagesButKeepInitialWrite(tenant, existingMessages, newestMessage, this.messageStore, this.dataStore, this.eventLog);
      return messageReply;
    });
  }
};
function constructIndexes(tenant, recordsDelete) {
  return __awaiter41(this, void 0, void 0, function* () {
    const message2 = recordsDelete.message;
    const descriptor2 = Object.assign({}, message2.descriptor);
    const indexes = Object.assign({
      // isLatestBaseState : "true", // intentionally showing that this index is omitted
      author: recordsDelete.author
    }, descriptor2);
    return indexes;
  });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/handlers/records-query.js
var __awaiter42 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest2 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var RecordsQueryHandler = class {
  constructor(didResolver, messageStore, dataStore) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
  }
  handle({ tenant, message: message2 }) {
    return __awaiter42(this, void 0, void 0, function* () {
      let recordsQuery;
      try {
        recordsQuery = yield RecordsQuery2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        yield authenticate(message2.authorization, this.didResolver);
        yield recordsQuery.authorize(tenant);
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      let records;
      if (recordsQuery.author === tenant) {
        records = yield this.fetchRecordsAsOwner(tenant, recordsQuery);
      } else {
        records = yield this.fetchRecordsAsNonOwner(tenant, recordsQuery);
      }
      if (recordsQuery.message.descriptor.dateSort) {
        records = yield sortRecords(records, recordsQuery.message.descriptor.dateSort);
      }
      const entries = [];
      for (const record of records) {
        const { authorization: _2 } = record, objectWithRemainingProperties = __rest2(record, ["authorization"]);
        entries.push(objectWithRemainingProperties);
      }
      return new MessageReply({
        status: { code: 200, detail: "OK" },
        entries
      });
    });
  }
  /**
   * Fetches the records as the owner of the DWN with no additional filtering.
   */
  fetchRecordsAsOwner(tenant, recordsQuery) {
    return __awaiter42(this, void 0, void 0, function* () {
      const filter2 = Object.assign(Object.assign({}, RecordsQuery2.convertFilter(recordsQuery.message.descriptor.filter)), { interface: DwnInterfaceName.Records, method: DwnMethodName.Write, isLatestBaseState: true });
      const records = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter2);
      return records;
    });
  }
  /**
   * Fetches the records as a non-owner, return only:
   * 1. published records; and
   * 2. unpublished records intended for the requester (where `recipient` is the requester)
   */
  fetchRecordsAsNonOwner(tenant, recordsQuery) {
    return __awaiter42(this, void 0, void 0, function* () {
      const publishedRecords = yield this.fetchPublishedRecords(tenant, recordsQuery);
      const unpublishedRecordsForRequester = yield this.fetchUnpublishedRecordsForRequester(tenant, recordsQuery);
      const unpublishedRecordsByRequester = yield this.fetchUnpublishedRecordsByRequester(tenant, recordsQuery);
      const records = [...publishedRecords, ...unpublishedRecordsForRequester, ...unpublishedRecordsByRequester];
      return records;
    });
  }
  /**
   * Fetches only published records.
   */
  fetchPublishedRecords(tenant, recordsQuery) {
    return __awaiter42(this, void 0, void 0, function* () {
      const filter2 = Object.assign(Object.assign({}, RecordsQuery2.convertFilter(recordsQuery.message.descriptor.filter)), { interface: DwnInterfaceName.Records, method: DwnMethodName.Write, published: true, isLatestBaseState: true });
      const publishedRecords = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter2);
      return publishedRecords;
    });
  }
  /**
   * Fetches only unpublished records that are intended for the requester (where `recipient` is the requester).
   */
  fetchUnpublishedRecordsForRequester(tenant, recordsQuery) {
    return __awaiter42(this, void 0, void 0, function* () {
      const filter2 = Object.assign(Object.assign({}, RecordsQuery2.convertFilter(recordsQuery.message.descriptor.filter)), {
        interface: DwnInterfaceName.Records,
        method: DwnMethodName.Write,
        // TODO: `recordsQuery.author` cannot be undefined until #299 is implemented (https://github.com/TBD54566975/dwn-sdk-js/issues/299)
        recipient: recordsQuery.author,
        isLatestBaseState: true,
        published: false
      });
      const unpublishedRecordsForRequester = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter2);
      return unpublishedRecordsForRequester;
    });
  }
  /**
   * Fetches only unpublished records that are authored by the requester.
   */
  fetchUnpublishedRecordsByRequester(tenant, recordsQuery) {
    return __awaiter42(this, void 0, void 0, function* () {
      const filter2 = Object.assign(Object.assign({}, RecordsQuery2.convertFilter(recordsQuery.message.descriptor.filter)), {
        // TODO: `recordsQuery.author` cannot be undefined until #299 is implemented (https://github.com/TBD54566975/dwn-sdk-js/issues/299)
        author: recordsQuery.author,
        interface: DwnInterfaceName.Records,
        method: DwnMethodName.Write,
        isLatestBaseState: true,
        published: false
      });
      const unpublishedRecordsForRequester = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter2);
      return unpublishedRecordsForRequester;
    });
  }
};
function sortRecords(messages, dateSort) {
  return __awaiter42(this, void 0, void 0, function* () {
    switch (dateSort) {
      case DateSort.CreatedAscending:
        return messages.sort((a2, b2) => lexicographicalCompare(a2.descriptor.dateCreated, b2.descriptor.dateCreated));
      case DateSort.CreatedDescending:
        return messages.sort((a2, b2) => lexicographicalCompare(b2.descriptor.dateCreated, a2.descriptor.dateCreated));
      case DateSort.PublishedAscending:
        return messages.filter((m2) => m2.descriptor.published).sort((a2, b2) => lexicographicalCompare(a2.descriptor.datePublished, b2.descriptor.datePublished));
      case DateSort.PublishedDescending:
        return messages.filter((m2) => m2.descriptor.published).sort((a2, b2) => lexicographicalCompare(b2.descriptor.datePublished, a2.descriptor.datePublished));
    }
  });
}

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/messages/records-read.js
var __awaiter43 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RecordsRead2 = class extends Message {
  static parse(message2) {
    return __awaiter43(this, void 0, void 0, function* () {
      if (message2.authorization !== void 0) {
        yield validateAuthorizationIntegrity(message2);
      }
      const recordsRead = new RecordsRead2(message2);
      return recordsRead;
    });
  }
  /**
   * Creates a RecordsRead message.
   * @param options.recordId If `undefined`, will be auto-filled as a originating message as convenience for developer.
   * @param options.date If `undefined`, it will be auto-filled with current time.
   */
  static create(options) {
    var _a2;
    return __awaiter43(this, void 0, void 0, function* () {
      const { recordId, authorizationSignatureInput } = options;
      const currentTime = getCurrentTimeInHighPrecision();
      const descriptor2 = {
        interface: DwnInterfaceName.Records,
        method: DwnMethodName.Read,
        recordId,
        date: (_a2 = options.date) !== null && _a2 !== void 0 ? _a2 : currentTime
      };
      const authorization = authorizationSignatureInput ? yield Message.signAsAuthorization(descriptor2, authorizationSignatureInput) : void 0;
      const message2 = { descriptor: descriptor2, authorization };
      Message.validateJsonSchema(message2);
      return new RecordsRead2(message2);
    });
  }
  authorize(tenant, newestRecordsWrite, messageStore) {
    return __awaiter43(this, void 0, void 0, function* () {
      if (this.author === tenant) {
        return;
      } else if (newestRecordsWrite.message.descriptor.protocol !== void 0) {
        yield ProtocolAuthorization.authorize(tenant, this, this.author, messageStore);
      } else {
        throw new Error("message failed authorization");
      }
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/records/handlers/records-read.js
var __awaiter44 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest3 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var RecordsReadHandler = class {
  constructor(didResolver, messageStore, dataStore) {
    this.didResolver = didResolver;
    this.messageStore = messageStore;
    this.dataStore = dataStore;
  }
  handle({ tenant, message: message2 }) {
    return __awaiter44(this, void 0, void 0, function* () {
      let recordsRead;
      try {
        recordsRead = yield RecordsRead2.parse(message2);
      } catch (e2) {
        return MessageReply.fromError(e2, 400);
      }
      try {
        if (recordsRead.author !== void 0) {
          yield authenticate(message2.authorization, this.didResolver);
        }
      } catch (e2) {
        return MessageReply.fromError(e2, 401);
      }
      const query = {
        interface: DwnInterfaceName.Records,
        recordId: message2.descriptor.recordId
      };
      const existingMessages = yield this.messageStore.query(tenant, query);
      const newestExistingMessage = yield RecordsWrite2.getNewestMessage(existingMessages);
      if (newestExistingMessage === void 0 || newestExistingMessage.descriptor.method === DwnMethodName.Delete) {
        return new MessageReply({
          status: { code: 404, detail: "Not Found" }
        });
      }
      const newestRecordsWrite = newestExistingMessage;
      if (newestRecordsWrite.descriptor.published === true) {
      } else {
        try {
          yield recordsRead.authorize(tenant, yield RecordsWrite2.parse(newestRecordsWrite), this.messageStore);
        } catch (error) {
          return MessageReply.fromError(error, 401);
        }
      }
      const messageCid = yield Message.getCid(newestRecordsWrite);
      const result = yield this.dataStore.get(tenant, messageCid, newestRecordsWrite.descriptor.dataCid);
      if ((result === null || result === void 0 ? void 0 : result.dataStream) === void 0) {
        return new MessageReply({
          status: { code: 404, detail: "Not Found" }
        });
      }
      const { authorization: _2 } = newestRecordsWrite, recordsWriteWithoutAuthorization = __rest3(newestRecordsWrite, ["authorization"]);
      const messageReply = {
        status: { code: 200, detail: "OK" },
        record: Object.assign(Object.assign({}, recordsWriteWithoutAuthorization), { data: result.dataStream })
      };
      return messageReply;
    });
  }
};

// ../../node_modules/@tbd54566975/dwn-sdk-js/dist/esm/src/dwn.js
var __awaiter45 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve5) {
      resolve5(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve5, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Dwn = class {
  constructor(config) {
    this.didResolver = config.didResolver;
    this.messageStore = config.messageStore;
    this.dataStore = config.dataStore;
    this.eventLog = config.eventLog;
    this.tenantGate = config.tenantGate;
    this.methodHandlers = {
      [DwnInterfaceName.Events + DwnMethodName.Get]: new EventsGetHandler(this.didResolver, this.eventLog),
      [DwnInterfaceName.Messages + DwnMethodName.Get]: new MessagesGetHandler(this.didResolver, this.messageStore, this.dataStore),
      [DwnInterfaceName.Permissions + DwnMethodName.Request]: new PermissionsRequestHandler(this.didResolver, this.messageStore, this.dataStore),
      [DwnInterfaceName.Protocols + DwnMethodName.Configure]: new ProtocolsConfigureHandler(this.didResolver, this.messageStore, this.dataStore, this.eventLog),
      [DwnInterfaceName.Protocols + DwnMethodName.Query]: new ProtocolsQueryHandler(this.didResolver, this.messageStore, this.dataStore),
      [DwnInterfaceName.Records + DwnMethodName.Delete]: new RecordsDeleteHandler(this.didResolver, this.messageStore, this.dataStore, this.eventLog),
      [DwnInterfaceName.Records + DwnMethodName.Query]: new RecordsQueryHandler(this.didResolver, this.messageStore, this.dataStore),
      [DwnInterfaceName.Records + DwnMethodName.Read]: new RecordsReadHandler(this.didResolver, this.messageStore, this.dataStore),
      [DwnInterfaceName.Records + DwnMethodName.Write]: new RecordsWriteHandler(this.didResolver, this.messageStore, this.dataStore, this.eventLog)
    };
  }
  /**
   * Creates an instance of the DWN.
   */
  static create(config) {
    var _a2, _b, _c, _d, _e2;
    return __awaiter45(this, void 0, void 0, function* () {
      config !== null && config !== void 0 ? config : config = {};
      (_a2 = config.didResolver) !== null && _a2 !== void 0 ? _a2 : config.didResolver = new DidResolver();
      (_b = config.tenantGate) !== null && _b !== void 0 ? _b : config.tenantGate = new AllowAllTenantGate();
      (_c = config.messageStore) !== null && _c !== void 0 ? _c : config.messageStore = new MessageStoreLevel();
      (_d = config.dataStore) !== null && _d !== void 0 ? _d : config.dataStore = new DataStoreLevel();
      (_e2 = config.eventLog) !== null && _e2 !== void 0 ? _e2 : config.eventLog = new EventLogLevel();
      const dwn = new Dwn(config);
      yield dwn.open();
      return dwn;
    });
  }
  open() {
    return __awaiter45(this, void 0, void 0, function* () {
      yield this.messageStore.open();
      yield this.dataStore.open();
      yield this.eventLog.open();
    });
  }
  close() {
    return __awaiter45(this, void 0, void 0, function* () {
      this.messageStore.close();
      this.dataStore.close();
      this.eventLog.close();
    });
  }
  /**
   * Processes the given DWN message and returns with a reply.
   * @param tenant The tenant DID to route the given message to.
   */
  processMessage(tenant, rawMessage, dataStream) {
    var _a2, _b;
    return __awaiter45(this, void 0, void 0, function* () {
      const isTenant = yield this.tenantGate.isTenant(tenant);
      if (!isTenant) {
        return new MessageReply({
          status: { code: 401, detail: `${tenant} is not a tenant` }
        });
      }
      const dwnInterface = (_a2 = rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.descriptor) === null || _a2 === void 0 ? void 0 : _a2.interface;
      const dwnMethod = (_b = rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.descriptor) === null || _b === void 0 ? void 0 : _b.method;
      if (dwnInterface === void 0 || dwnMethod === void 0) {
        return new MessageReply({
          status: { code: 400, detail: `Both interface and method must be present, interface: ${dwnInterface}, method: ${dwnMethod}` }
        });
      }
      try {
        Message.validateJsonSchema(rawMessage);
      } catch (error) {
        return MessageReply.fromError(error, 400);
      }
      const handlerKey = dwnInterface + dwnMethod;
      const methodHandlerReply = yield this.methodHandlers[handlerKey].handle({
        tenant,
        message: rawMessage,
        dataStream
      });
      return methodHandlerReply;
    });
  }
  /**
   * Handles a `RecordsRead` message.
   */
  handleRecordsRead(tenant, message2) {
    return __awaiter45(this, void 0, void 0, function* () {
      const reply = yield this.processMessage(tenant, message2);
      return reply;
    });
  }
  /**
   * Handles a `MessagesGet` message.
   */
  handleMessagesGet(tenant, message2) {
    return __awaiter45(this, void 0, void 0, function* () {
      const reply = yield this.processMessage(tenant, message2);
      return reply;
    });
  }
  dump() {
    var _a2, _b, _c, _d, _e2, _f, _g, _h;
    return __awaiter45(this, void 0, void 0, function* () {
      console.group("didResolver");
      yield (_b = (_a2 = this.didResolver)["dump"]) === null || _b === void 0 ? void 0 : _b.call(_a2);
      console.groupEnd();
      console.group("messageStore");
      yield (_d = (_c = this.messageStore)["dump"]) === null || _d === void 0 ? void 0 : _d.call(_c);
      console.groupEnd();
      console.group("dataStore");
      yield (_f = (_e2 = this.dataStore)["dump"]) === null || _f === void 0 ? void 0 : _f.call(_e2);
      console.groupEnd();
      console.group("eventLog");
      yield (_h = (_g = this.eventLog)["dump"]) === null || _h === void 0 ? void 0 : _h.call(_g);
      console.groupEnd();
    });
  }
};

// src/web5-user-agent.ts
var dwnMessageCreators = {
  [DwnInterfaceName.Events + DwnMethodName.Get]: EventsGet2,
  [DwnInterfaceName.Messages + DwnMethodName.Get]: MessagesGet2,
  [DwnInterfaceName.Records + DwnMethodName.Read]: RecordsRead2,
  [DwnInterfaceName.Records + DwnMethodName.Query]: RecordsQuery2,
  [DwnInterfaceName.Records + DwnMethodName.Write]: RecordsWrite2,
  [DwnInterfaceName.Records + DwnMethodName.Delete]: RecordsDelete2,
  [DwnInterfaceName.Protocols + DwnMethodName.Query]: ProtocolsQuery2,
  [DwnInterfaceName.Protocols + DwnMethodName.Configure]: ProtocolsConfigure2
};
var Web5UserAgent = class {
  constructor(options) {
    this.dwn = options.dwn;
    this.profileManager = options.profileManager;
  }
  static create(options) {
    return __async(this, null, function* () {
      options.dwn || (options.dwn = yield Dwn.create());
      options.profileManager || (options.profileManager = new ProfileApi());
      return new Web5UserAgent(options);
    });
  }
  processDwnRequest(message2) {
    return __async(this, null, function* () {
      const profile = yield this.profileManager.getProfile(message2.author);
      if (!profile) {
        throw new Error("profile not found for author.");
      }
      const { keys } = profile.did;
      const [key] = keys;
      const { privateKeyJwk } = key;
      const kidFragment = privateKeyJwk.kid || key.id;
      const kid = `${profile.did.id}#${kidFragment}`;
      const dwnSignatureInput = {
        privateJwk: privateKeyJwk,
        protectedHeader: { alg: privateKeyJwk.crv, kid }
      };
      const messageCreateInput = __spreadProps(__spreadValues({}, message2.messageOptions), {
        authorizationSignatureInput: dwnSignatureInput
      });
      const messageCreator = dwnMessageCreators[message2.messageType];
      const dwnMessage = yield messageCreator.create(messageCreateInput);
      const reply = yield this.dwn.processMessage(message2.target, dwnMessage.toJSON(), message2.dataStream);
      return {
        reply,
        message: dwnMessage.toJSON()
      };
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ProfileApi,
  ProfileStore,
  Web5UserAgent
});
/*! Bundled license information:

es6-promise/dist/es6-promise.js:
  (*!
   * @overview es6-promise - a tiny implementation of Promises/A+.
   * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
   * @license   Licensed under MIT license
   *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
   * @version   v4.2.8+1e68dce6
   *)

@noble/ed25519/lib/esm/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@tbd54566975/dwn-sdk-js/dist/esm/src/interfaces/messages/handlers/messages-get.js:
  (*! NOTE: this is somewhat duplicate code that also exists in `StorageController.query`. *)
*/
//# sourceMappingURL=main.cjs.map
