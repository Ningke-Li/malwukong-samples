"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBridgeChainProvider = void 0;
const address_derivation_1 = require("../util/address-derivation");
const ethers_1 = require("ethers");
const Logger_1 = require("../../util/Logger");
const protocol_kit_1 = require("@safe-global/protocol-kit");
const crypto_1 = __importDefault(require("crypto"));
const BridgeDoorToken__factory_1 = require("@peersyst/xrp-evm-contracts/dist/typechain/factories/BridgeDoorToken__factory");
class EvmBridgeChainProvider {
    toEvmAddress(address) {
        if (address.startsWith("0x"))
            return address;
        else
            return (0, address_derivation_1.xrplAccountToEvmAddress)(address);
    }
    defaultSafeContractNetworks(chainId) {
        return {
            [chainId.toString()]: {
                safeMasterCopyAddress: "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
                safeProxyFactoryAddress: "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
                multiSendAddress: "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
                multiSendCallOnlyAddress: "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
                fallbackHandlerAddress: "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
                signMessageLibAddress: "0x03F886722b44BefB13871D4a05621D38616D3b7c",
                createCallAddress: "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
            },
        };
    }
    createBridgeWallet() {
        return undefined;
    }
    async fundAddress(fundingWallet, address, amount) {
        const result = await fundingWallet.sendTransaction({
            from: fundingWallet.address,
            to: address,
            value: ethers_1.ethers.utils.parseEther(amount.toString()),
            gasLimit: 300000,
        });
        await result.wait();
    }
    async setupAccounts(config, signer, witnesses) {
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Funding witnesses...");
        for (const witness of witnesses) {
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Working, `Funding witness ${witness}...`);
            await this.fundAddress(signer, witness, 1);
        }
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, "Witnesses funded");
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Setting up safe smart contract...`);
        const safeAddress = await this.setupSafe(config, signer, witnesses);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Safe smart contract set up at ${safeAddress}`);
        return safeAddress;
    }
    async setupSafe(config, signer, witnesses) {
        const ethAdapter = new protocol_kit_1.EthersAdapter({ ethers: ethers_1.ethers, signerOrProvider: signer });
        const safeFactory = await protocol_kit_1.SafeFactory.create({
            ethAdapter,
            contractNetworks: this.defaultSafeContractNetworks(await signer.getChainId()),
        });
        const safe = await safeFactory.deploySafe({
            safeAccountConfig: {
                threshold: config.threshold,
                owners: witnesses,
            },
            saltNonce: ethers_1.BigNumber.from(crypto_1.default.randomInt(1000000)).toString(),
            options: {
                gasLimit: 300000,
            },
        });
        return safe.getAddress();
    }
    async createIssuingChainBridge(config, lockingBridgeAddress) {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(config.issuingChain.url);
        const signerWallet = new ethers_1.ethers.Wallet(config.issuingChain.fundingPrivateKey, provider);
        const safeAddress = await this.setupAccounts(config, signerWallet, config.issuingChain.witnesses);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Setting up bridge smart contract ${lockingBridgeAddress} ${config.lockingChain.tokenIssuer}...`);
        const bridgeDoorTokenFactory = new BridgeDoorToken__factory_1.BridgeDoorToken__factory(signerWallet);
        const bridgeDoorToken = await bridgeDoorTokenFactory.deploy(safeAddress, ethers_1.ethers.utils.parseEther(config.minRewardAmount.toString()), this.toEvmAddress(lockingBridgeAddress), this.toEvmAddress(config.lockingChain.tokenIssuer), ethers_1.ethers.constants.AddressZero, ethers_1.ethers.constants.AddressZero, config.lockingChain.tokenCode, `Bridged ${config.lockingChain.tokenCode} (${config.lockingChain.tokenIssuer})`);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Bridge smart contract set up at ${bridgeDoorToken.address}`);
        return {
            address: bridgeDoorToken.address,
            config: {
                LockingChainDoor: this.toEvmAddress(lockingBridgeAddress),
                LockingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: this.toEvmAddress(config.lockingChain.tokenIssuer),
                },
                IssuingChainDoor: bridgeDoorToken.address,
                IssuingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: bridgeDoorToken.address,
                },
            },
        };
    }
    async createLockingChainBridge(config, issuingBridgeAddress) {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(config.lockingChain.url);
        const signerWallet = new ethers_1.ethers.Wallet(config.lockingChain.fundingPrivateKey, provider);
        const safeAddress = await this.setupAccounts(config, signerWallet, config.lockingChain.witnesses);
        const bridgeDoorTokenFactory = new BridgeDoorToken__factory_1.BridgeDoorToken__factory(signerWallet);
        const bridgeDoorToken = await bridgeDoorTokenFactory.deploy(safeAddress, ethers_1.ethers.utils.parseEther(config.minRewardAmount.toString()), ethers_1.ethers.constants.AddressZero, config.lockingChain.tokenIssuer, this.toEvmAddress(issuingBridgeAddress), this.toEvmAddress(issuingBridgeAddress), "", "");
        return {
            address: bridgeDoorToken.address,
            config: {
                LockingChainDoor: bridgeDoorToken.address,
                LockingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: config.lockingChain.tokenIssuer,
                },
                IssuingChainDoor: this.toEvmAddress(issuingBridgeAddress),
                IssuingChainIssue: {
                    currency: config.lockingChain.tokenCode,
                    issuer: this.toEvmAddress(issuingBridgeAddress),
                },
            },
        };
    }
}
exports.EvmBridgeChainProvider = EvmBridgeChainProvider;
//# sourceMappingURL=EvmBridgeChainProvider.js.map