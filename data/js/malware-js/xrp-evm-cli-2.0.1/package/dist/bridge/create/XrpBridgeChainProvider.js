"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrpBridgeChainProvider = void 0;
const xrpl_1 = require("xrpl");
const address_derivation_1 = require("../util/address-derivation");
const Logger_1 = require("../../util/Logger");
class XrpBridgeChainProvider {
    toXrpAddress(address) {
        if (!address.startsWith("0x"))
            return address;
        else
            return (0, address_derivation_1.evmAddressToXrplAccount)(address);
    }
    async setupSignerList(client, bridgeDoorWallet, witnesses, claimThreshold) {
        const signerListSet = await client.autofill({
            TransactionType: "SignerListSet",
            Account: bridgeDoorWallet.address,
            SignerQuorum: claimThreshold,
            SignerEntries: witnesses.map((w) => ({
                SignerEntry: {
                    Account: w,
                    SignerWeight: 1,
                },
            })),
        });
        const signed = bridgeDoorWallet.sign(signerListSet);
        await client.submit(signed.tx_blob);
    }
    async disableMasterKey(client, bridgeDoorWallet) {
        const signerListSet = await client.autofill({
            TransactionType: "AccountSet",
            Account: bridgeDoorWallet.address,
            SetFlag: xrpl_1.AccountSetAsfFlags.asfDisableMaster,
        });
        const signed = bridgeDoorWallet.sign(signerListSet);
        await client.submit(signed.tx_blob);
    }
    async createBridge(client, wallet, config, bridgeConfig) {
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Creating bridge...");
        const createBridge = await client.autofill({
            TransactionType: "XChainCreateBridge",
            Account: wallet.address,
            XChainBridge: bridgeConfig,
            // MinAccountCreateAmount: xrpToDrops(config.minCreateAmount),
            SignatureReward: (0, xrpl_1.xrpToDrops)(config.minRewardAmount),
        });
        // sign transaction
        const signed = wallet.sign(createBridge);
        await client.submit(signed.tx_blob);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, "Bridge created");
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Disabling bridge master key...");
        await this.disableMasterKey(client, wallet);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Bridge master key disabled`);
    }
    async fundAccount(client, address) {
        const { wallet } = await client.fundWallet({ address: address, classicAddress: address }, {
            faucetHost: "sidechain-faucet.devnet.rippletest.net",
        });
        return wallet;
    }
    async createTrustLine(client, wallet, issuerAddress, currencyCode) {
        await client.submit({
            TransactionType: "TrustSet",
            Account: wallet.address,
            LimitAmount: {
                currency: currencyCode,
                issuer: issuerAddress,
                value: "100000000000000",
            },
        }, {
            autofill: true,
            wallet: wallet,
        });
    }
    async setupAccounts(client, bridgeDoorWallet, witnesses, threshold, issuer, currencyCode) {
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Funding witnesses...");
        for (const witness of witnesses) {
            (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Working, `Funding witness ${witness}...`);
            await this.fundAccount(client, witness);
        }
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, "Witnesses funded");
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Creating bridge account...");
        await this.fundAccount(client, bridgeDoorWallet.address);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Bridge account created ${bridgeDoorWallet.address}`);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Creating bridge account trust line...");
        await this.createTrustLine(client, bridgeDoorWallet, issuer, currencyCode);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Bridge account trust line created`);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, "Setting up bridge account signer list...");
        await this.setupSignerList(client, bridgeDoorWallet, witnesses, threshold);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Bridge account signer list set up`);
        return bridgeDoorWallet;
    }
    createBridgeWallet() {
        return xrpl_1.Wallet.generate();
    }
    getLockingBridgeConfig(config, issuingBridgeAddress, bridgeWallet) {
        return {
            LockingChainDoor: bridgeWallet.address,
            LockingChainIssue: {
                currency: config.lockingChain.tokenCode,
                issuer: this.toXrpAddress(config.lockingChain.tokenIssuer),
            },
            IssuingChainDoor: this.toXrpAddress(issuingBridgeAddress),
            IssuingChainIssue: {
                currency: config.lockingChain.tokenCode,
                issuer: this.toXrpAddress(issuingBridgeAddress),
            },
        };
    }
    getIssuingBridgeConfig(config, lockingBridgeAddress, bridgeWallet) {
        return {
            LockingChainDoor: this.toXrpAddress(lockingBridgeAddress),
            LockingChainIssue: {
                currency: config.lockingChain.tokenCode,
                issuer: this.toXrpAddress(config.lockingChain.tokenIssuer),
            },
            IssuingChainDoor: bridgeWallet.address,
            IssuingChainIssue: {
                currency: config.lockingChain.tokenCode,
                issuer: bridgeWallet.address,
            },
        };
    }
    async createLockingChainBridge(config, issuingBridgeAddress, bridgeWallet) {
        const client = new xrpl_1.Client(config.lockingChain.url);
        await client.connect();
        const bridgeDoorWallet = await this.setupAccounts(client, bridgeWallet, config.lockingChain.witnesses, config.threshold, config.lockingChain.tokenIssuer, config.lockingChain.tokenCode);
        const bridgeConfig = this.getLockingBridgeConfig(config, issuingBridgeAddress, bridgeDoorWallet);
        await this.createBridge(client, bridgeDoorWallet, config, bridgeConfig);
        return { address: bridgeDoorWallet.address, config: bridgeConfig };
    }
    async createIssuingChainBridge(config, lockingBridgeAddress, bridgeWallet) {
        const client = new xrpl_1.Client(config.issuingChain.url);
        await client.connect();
        const bridgeDoorWallet = await this.setupAccounts(client, bridgeWallet, config.issuingChain.witnesses, config.threshold, config.lockingChain.tokenIssuer, config.lockingChain.tokenCode);
        const bridgeConfig = this.getLockingBridgeConfig(config, lockingBridgeAddress, bridgeDoorWallet);
        await this.createBridge(client, bridgeDoorWallet, config, bridgeConfig);
        return { address: bridgeDoorWallet.address, config: bridgeConfig };
    }
}
exports.XrpBridgeChainProvider = XrpBridgeChainProvider;
//# sourceMappingURL=XrpBridgeChainProvider.js.map