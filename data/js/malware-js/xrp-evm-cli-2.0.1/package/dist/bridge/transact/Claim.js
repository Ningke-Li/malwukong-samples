"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const Logger_1 = require("../../util/Logger");
const BridgeConfig_1 = require("../core/BridgeConfig");
const fs = __importStar(require("fs"));
const ChainProviderFactory_1 = require("../core/ChainProviderFactory");
const parse = (args) => {
    const validNumber = (n) => !isNaN(Number(n)) && Number(n) >= 0;
    if (args.origin && (args.origin == "xrp" || args.origin == "evm") && args.config && validNumber(args.amount)) {
        return {
            direction: args.origin === "xrp" ? ChainProviderFactory_1.BridgeDirection.XRP_TO_EVM : ChainProviderFactory_1.BridgeDirection.EVM_TO_XRP,
            bridgeConfig: new BridgeConfig_1.BridgeConfig(JSON.parse(fs.readFileSync(args.config).toString())),
            amount: Number(args.amount),
        };
    }
    return undefined;
};
const program = new commander_1.Command("claim")
    .option("-o, --origin <xrp|evm>", "Origin chain to execute the claim")
    .option("-op, --origin-private-key <value>", "Origin private key")
    .option("-dp, --destination-private-key <value>", "Destination private key")
    .option("-c, --config <value>", "Exported bridge config json file")
    .option("-a, --amount <number>", "Amount")
    .action(async (args) => {
    const parsedArgs = parse(args);
    if (parsedArgs) {
        const { bridgeConfig, direction } = parsedArgs;
        const providers = (0, ChainProviderFactory_1.createProviders)(direction, bridgeConfig);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Initializing providers...`);
        await (0, ChainProviderFactory_1.initProviders)(providers);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Providers initialized`);
        const sourceProvider = await providers[direction].source;
        const destinationProvider = await providers[direction].destination;
        let originAccount, destinationAccount;
        if (args.originPrivateKey) {
            originAccount = {
                address: sourceProvider.getAddressFromPrivateKey(args.originPrivateKey),
                privateKey: args.originPrivateKey,
            };
        }
        else {
            originAccount = {
                address: sourceProvider.getMasterAddress(),
                privateKey: sourceProvider.getMasterPrivateKey(),
            };
        }
        if (args.destinationPrivateKey) {
            destinationAccount = {
                address: destinationProvider.getAddressFromPrivateKey(args.destinationPrivateKey),
                privateKey: args.destinationPrivateKey,
            };
        }
        else {
            destinationAccount = {
                address: destinationProvider.getMasterAddress(),
                privateKey: destinationProvider.getMasterPrivateKey(),
            };
        }
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Creating claim id from ${destinationAccount.address} to ${originAccount.address}...`);
        const claimId = await destinationProvider.createClaim(destinationAccount.privateKey, sourceProvider.getOtherChainAddress(originAccount.address));
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Claim created with id ${claimId}`);
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.ToDo, `Creating commit from ${originAccount.address} to ${destinationAccount.address}...`);
        await sourceProvider.commit(originAccount.privateKey, claimId, parsedArgs.amount, destinationProvider.getOtherChainAddress(destinationAccount.address));
        (0, Logger_1.Log)(Logger_1.LogType.Bridge, Logger_1.LogStatus.Done, `Created commit successfully`);
        process.exit(0);
    }
    else {
        program.help();
        process.exit(1);
    }
});
exports.default = program;
//# sourceMappingURL=Claim.js.map